(window.webpackJsonp = window.webpackJsonp || []).push([
        [1], { 0: function(t, e, i) { t.exports = i("zUnb") }, "8/JR": function(t, e, i) { "use strict"; var n = i("8T9/"),
                    s = i("Ibf7");
                t.exports = function(t, e) { var i = e || {},
                        r = {}; return void 0 === t && (t = {}), t.on = function(e, i) { return r[e] ? r[e].push(i) : r[e] = [i], t }, t.once = function(e, i) { return i._once = !0, t.on(e, i), t }, t.off = function(e, i) { var n = arguments.length; if (1 === n) delete r[e];
                        else if (0 === n) r = {};
                        else { var s = r[e]; if (!s) return t;
                            s.splice(s.indexOf(i), 1) } return t }, t.emit = function() { var e = n(arguments); return t.emitterSnapshot(e.shift()).apply(this, e) }, t.emitterSnapshot = function(e) { var a = (r[e] || []).slice(0); return function() { var r = n(arguments),
                                o = this || t; if ("error" === e && !1 !== i.throws && !a.length) throw 1 === r.length ? r[0] : r; return a.forEach((function(n) { i.async ? s(n, r, o) : n.apply(o, r), n._once && t.off(e, n) })), t } }, t } }, "8T9/": function(t, e) { t.exports = function(t, e) { return Array.prototype.slice.call(t, e) } }, Gjsa: function(t, e) { var i = "function" == typeof setImmediate;
                t.exports = i ? function(t) { setImmediate(t) } : function(t) { setTimeout(t, 0) } }, Ibf7: function(t, e, i) { "use strict"; var n = i("Gjsa");
                t.exports = function(t, e, i) { t && n((function() { t.apply(i || null, e || []) })) } }, KRns: function(t, e) { var i = global.CustomEvent;
                t.exports = function() { try { var t = new i("cat", { detail: { foo: "bar" } }); return "cat" === t.type && "bar" === t.detail.foo } catch (e) {} return !1 }() ? i : "function" == typeof document.createEvent ? function(t, e) { var i = document.createEvent("CustomEvent"); return e ? i.initCustomEvent(t, e.bubbles, e.cancelable, e.detail) : i.initCustomEvent(t, !1, !1, void 0), i } : function(t, e) { var i = document.createEventObject(); return i.type = t, e ? (i.bubbles = Boolean(e.bubbles), i.cancelable = Boolean(e.cancelable), i.detail = e.detail) : (i.bubbles = !1, i.cancelable = !1, i.detail = void 0), i } }, PzH3: function(t, e, i) { "use strict"; var n = i("KRns"),
                    s = i("Ys8N"),
                    r = global.document,
                    a = function(t, e, i, n) { return t.addEventListener(e, i, n) },
                    o = function(t, e, i, n) { return t.removeEventListener(e, i, n) },
                    l = [];

                function c(t, e, i) { var n = function(t, e, i) { var n, s; for (n = 0; n < l.length; n++)
                            if ((s = l[n]).element === t && s.type === e && s.fn === i) return n }(t, e, i); if (n) { var s = l[n].wrapper; return l.splice(n, 1), s } } global.addEventListener || (a = function(t, e, i) { return t.attachEvent("on" + e, function(t, e, i) { var n = c(t, e, i) || function(t, e, i) { return function(e) { var n = e || global.event;
                                n.target = n.target || n.srcElement, n.preventDefault = n.preventDefault || function() { n.returnValue = !1 }, n.stopPropagation = n.stopPropagation || function() { n.cancelBubble = !0 }, n.which = n.which || n.keyCode, i.call(t, n) } }(t, 0, i); return l.push({ wrapper: n, element: t, type: e, fn: i }), n }(t, e, i)) }, o = function(t, e, i) { var n = c(t, e, i); if (n) return t.detachEvent("on" + e, n) }), t.exports = { add: a, remove: o, fabricate: function(t, e, i) { var a = -1 === s.indexOf(e) ? new n(e, { detail: i }) : function() { var t; return r.createEvent ? (t = r.createEvent("Event")).initEvent(e, !0, !0) : r.createEventObject && (t = r.createEventObject()), t }();
                        t.dispatchEvent ? t.dispatchEvent(a) : t.fireEvent("on" + e, a) } } }, YS7c: function(t, e, i) { "use strict"; var n = i("8/JR"),
                    s = i("PzH3"),
                    r = i("n6yW"),
                    a = document,
                    o = a.documentElement;

                function l(t, e, i, n) { global.navigator.pointerEnabled ? s[e](t, { mouseup: "pointerup", mousedown: "pointerdown", mousemove: "pointermove" } [i], n) : global.navigator.msPointerEnabled ? s[e](t, { mouseup: "MSPointerUp", mousedown: "MSPointerDown", mousemove: "MSPointerMove" } [i], n) : (s[e](t, { mouseup: "touchend", mousedown: "touchstart", mousemove: "touchmove" } [i], n), s[e](t, i, n)) }

                function c(t) { if (void 0 !== t.touches) return t.touches.length; if (void 0 !== t.which && 0 !== t.which) return t.which; if (void 0 !== t.buttons) return t.buttons; var e = t.button; return void 0 !== e ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : void 0 }

                function h(t) { var e = t.getBoundingClientRect(); return { left: e.left + d("scrollLeft", "pageXOffset"), top: e.top + d("scrollTop", "pageYOffset") } }

                function d(t, e) { return void 0 !== global[e] ? global[e] : o.clientHeight ? o[t] : a.body[t] }

                function u(t, e, i) { var n, s = t || {},
                        r = s.className; return s.className += " gu-hide", n = a.elementFromPoint(e, i), s.className = r, n }

                function m() { return !1 }

                function p() { return !0 }

                function f(t) { return t.width || t.right - t.left }

                function g(t) { return t.height || t.bottom - t.top }

                function _(t) { return t.parentNode === a ? null : t.parentNode }

                function b(t) { return "INPUT" === t.tagName || "TEXTAREA" === t.tagName || "SELECT" === t.tagName || function t(e) { return !!e && "false" !== e.contentEditable && ("true" === e.contentEditable || t(_(e))) }(t) }

                function y(t) { return t.nextElementSibling || function() { var e = t;
                        do { e = e.nextSibling } while (e && 1 !== e.nodeType); return e }() }

                function v(t, e) { var i = function(t) { return t.targetTouches && t.targetTouches.length ? t.targetTouches[0] : t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : t }(e),
                        n = { pageX: "clientX", pageY: "clientY" }; return t in n && !(t in i) && n[t] in i && (t = n[t]), i[t] } t.exports = function(t, e) { var i, d, w, C, x, S, k, E, D, A, I, T = arguments.length;
                    1 === T && !1 === Array.isArray(t) && (e = t, t = []); var O, R = null,
                        M = e || {};
                    void 0 === M.moves && (M.moves = p), void 0 === M.accepts && (M.accepts = p), void 0 === M.invalid && (M.invalid = q), void 0 === M.containers && (M.containers = t || []), void 0 === M.isContainer && (M.isContainer = m), void 0 === M.copy && (M.copy = !1), void 0 === M.copySortSource && (M.copySortSource = !1), void 0 === M.revertOnSpill && (M.revertOnSpill = !1), void 0 === M.removeOnSpill && (M.removeOnSpill = !1), void 0 === M.direction && (M.direction = "vertical"), void 0 === M.ignoreInputTextSelection && (M.ignoreInputTextSelection = !0), void 0 === M.mirrorContainer && (M.mirrorContainer = a.body); var P = n({ containers: M.containers, start: $, end: Y, cancel: J, remove: Q, destroy: V, canMove: G, dragging: !1 }); return !0 === M.removeOnSpill && P.on("over", st).on("out", rt), N(), P;

                    function F(t) { return -1 !== P.containers.indexOf(t) || M.isContainer(t) }

                    function N(t) { var e = t ? "remove" : "add";
                        l(o, e, "mousedown", U), l(o, e, "mouseup", K) }

                    function L(t) { l(o, t ? "remove" : "add", "mousemove", H) }

                    function B(t) { var e = t ? "remove" : "add";
                        s[e](o, "selectstart", z), s[e](o, "click", z) }

                    function V() { N(!0), K({}) }

                    function z(t) { O && t.preventDefault() }

                    function U(t) { if (S = t.clientX, k = t.clientY, 1 === c(t) && !t.metaKey && !t.ctrlKey) { var e = t.target,
                                i = j(e);
                            i && (O = i, L(), "mousedown" === t.type && (b(e) ? e.focus() : t.preventDefault())) } }

                    function H(t) { if (O)
                            if (0 !== c(t)) { if (void 0 === t.clientX || t.clientX !== S || void 0 === t.clientY || t.clientY !== k) { if (M.ignoreInputTextSelection) { var e = v("clientX", t),
                                            i = v("clientY", t); if (b(a.elementFromPoint(e, i))) return } var n = O;
                                    L(!0), B(), Y(), W(n); var s = h(w);
                                    C = v("pageX", t) - s.left, x = v("pageY", t) - s.top, r.add(A || w, "gu-transit"), at(), nt(t) } } else K({}) }

                    function j(t) { if (!(P.dragging && i || F(t))) { for (var e = t; _(t) && !1 === F(_(t));) { if (M.invalid(t, e)) return; if (!(t = _(t))) return } var n = _(t); if (n && !M.invalid(t, e) && M.moves(t, n, e, y(t))) return { item: t, source: n } } }

                    function G(t) { return !!j(t) }

                    function $(t) { var e = j(t);
                        e && W(e) }

                    function W(t) { ht(t.item, t.source) && (A = t.item.cloneNode(!0), P.emit("cloned", A, t.item, "copy")), d = t.source, w = t.item, E = D = y(t.item), P.dragging = !0, P.emit("drag", w, d) }

                    function q() { return !1 }

                    function Y() { if (P.dragging) { var t = A || w;
                            Z(t, _(t)) } }

                    function X() { O = !1, L(!0), B(!0) }

                    function K(t) { if (X(), P.dragging) { var e = A || w,
                                n = v("clientX", t),
                                s = v("clientY", t),
                                r = it(u(i, n, s), n, s);
                            r && (A && M.copySortSource || !A || r !== d) ? Z(e, r) : M.removeOnSpill ? Q() : J() } }

                    function Z(t, e) { var i = _(t);
                        A && M.copySortSource && e === d && i.removeChild(w), et(e) ? P.emit("cancel", t, d, d) : P.emit("drop", t, e, d, D), tt() }

                    function Q() { if (P.dragging) { var t = A || w,
                                e = _(t);
                            e && e.removeChild(t), P.emit(A ? "cancel" : "remove", t, e, d), tt() } }

                    function J(t) { if (P.dragging) { var e = arguments.length > 0 ? t : M.revertOnSpill,
                                i = A || w,
                                n = _(i),
                                s = et(n);!1 === s && e && (A ? n && n.removeChild(A) : d.insertBefore(i, E)), s || e ? P.emit("cancel", i, d, d) : P.emit("drop", i, n, d, D), tt() } }

                    function tt() { var t = A || w;
                        X(), ot(), t && r.rm(t, "gu-transit"), I && clearTimeout(I), P.dragging = !1, R && P.emit("out", t, R, d), P.emit("dragend", t), d = w = A = E = D = I = R = null }

                    function et(t, e) { var n; return n = void 0 !== e ? e : i ? D : y(A || w), t === d && n === E }

                    function it(t, e, i) { for (var n = t; n && !s();) n = _(n); return n;

                        function s() { if (!1 === F(n)) return !1; var s = lt(n, t),
                                r = ct(n, s, e, i); return !!et(n, r) || M.accepts(w, n, d, r) } }

                    function nt(t) { if (i) { t.preventDefault(); var e = v("clientX", t),
                                n = v("clientY", t),
                                s = n - x;
                            i.style.left = e - C + "px", i.style.top = s + "px"; var r = A || w,
                                a = u(i, e, n),
                                o = it(a, e, n),
                                l = null !== o && o !== R;
                            (l || null === o) && (R && p("out"), R = o, l && p("over")); var c = _(r); if (o !== d || !A || M.copySortSource) { var h, m = lt(o, a); if (null !== m) h = ct(o, m, e, n);
                                else { if (!0 !== M.revertOnSpill || A) return void(A && c && c.removeChild(r));
                                    h = E, o = d }(null === h && l || h !== r && h !== y(r)) && (D = h, o.insertBefore(r, h), P.emit("shadow", r, o, d)) } else c && c.removeChild(r) }

                        function p(t) { P.emit(t, r, R, d) } }

                    function st(t) { r.rm(t, "gu-hide") }

                    function rt(t) { P.dragging && r.add(t, "gu-hide") }

                    function at() { if (!i) { var t = w.getBoundingClientRect();
                            (i = w.cloneNode(!0)).style.width = f(t) + "px", i.style.height = g(t) + "px", r.rm(i, "gu-transit"), r.add(i, "gu-mirror"), M.mirrorContainer.appendChild(i), l(o, "add", "mousemove", nt), r.add(M.mirrorContainer, "gu-unselectable"), P.emit("cloned", i, w, "mirror") } }

                    function ot() { i && (r.rm(M.mirrorContainer, "gu-unselectable"), l(o, "remove", "mousemove", nt), _(i).removeChild(i), i = null) }

                    function lt(t, e) { for (var i = e; i !== t && _(i) !== t;) i = _(i); return i === o ? null : i }

                    function ct(t, e, i, n) { var s, r = "horizontal" === M.direction; return e !== t ? (s = e.getBoundingClientRect(), (r ? i > s.left + f(s) / 2 : n > s.top + g(s) / 2) ? y(e) : e) : function() { var e, s, a, o = t.children.length; for (e = 0; e < o; e++) { if (a = (s = t.children[e]).getBoundingClientRect(), r && a.left + a.width / 2 > i) return s; if (!r && a.top + a.height / 2 > n) return s } return null }() }

                    function ht(t, e) { return "boolean" == typeof M.copy ? M.copy : M.copy(t, e) } } }, Ys8N: function(t, e, i) { "use strict"; var n = [],
                    s = "",
                    r = /^on/; for (s in global) r.test(s) && n.push(s.slice(2));
                t.exports = n }, n6yW: function(t, e, i) { "use strict"; var n = {};

                function s(t) { var e = n[t]; return e ? e.lastIndex = 0 : n[t] = e = new RegExp("(?:^|\\s)" + t + "(?:\\s|$)", "g"), e } t.exports = { add: function(t, e) { var i = t.className;
                        i.length ? s(e).test(i) || (t.className += " " + e) : t.className = e }, rm: function(t, e) { t.className = t.className.replace(s(e), " ").trim() } } }, yLV6: function(t, e, i) { var n;! function(s, r, a, o) { "use strict"; var l, c = ["", "webkit", "Moz", "MS", "ms", "o"],
                        h = r.createElement("div"),
                        d = Math.round,
                        u = Math.abs,
                        m = Date.now;

                    function p(t, e, i) { return setTimeout(w(t, i), e) }

                    function f(t, e, i) { return !!Array.isArray(t) && (g(t, i[e], i), !0) }

                    function g(t, e, i) { var n; if (t)
                            if (t.forEach) t.forEach(e, i);
                            else if (void 0 !== t.length)
                            for (n = 0; n < t.length;) e.call(i, t[n], n, t), n++;
                        else
                            for (n in t) t.hasOwnProperty(n) && e.call(i, t[n], n, t) }

                    function _(t, e, i) { var n = "DEPRECATED METHOD: " + e + "\n" + i + " AT \n"; return function() { var e = new Error("get-stack-trace"),
                                i = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                                r = s.console && (s.console.warn || s.console.log); return r && r.call(s.console, n, i), t.apply(this, arguments) } } l = "function" != typeof Object.assign ? function(t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), i = 1; i < arguments.length; i++) { var n = arguments[i]; if (null != n)
                                for (var s in n) n.hasOwnProperty(s) && (e[s] = n[s]) } return e } : Object.assign; var b = _((function(t, e, i) { for (var n = Object.keys(e), s = 0; s < n.length;)(!i || i && void 0 === t[n[s]]) && (t[n[s]] = e[n[s]]), s++; return t }), "extend", "Use `assign`."),
                        y = _((function(t, e) { return b(t, e, !0) }), "merge", "Use `assign`.");

                    function v(t, e, i) { var n, s = e.prototype;
                        (n = t.prototype = Object.create(s)).constructor = t, n._super = s, i && l(n, i) }

                    function w(t, e) { return function() { return t.apply(e, arguments) } }

                    function C(t, e) { return "function" == typeof t ? t.apply(e && e[0] || void 0, e) : t }

                    function x(t, e) { return void 0 === t ? e : t }

                    function S(t, e, i) { g(A(e), (function(e) { t.addEventListener(e, i, !1) })) }

                    function k(t, e, i) { g(A(e), (function(e) { t.removeEventListener(e, i, !1) })) }

                    function E(t, e) { for (; t;) { if (t == e) return !0;
                            t = t.parentNode } return !1 }

                    function D(t, e) { return t.indexOf(e) > -1 }

                    function A(t) { return t.trim().split(/\s+/g) }

                    function I(t, e, i) { if (t.indexOf && !i) return t.indexOf(e); for (var n = 0; n < t.length;) { if (i && t[n][i] == e || !i && t[n] === e) return n;
                            n++ } return -1 }

                    function T(t) { return Array.prototype.slice.call(t, 0) }

                    function O(t, e, i) { for (var n = [], s = [], r = 0; r < t.length;) { var a = e ? t[r][e] : t[r];
                            I(s, a) < 0 && n.push(t[r]), s[r] = a, r++ } return i && (n = e ? n.sort((function(t, i) { return t[e] > i[e] })) : n.sort()), n }

                    function R(t, e) { for (var i, n, s = e[0].toUpperCase() + e.slice(1), r = 0; r < c.length;) { if ((n = (i = c[r]) ? i + s : e) in t) return n;
                            r++ } } var M = 1;

                    function P(t) { var e = t.ownerDocument || t; return e.defaultView || e.parentWindow || s } var F = "ontouchstart" in s,
                        N = void 0 !== R(s, "PointerEvent"),
                        L = F && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),
                        B = ["x", "y"],
                        V = ["clientX", "clientY"];

                    function z(t, e) { var i = this;
                        this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function(e) { C(t.options.enable, [t]) && i.handler(e) }, this.init() }

                    function U(t, e, i) { var n = i.pointers.length,
                            s = i.changedPointers.length,
                            r = 1 & e && n - s == 0,
                            a = 12 & e && n - s == 0;
                        i.isFirst = !!r, i.isFinal = !!a, r && (t.session = {}), i.eventType = e,
                            function(t, e) { var i = t.session,
                                    n = e.pointers,
                                    s = n.length;
                                i.firstInput || (i.firstInput = H(e)), s > 1 && !i.firstMultiple ? i.firstMultiple = H(e) : 1 === s && (i.firstMultiple = !1); var r = i.firstInput,
                                    a = i.firstMultiple,
                                    o = a ? a.center : r.center,
                                    l = e.center = j(n);
                                e.timeStamp = m(), e.deltaTime = e.timeStamp - r.timeStamp, e.angle = q(o, l), e.distance = W(o, l),
                                    function(t, e) { var i = e.center,
                                            n = t.offsetDelta || {},
                                            s = t.prevDelta || {},
                                            r = t.prevInput || {};
                                        1 !== e.eventType && 4 !== r.eventType || (s = t.prevDelta = { x: r.deltaX || 0, y: r.deltaY || 0 }, n = t.offsetDelta = { x: i.x, y: i.y }), e.deltaX = s.x + (i.x - n.x), e.deltaY = s.y + (i.y - n.y) }(i, e), e.offsetDirection = $(e.deltaX, e.deltaY); var c, h, d = G(e.deltaTime, e.deltaX, e.deltaY);
                                e.overallVelocityX = d.x, e.overallVelocityY = d.y, e.overallVelocity = u(d.x) > u(d.y) ? d.x : d.y, e.scale = a ? (c = a.pointers, W((h = n)[0], h[1], V) / W(c[0], c[1], V)) : 1, e.rotation = a ? function(t, e) { return q(e[1], e[0], V) + q(t[1], t[0], V) }(a.pointers, n) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length,
                                    function(t, e) { var i, n, s, r, a = t.lastInterval || e,
                                            o = e.timeStamp - a.timeStamp; if (8 != e.eventType && (o > 25 || void 0 === a.velocity)) { var l = e.deltaX - a.deltaX,
                                                c = e.deltaY - a.deltaY,
                                                h = G(o, l, c);
                                            n = h.x, s = h.y, i = u(h.x) > u(h.y) ? h.x : h.y, r = $(l, c), t.lastInterval = e } else i = a.velocity, n = a.velocityX, s = a.velocityY, r = a.direction;
                                        e.velocity = i, e.velocityX = n, e.velocityY = s, e.direction = r }(i, e); var p = t.element;
                                E(e.srcEvent.target, p) && (p = e.srcEvent.target), e.target = p }(t, i), t.emit("hammer.input", i), t.recognize(i), t.session.prevInput = i }

                    function H(t) { for (var e = [], i = 0; i < t.pointers.length;) e[i] = { clientX: d(t.pointers[i].clientX), clientY: d(t.pointers[i].clientY) }, i++; return { timeStamp: m(), pointers: e, center: j(e), deltaX: t.deltaX, deltaY: t.deltaY } }

                    function j(t) { var e = t.length; if (1 === e) return { x: d(t[0].clientX), y: d(t[0].clientY) }; for (var i = 0, n = 0, s = 0; s < e;) i += t[s].clientX, n += t[s].clientY, s++; return { x: d(i / e), y: d(n / e) } }

                    function G(t, e, i) { return { x: e / t || 0, y: i / t || 0 } }

                    function $(t, e) { return t === e ? 1 : u(t) >= u(e) ? t < 0 ? 2 : 4 : e < 0 ? 8 : 16 }

                    function W(t, e, i) { i || (i = B); var n = e[i[0]] - t[i[0]],
                            s = e[i[1]] - t[i[1]]; return Math.sqrt(n * n + s * s) }

                    function q(t, e, i) { return i || (i = B), 180 * Math.atan2(e[i[1]] - t[i[1]], e[i[0]] - t[i[0]]) / Math.PI } z.prototype = { handler: function() {}, init: function() { this.evEl && S(this.element, this.evEl, this.domHandler), this.evTarget && S(this.target, this.evTarget, this.domHandler), this.evWin && S(P(this.element), this.evWin, this.domHandler) }, destroy: function() { this.evEl && k(this.element, this.evEl, this.domHandler), this.evTarget && k(this.target, this.evTarget, this.domHandler), this.evWin && k(P(this.element), this.evWin, this.domHandler) } }; var Y = { mousedown: 1, mousemove: 2, mouseup: 4 };

                    function X() { this.evEl = "mousedown", this.evWin = "mousemove mouseup", this.pressed = !1, z.apply(this, arguments) } v(X, z, { handler: function(t) { var e = Y[t.type];
                            1 & e && 0 === t.button && (this.pressed = !0), 2 & e && 1 !== t.which && (e = 4), this.pressed && (4 & e && (this.pressed = !1), this.callback(this.manager, e, { pointers: [t], changedPointers: [t], pointerType: "mouse", srcEvent: t })) } }); var K = { pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8 },
                        Z = { 2: "touch", 3: "pen", 4: "mouse", 5: "kinect" },
                        Q = "pointerdown",
                        J = "pointermove pointerup pointercancel";

                    function tt() { this.evEl = Q, this.evWin = J, z.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } s.MSPointerEvent && !s.PointerEvent && (Q = "MSPointerDown", J = "MSPointerMove MSPointerUp MSPointerCancel"), v(tt, z, { handler: function(t) { var e = this.store,
                                i = !1,
                                n = t.type.toLowerCase().replace("ms", ""),
                                s = K[n],
                                r = Z[t.pointerType] || t.pointerType,
                                a = "touch" == r,
                                o = I(e, t.pointerId, "pointerId");
                            1 & s && (0 === t.button || a) ? o < 0 && (e.push(t), o = e.length - 1) : 12 & s && (i = !0), o < 0 || (e[o] = t, this.callback(this.manager, s, { pointers: e, changedPointers: [t], pointerType: r, srcEvent: t }), i && e.splice(o, 1)) } }); var et = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 };

                    function it() { this.evTarget = "touchstart", this.evWin = "touchstart touchmove touchend touchcancel", this.started = !1, z.apply(this, arguments) }

                    function nt(t, e) { var i = T(t.touches),
                            n = T(t.changedTouches); return 12 & e && (i = O(i.concat(n), "identifier", !0)), [i, n] } v(it, z, { handler: function(t) { var e = et[t.type]; if (1 === e && (this.started = !0), this.started) { var i = nt.call(this, t, e);
                                12 & e && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, e, { pointers: i[0], changedPointers: i[1], pointerType: "touch", srcEvent: t }) } } }); var st = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 };

                    function rt() { this.evTarget = "touchstart touchmove touchend touchcancel", this.targetIds = {}, z.apply(this, arguments) }

                    function at(t, e) { var i = T(t.touches),
                            n = this.targetIds; if (3 & e && 1 === i.length) return n[i[0].identifier] = !0, [i, i]; var s, r, a = T(t.changedTouches),
                            o = [],
                            l = this.target; if (r = i.filter((function(t) { return E(t.target, l) })), 1 === e)
                            for (s = 0; s < r.length;) n[r[s].identifier] = !0, s++; for (s = 0; s < a.length;) n[a[s].identifier] && o.push(a[s]), 12 & e && delete n[a[s].identifier], s++; return o.length ? [O(r.concat(o), "identifier", !0), o] : void 0 }

                    function ot() { z.apply(this, arguments); var t = w(this.handler, this);
                        this.touch = new rt(this.manager, t), this.mouse = new X(this.manager, t), this.primaryTouch = null, this.lastTouches = [] }

                    function lt(t, e) { 1 & t ? (this.primaryTouch = e.changedPointers[0].identifier, ct.call(this, e)) : 12 & t && ct.call(this, e) }

                    function ct(t) { var e = t.changedPointers[0]; if (e.identifier === this.primaryTouch) { var i = { x: e.clientX, y: e.clientY };
                            this.lastTouches.push(i); var n = this.lastTouches;
                            setTimeout((function() { var t = n.indexOf(i);
                                t > -1 && n.splice(t, 1) }), 2500) } }

                    function ht(t) { for (var e = t.srcEvent.clientX, i = t.srcEvent.clientY, n = 0; n < this.lastTouches.length; n++) { var s = this.lastTouches[n],
                                r = Math.abs(e - s.x),
                                a = Math.abs(i - s.y); if (r <= 25 && a <= 25) return !0 } return !1 } v(rt, z, { handler: function(t) { var e = st[t.type],
                                i = at.call(this, t, e);
                            i && this.callback(this.manager, e, { pointers: i[0], changedPointers: i[1], pointerType: "touch", srcEvent: t }) } }), v(ot, z, { handler: function(t, e, i) { var n = "mouse" == i.pointerType; if (!(n && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) { if ("touch" == i.pointerType) lt.call(this, e, i);
                                else if (n && ht.call(this, i)) return;
                                this.callback(t, e, i) } }, destroy: function() { this.touch.destroy(), this.mouse.destroy() } }); var dt = R(h.style, "touchAction"),
                        ut = void 0 !== dt,
                        mt = function() { if (!ut) return !1; var t = {},
                                e = s.CSS && s.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function(i) { t[i] = !e || s.CSS.supports("touch-action", i) })), t }();

                    function pt(t, e) { this.manager = t, this.set(e) }

                    function ft(t) { this.options = l({}, this.defaults, t || {}), this.id = M++, this.manager = null, this.options.enable = x(this.options.enable, !0), this.state = 1, this.simultaneous = {}, this.requireFail = [] }

                    function gt(t) { return 16 & t ? "cancel" : 8 & t ? "end" : 4 & t ? "move" : 2 & t ? "start" : "" }

                    function _t(t) { return 16 == t ? "down" : 8 == t ? "up" : 2 == t ? "left" : 4 == t ? "right" : "" }

                    function bt(t, e) { var i = e.manager; return i ? i.get(t) : t }

                    function yt() { ft.apply(this, arguments) }

                    function vt() { yt.apply(this, arguments), this.pX = null, this.pY = null }

                    function wt() { yt.apply(this, arguments) }

                    function Ct() { ft.apply(this, arguments), this._timer = null, this._input = null }

                    function xt() { yt.apply(this, arguments) }

                    function St() { yt.apply(this, arguments) }

                    function kt() { ft.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 }

                    function Et(t, e) { return (e = e || {}).recognizers = x(e.recognizers, Et.defaults.preset), new Dt(t, e) }

                    function Dt(t, e) { var i;
                        this.options = l({}, Et.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new((i = this).options.inputClass || (N ? tt : L ? rt : F ? ot : X))(i, U), this.touchAction = new pt(this, this.options.touchAction), At(this, !0), g(this.options.recognizers, (function(t) { var e = this.add(new t[0](t[1]));
                            t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]) }), this) }

                    function At(t, e) { var i, n = t.element;
                        n.style && (g(t.options.cssProps, (function(s, r) { i = R(n.style, r), e ? (t.oldCssProps[i] = n.style[i], n.style[i] = s) : n.style[i] = t.oldCssProps[i] || "" })), e || (t.oldCssProps = {})) } pt.prototype = { set: function(t) { "compute" == t && (t = this.compute()), ut && this.manager.element.style && mt[t] && (this.manager.element.style[dt] = t), this.actions = t.toLowerCase().trim() }, update: function() { this.set(this.manager.options.touchAction) }, compute: function() { var t = []; return g(this.manager.recognizers, (function(e) { C(e.options.enable, [e]) && (t = t.concat(e.getTouchAction())) })),
                                function(t) { if (D(t, "none")) return "none"; var e = D(t, "pan-x"),
                                        i = D(t, "pan-y"); return e && i ? "none" : e || i ? e ? "pan-x" : "pan-y" : D(t, "manipulation") ? "manipulation" : "auto" }(t.join(" ")) }, preventDefaults: function(t) { var e = t.srcEvent,
                                i = t.offsetDirection; if (this.manager.session.prevented) e.preventDefault();
                            else { var n = this.actions,
                                    s = D(n, "none") && !mt.none,
                                    r = D(n, "pan-y") && !mt["pan-y"],
                                    a = D(n, "pan-x") && !mt["pan-x"]; if (s && 1 === t.pointers.length && t.distance < 2 && t.deltaTime < 250) return; if (!a || !r) return s || r && 6 & i || a && 24 & i ? this.preventSrc(e) : void 0 } }, preventSrc: function(t) { this.manager.session.prevented = !0, t.preventDefault() } }, ft.prototype = { defaults: {}, set: function(t) { return l(this.options, t), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function(t) { if (f(t, "recognizeWith", this)) return this; var e = this.simultaneous; return e[(t = bt(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this }, dropRecognizeWith: function(t) { return f(t, "dropRecognizeWith", this) || (t = bt(t, this), delete this.simultaneous[t.id]), this }, requireFailure: function(t) { if (f(t, "requireFailure", this)) return this; var e = this.requireFail; return -1 === I(e, t = bt(t, this)) && (e.push(t), t.requireFailure(this)), this }, dropRequireFailure: function(t) { if (f(t, "dropRequireFailure", this)) return this;
                            t = bt(t, this); var e = I(this.requireFail, t); return e > -1 && this.requireFail.splice(e, 1), this }, hasRequireFailures: function() { return this.requireFail.length > 0 }, canRecognizeWith: function(t) { return !!this.simultaneous[t.id] }, emit: function(t) { var e = this,
                                i = this.state;

                            function n(i) { e.manager.emit(i, t) } i < 8 && n(e.options.event + gt(i)), n(e.options.event), t.additionalEvent && n(t.additionalEvent), i >= 8 && n(e.options.event + gt(i)) }, tryEmit: function(t) { if (this.canEmit()) return this.emit(t);
                            this.state = 32 }, canEmit: function() { for (var t = 0; t < this.requireFail.length;) { if (!(33 & this.requireFail[t].state)) return !1;
                                t++ } return !0 }, recognize: function(t) { var e = l({}, t); if (!C(this.options.enable, [this, e])) return this.reset(), void(this.state = 32);
                            56 & this.state && (this.state = 1), this.state = this.process(e), 30 & this.state && this.tryEmit(e) }, process: function(t) {}, getTouchAction: function() {}, reset: function() {} }, v(yt, ft, { defaults: { pointers: 1 }, attrTest: function(t) { var e = this.options.pointers; return 0 === e || t.pointers.length === e }, process: function(t) { var e = this.state,
                                i = t.eventType,
                                n = 6 & e,
                                s = this.attrTest(t); return n && (8 & i || !s) ? 16 | e : n || s ? 4 & i ? 8 | e : 2 & e ? 4 | e : 2 : 32 } }), v(vt, yt, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: 30 }, getTouchAction: function() { var t = this.options.direction,
                                e = []; return 6 & t && e.push("pan-y"), 24 & t && e.push("pan-x"), e }, directionTest: function(t) { var e = this.options,
                                i = !0,
                                n = t.distance,
                                s = t.direction,
                                r = t.deltaX,
                                a = t.deltaY; return s & e.direction || (6 & e.direction ? (s = 0 === r ? 1 : r < 0 ? 2 : 4, i = r != this.pX, n = Math.abs(t.deltaX)) : (s = 0 === a ? 1 : a < 0 ? 8 : 16, i = a != this.pY, n = Math.abs(t.deltaY))), t.direction = s, i && n > e.threshold && s & e.direction }, attrTest: function(t) { return yt.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t)) }, emit: function(t) { this.pX = t.deltaX, this.pY = t.deltaY; var e = _t(t.direction);
                            e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t) } }), v(wt, yt, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function() { return ["none"] }, attrTest: function(t) { return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || 2 & this.state) }, emit: function(t) { 1 !== t.scale && (t.additionalEvent = this.options.event + (t.scale < 1 ? "in" : "out")), this._super.emit.call(this, t) } }), v(Ct, ft, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function() { return ["auto"] }, process: function(t) { var e = this.options,
                                i = t.pointers.length === e.pointers,
                                n = t.distance < e.threshold,
                                s = t.deltaTime > e.time; if (this._input = t, !n || !i || 12 & t.eventType && !s) this.reset();
                            else if (1 & t.eventType) this.reset(), this._timer = p((function() { this.state = 8, this.tryEmit() }), e.time, this);
                            else if (4 & t.eventType) return 8; return 32 }, reset: function() { clearTimeout(this._timer) }, emit: function(t) { 8 === this.state && (t && 4 & t.eventType ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = m(), this.manager.emit(this.options.event, this._input))) } }), v(xt, yt, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function() { return ["none"] }, attrTest: function(t) { return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || 2 & this.state) } }), v(St, yt, { defaults: { event: "swipe", threshold: 10, velocity: .3, direction: 30, pointers: 1 }, getTouchAction: function() { return vt.prototype.getTouchAction.call(this) }, attrTest: function(t) { var e, i = this.options.direction; return 30 & i ? e = t.overallVelocity : 6 & i ? e = t.overallVelocityX : 24 & i && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && i & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && u(e) > this.options.velocity && 4 & t.eventType }, emit: function(t) { var e = _t(t.offsetDirection);
                            e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t) } }), v(kt, ft, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function() { return ["manipulation"] }, process: function(t) { var e = this.options,
                                i = t.pointers.length === e.pointers,
                                n = t.distance < e.threshold,
                                s = t.deltaTime < e.time; if (this.reset(), 1 & t.eventType && 0 === this.count) return this.failTimeout(); if (n && s && i) { if (4 != t.eventType) return this.failTimeout(); var r = !this.pTime || t.timeStamp - this.pTime < e.interval,
                                    a = !this.pCenter || W(this.pCenter, t.center) < e.posThreshold; if (this.pTime = t.timeStamp, this.pCenter = t.center, a && r ? this.count += 1 : this.count = 1, this._input = t, 0 == this.count % e.taps) return this.hasRequireFailures() ? (this._timer = p((function() { this.state = 8, this.tryEmit() }), e.interval, this), 2) : 8 } return 32 }, failTimeout: function() { return this._timer = p((function() { this.state = 32 }), this.options.interval, this), 32 }, reset: function() { clearTimeout(this._timer) }, emit: function() { 8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), Et.VERSION = "2.0.7", Et.defaults = { domEvents: !1, touchAction: "compute", enable: !0, inputTarget: null, inputClass: null, preset: [
                            [xt, { enable: !1 }],
                            [wt, { enable: !1 },
                                ["rotate"]
                            ],
                            [St, { direction: 6 }],
                            [vt, { direction: 6 },
                                ["swipe"]
                            ],
                            [kt],
                            [kt, { event: "doubletap", taps: 2 },
                                ["tap"]
                            ],
                            [Ct]
                        ], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }, Dt.prototype = { set: function(t) { return l(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this }, stop: function(t) { this.session.stopped = t ? 2 : 1 }, recognize: function(t) { var e = this.session; if (!e.stopped) { var i;
                                this.touchAction.preventDefaults(t); var n = this.recognizers,
                                    s = e.curRecognizer;
                                (!s || s && 8 & s.state) && (s = e.curRecognizer = null); for (var r = 0; r < n.length;) i = n[r], 2 === e.stopped || s && i != s && !i.canRecognizeWith(s) ? i.reset() : i.recognize(t), !s && 14 & i.state && (s = e.curRecognizer = i), r++ } }, get: function(t) { if (t instanceof ft) return t; for (var e = this.recognizers, i = 0; i < e.length; i++)
                                if (e[i].options.event == t) return e[i]; return null }, add: function(t) { if (f(t, "add", this)) return this; var e = this.get(t.options.event); return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t }, remove: function(t) { if (f(t, "remove", this)) return this; if (t = this.get(t)) { var e = this.recognizers,
                                    i = I(e, t); - 1 !== i && (e.splice(i, 1), this.touchAction.update()) } return this }, on: function(t, e) { if (void 0 !== t && void 0 !== e) { var i = this.handlers; return g(A(t), (function(t) { i[t] = i[t] || [], i[t].push(e) })), this } }, off: function(t, e) { if (void 0 !== t) { var i = this.handlers; return g(A(t), (function(t) { e ? i[t] && i[t].splice(I(i[t], e), 1) : delete i[t] })), this } }, emit: function(t, e) { this.options.domEvents && function(t, e) { var i = r.createEvent("Event");
                                i.initEvent(t, !0, !0), i.gesture = e, e.target.dispatchEvent(i) }(t, e); var i = this.handlers[t] && this.handlers[t].slice(); if (i && i.length) { e.type = t, e.preventDefault = function() { e.srcEvent.preventDefault() }; for (var n = 0; n < i.length;) i[n](e), n++ } }, destroy: function() { this.element && At(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, l(Et, { INPUT_START: 1, INPUT_MOVE: 2, INPUT_END: 4, INPUT_CANCEL: 8, STATE_POSSIBLE: 1, STATE_BEGAN: 2, STATE_CHANGED: 4, STATE_ENDED: 8, STATE_RECOGNIZED: 8, STATE_CANCELLED: 16, STATE_FAILED: 32, DIRECTION_NONE: 1, DIRECTION_LEFT: 2, DIRECTION_RIGHT: 4, DIRECTION_UP: 8, DIRECTION_DOWN: 16, DIRECTION_HORIZONTAL: 6, DIRECTION_VERTICAL: 24, DIRECTION_ALL: 30, Manager: Dt, Input: z, TouchAction: pt, TouchInput: rt, MouseInput: X, PointerEventInput: tt, TouchMouseInput: ot, SingleTouchInput: it, Recognizer: ft, AttrRecognizer: yt, Tap: kt, Pan: vt, Swipe: St, Pinch: wt, Rotate: xt, Press: Ct, on: S, off: k, each: g, merge: y, extend: b, assign: l, inherit: v, bindFn: w, prefixed: R }), (void 0 !== s ? s : "undefined" != typeof self ? self : {}).Hammer = Et, void 0 === (n = (function() { return Et }).call(e, i, e, t)) || (t.exports = n) }(window, document) }, zUnb: function(t, e, i) { "use strict";

                function n(t) { return "function" == typeof t } i.r(e); let s = !1; const r = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error;
                            console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3");
                        s = t }, get useDeprecatedSynchronousErrorHandling() { return s } };

                function a(t) { setTimeout(() => { throw t }, 0) } const o = { closed: !0, next(t) {}, error(t) { if (r.useDeprecatedSynchronousErrorHandling) throw t;
                            a(t) }, complete() {} },
                    l = (() => Array.isArray || (t => t && "number" == typeof t.length))();

                function c(t) { return null !== t && "object" == typeof t } const h = (() => {
                    function t(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t })(); let d = (() => { class t { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._unsubscribe = t) } unsubscribe() { let e; if (this.closed) return; let { _parentOrParents: i, _unsubscribe: s, _subscriptions: r } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, i instanceof t) i.remove(this);
                            else if (null !== i)
                                for (let t = 0; t < i.length; ++t) i[t].remove(this); if (n(s)) try { s.call(this) } catch (a) { e = a instanceof h ? u(a.errors) : [a] }
                            if (l(r)) { let t = -1,
                                    i = r.length; for (; ++t < i;) { const i = r[t]; if (c(i)) try { i.unsubscribe() } catch (a) { e = e || [], a instanceof h ? e = e.concat(u(a.errors)) : e.push(a) } } } if (e) throw new h(e) } add(e) { let i = e; if (!e) return t.EMPTY; switch (typeof e) {
                                case "function":
                                    i = new t(e);
                                case "object":
                                    if (i === this || i.closed || "function" != typeof i.unsubscribe) return i; if (this.closed) return i.unsubscribe(), i; if (!(i instanceof t)) { const e = i;
                                        i = new t, i._subscriptions = [e] } break;
                                default:
                                    throw new Error("unrecognized teardown " + e + " added to Subscription.") } let { _parentOrParents: n } = i; if (null === n) i._parentOrParents = this;
                            else if (n instanceof t) { if (n === this) return i;
                                i._parentOrParents = [n, this] } else { if (-1 !== n.indexOf(this)) return i;
                                n.push(this) } const s = this._subscriptions; return null === s ? this._subscriptions = [i] : s.push(i), i } remove(t) { const e = this._subscriptions; if (e) { const i = e.indexOf(t); - 1 !== i && e.splice(i, 1) } } } return t.EMPTY = function(t) { return t.closed = !0, t }(new t), t })();

                function u(t) { return t.reduce((t, e) => t.concat(e instanceof h ? e.errors : e), []) } const m = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())();
                class p extends d { constructor(t, e, i) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) {
                            case 0:
                                this.destination = o; break;
                            case 1:
                                if (!t) { this.destination = o; break } if ("object" == typeof t) { t instanceof p ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new f(this, t)); break }
                            default:
                                this.syncErrorThrowable = !0, this.destination = new f(this, t, e, i) } } [m]() { return this } static create(t, e, i) { const n = new p(t, e, i); return n.syncErrorThrowable = !1, n } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class f extends p { constructor(t, e, i, s) { let r;
                        super(), this._parentSubscriber = t; let a = this;
                        n(e) ? r = e : e && (r = e.next, i = e.error, s = e.complete, e !== o && (a = Object.create(e), n(a.unsubscribe) && this.add(a.unsubscribe.bind(a)), a.unsubscribe = this.unsubscribe.bind(this))), this._context = a, this._next = r, this._error = i, this._complete = s } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this;
                            r.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: i } = r; if (this._error) i && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe());
                            else if (e.syncErrorThrowable) i ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : a(t), this.unsubscribe();
                            else { if (this.unsubscribe(), i) throw t;
                                a(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context);
                                r.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (i) { if (this.unsubscribe(), r.useDeprecatedSynchronousErrorHandling) throw i;
                            a(i) } } __tryOrSetError(t, e, i) { if (!r.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, i) } catch (n) { return r.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = n, t.syncErrorThrown = !0, !0) : (a(n), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this;
                        this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const g = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")();

                function _(t) { return t }

                function b(...t) { return y(t) }

                function y(t) { return 0 === t.length ? _ : 1 === t.length ? t[0] : function(e) { return t.reduce((t, e) => e(t), e) } } let v = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const i = new t; return i.source = this, i.operator = e, i } subscribe(t, e, i) { const { operator: n } = this, s = function(t, e, i) { if (t) { if (t instanceof p) return t; if (t[m]) return t[m]() } return t || e || i ? new p(t, e, i) : new p(o) }(t, e, i); if (s.add(n ? n.call(s, this.source) : this.source || r.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), r.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown)) throw s.syncErrorValue; return s } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { r.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e),
                                    function(t) { for (; t;) { const { closed: e, destination: i, isStopped: n } = t; if (e || n) return !1;
                                            t = i && i instanceof p ? i : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new(e = w(e))((e, i) => { let n;
                                n = this.subscribe(e => { try { t(e) } catch (s) { i(s), n && n.unsubscribe() } }, i, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [g]() { return this } pipe(...t) { return 0 === t.length ? this : y(t)(this) } toPromise(t) { return new(t = w(t))((t, e) => { let i;
                                this.subscribe(t => i = t, t => e(t), () => t(i)) }) } } return t.create = e => new t(e), t })();

                function w(t) { if (t || (t = r.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } const C = (() => {
                    function t() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return t.prototype = Object.create(Error.prototype), t })();
                class x extends d { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return;
                        this.closed = !0; const t = this.subject,
                            e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const i = e.indexOf(this.subscriber); - 1 !== i && e.splice(i, 1) } } class S extends p { constructor(t) { super(t), this.destination = t } } let k = (() => { class t extends v { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [m]() { return new S(this) } lift(t) { const e = new E(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new C; if (!this.isStopped) { const { observers: e } = this, i = e.length, n = e.slice(); for (let s = 0; s < i; s++) n[s].next(t) } } error(t) { if (this.closed) throw new C;
                            this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, i = e.length, n = e.slice(); for (let s = 0; s < i; s++) n[s].error(t);
                            this.observers.length = 0 } complete() { if (this.closed) throw new C;
                            this.isStopped = !0; const { observers: t } = this, e = t.length, i = t.slice(); for (let n = 0; n < e; n++) i[n].complete();
                            this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new C; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new C; return this.hasError ? (t.error(this.thrownError), d.EMPTY) : this.isStopped ? (t.complete(), d.EMPTY) : (this.observers.push(t), new x(this, t)) } asObservable() { const t = new v; return t.source = this, t } } return t.create = (t, e) => new E(t, e), t })();
                class E extends k { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this;
                        e && e.next && e.next(t) } error(t) { const { destination: e } = this;
                        e && e.error && this.destination.error(t) } complete() { const { destination: t } = this;
                        t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : d.EMPTY } }

                function D(t) { return t && "function" == typeof t.schedule } class A extends p { constructor(t, e, i) { super(), this.parent = t, this.outerValue = e, this.outerIndex = i, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } const I = t => e => { for (let i = 0, n = t.length; i < n && !e.closed; i++) e.next(t[i]);
                    e.complete() };

                function T() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } const O = T(),
                    R = t => t && "number" == typeof t.length && "function" != typeof t;

                function M(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } const P = t => { if (t && "function" == typeof t[g]) return n = t, t => { const e = n[g](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) }; if (R(t)) return I(t); if (M(t)) return i = t, t => (i.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, a), t); if (t && "function" == typeof t[O]) return e = t, t => { const i = e[O](); for (;;) { const e = i.next(); if (e.done) { t.complete(); break } if (t.next(e.value), t.closed) break } return "function" == typeof i.return && t.add(() => { i.return && i.return() }), t }; { const e = c(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected.` + " You can provide an Observable, Promise, Array, or Iterable.") } var e, i, n };

                function F(t, e, i, n, s = new A(t, i, n)) { if (!s.closed) return e instanceof v ? e.subscribe(s) : P(e)(s) } class N extends p { notifyNext(t, e, i, n, s) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } }

                function L(t, e) { return function(i) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return i.lift(new B(t, e)) } } class B { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new V(t, this.project, this.thisArg)) } } class V extends p { constructor(t, e, i) { super(t), this.project = e, this.count = 0, this.thisArg = i || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (i) { return void this.destination.error(i) } this.destination.next(e) } }

                function z(t, e) { return new v(i => { const n = new d; let s = 0; return n.add(e.schedule((function() { s !== t.length ? (i.next(t[s++]), i.closed || n.add(this.schedule())) : i.complete() }))), n }) }

                function U(t, e) { return e ? function(t, e) { if (null != t) { if (function(t) { return t && "function" == typeof t[g] }(t)) return function(t, e) { return new v(i => { const n = new d; return n.add(e.schedule(() => { const s = t[g]();
                                        n.add(s.subscribe({ next(t) { n.add(e.schedule(() => i.next(t))) }, error(t) { n.add(e.schedule(() => i.error(t))) }, complete() { n.add(e.schedule(() => i.complete())) } })) })), n }) }(t, e); if (M(t)) return function(t, e) { return new v(i => { const n = new d; return n.add(e.schedule(() => t.then(t => { n.add(e.schedule(() => { i.next(t), n.add(e.schedule(() => i.complete())) })) }, t => { n.add(e.schedule(() => i.error(t))) }))), n }) }(t, e); if (R(t)) return z(t, e); if (function(t) { return t && "function" == typeof t[O] }(t) || "string" == typeof t) return function(t, e) { if (!t) throw new Error("Iterable cannot be null"); return new v(i => { const n = new d; let s; return n.add(() => { s && "function" == typeof s.return && s.return() }), n.add(e.schedule(() => { s = t[O](), n.add(e.schedule((function() { if (i.closed) return; let t, e; try { const i = s.next();
                                                t = i.value, e = i.done } catch (n) { return void i.error(n) } e ? i.complete() : (i.next(t), this.schedule()) }))) })), n }) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") }(t, e) : t instanceof v ? t : new v(P(t)) }

                function H(t, e, i = Number.POSITIVE_INFINITY) { return "function" == typeof e ? n => n.pipe(H((i, n) => U(t(i, n)).pipe(L((t, s) => e(i, t, n, s))), i)) : ("number" == typeof e && (i = e), e => e.lift(new j(t, i))) } class j { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new G(t, this.project, this.concurrent)) } } class G extends N { constructor(t, e, i = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = i, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const i = this.index++; try { e = this.project(t, i) } catch (n) { return void this.destination.error(n) } this.active++, this._innerSub(e, t, i) } _innerSub(t, e, i) { const n = new A(this, e, i),
                            s = this.destination;
                        s.add(n); const r = F(this, t, void 0, void 0, n);
                        r !== n && s.add(r) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t, e, i, n, s) { this.destination.next(e) } notifyComplete(t) { const e = this.buffer;
                        this.remove(t), this.active--, e.length > 0 ? this._next(e.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } }

                function $(t = Number.POSITIVE_INFINITY) { return H(_, t) }

                function W(t, e) { return e ? z(t, e) : new v(I(t)) }

                function q(...t) { let e = Number.POSITIVE_INFINITY,
                        i = null,
                        n = t[t.length - 1]; return D(n) ? (i = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof n && (e = t.pop()), null === i && 1 === t.length && t[0] instanceof v ? t[0] : $(e)(W(t, i)) }

                function Y() { return function(t) { return t.lift(new X(t)) } } class X { constructor(t) { this.connectable = t } call(t, e) { const { connectable: i } = this;
                        i._refCount++; const n = new K(t, i),
                            s = e.subscribe(n); return n.closed || (n.connection = i.connect()), s } } class K extends p { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void(this.connection = null);
                        this.connectable = null; const e = t._refCount; if (e <= 0) return void(this.connection = null); if (t._refCount = e - 1, e > 1) return void(this.connection = null); const { connection: i } = this, n = t._connection;
                        this.connection = null, !n || i && n !== i || n.unsubscribe() } } class Z extends v { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new d, t.add(this.source.subscribe(new J(this.getSubject(), this))), t.closed && (this._connection = null, t = d.EMPTY)), t } refCount() { return Y()(this) } } const Q = (() => { const t = Z.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: t._subscribe }, _isComplete: { value: t._isComplete, writable: !0 }, getSubject: { value: t.getSubject }, connect: { value: t.connect }, refCount: { value: t.refCount } } })();
                class J extends S { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection;
                            t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } }

                function tt() { return new k }

                function et() { return t => { return Y()((e = tt, function(t) { let i;
                            i = "function" == typeof e ? e : function() { return e }; const n = Object.create(t, Q); return n.source = t, n.subjectFactory = i, n })(t)); var e } }

                function it(t) { return { toString: t }.toString() }

                function nt(t, e, i) { return it(() => { const n = function(t) { return function(...e) { if (t) { const i = t(...e); for (const t in i) this[t] = i[t] } } }(e);

                        function s(...t) { if (this instanceof s) return n.apply(this, t), this; const e = new s(...t); return i.annotation = e, i;

                            function i(t, i, n) { const s = t.hasOwnProperty("__parameters__") ? t.__parameters__ : Object.defineProperty(t, "__parameters__", { value: [] }).__parameters__; for (; s.length <= n;) s.push(null); return (s[n] = s[n] || []).push(e), t } } return i && (s.prototype = Object.create(i.prototype)), s.prototype.ngMetadataName = t, s.annotationCls = s, s }) } const st = nt("Inject", t => ({ token: t })),
                    rt = nt("Optional"),
                    at = nt("Self"),
                    ot = nt("SkipSelf"); var lt = function(t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({});

                function ct(t) { for (let e in t)
                        if (t[e] === ct) return e; throw Error("Could not find renamed property on target object.") }

                function ht(t, e) { for (const i in e) e.hasOwnProperty(i) && !t.hasOwnProperty(i) && (t[i] = e[i]) }

                function dt(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } }

                function ut(t) { return { factory: t.factory, providers: t.providers || [], imports: t.imports || [] } }

                function mt(t) { return pt(t, t[gt]) || pt(t, t[yt]) }

                function pt(t, e) { return e && e.token === t ? e : null }

                function ft(t) { return t && (t.hasOwnProperty(_t) || t.hasOwnProperty(vt)) ? t[_t] : null } const gt = ct({ "\u0275prov": ct }),
                    _t = ct({ "\u0275inj": ct }),
                    bt = ct({ "\u0275provFallback": ct }),
                    yt = ct({ ngInjectableDef: ct }),
                    vt = ct({ ngInjectorDef: ct });

                function wt(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(wt).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const i = e.indexOf("\n"); return -1 === i ? e : e.substring(0, i) }

                function Ct(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const xt = ct({ __forward_ref__: ct });

                function St(t) { return t.__forward_ref__ = St, t.toString = function() { return wt(this()) }, t }

                function kt(t) { return Et(t) ? t() : t }

                function Et(t) { return "function" == typeof t && t.hasOwnProperty(xt) && t.__forward_ref__ === St } const Dt = "undefined" != typeof globalThis && globalThis,
                    At = "undefined" != typeof window && window,
                    It = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self,
                    Tt = "undefined" != typeof global && global,
                    Ot = Dt || Tt || At || It,
                    Rt = ct({ "\u0275cmp": ct }),
                    Mt = ct({ "\u0275dir": ct }),
                    Pt = ct({ "\u0275pipe": ct }),
                    Ft = ct({ "\u0275mod": ct }),
                    Nt = ct({ "\u0275loc": ct }),
                    Lt = ct({ "\u0275fac": ct }),
                    Bt = ct({ __NG_ELEMENT_ID__: ct });
                class Vt { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = dt({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } const zt = new Vt("INJECTOR", -1),
                    Ut = {},
                    Ht = /\n/gm,
                    jt = ct({ provide: String, useValue: ct }); let Gt, $t = void 0;

                function Wt(t) { const e = $t; return $t = t, e }

                function qt(t) { const e = Gt; return Gt = t, e }

                function Yt(t, e = lt.Default) { if (void 0 === $t) throw new Error("inject() must be called from an injection context"); return null === $t ? Zt(t, void 0, e) : $t.get(t, e & lt.Optional ? null : void 0, e) }

                function Xt(t, e = lt.Default) { return (Gt || Yt)(kt(t), e) } const Kt = Xt;

                function Zt(t, e, i) { const n = mt(t); if (n && "root" == n.providedIn) return void 0 === n.value ? n.value = n.factory() : n.value; if (i & lt.Optional) return null; if (void 0 !== e) return e; throw new Error(`Injector: NOT_FOUND [${wt(t)}]`) }

                function Qt(t) { const e = []; for (let i = 0; i < t.length; i++) { const n = kt(t[i]); if (Array.isArray(n)) { if (0 === n.length) throw new Error("Arguments array must have arguments."); let t = void 0,
                                i = lt.Default; for (let e = 0; e < n.length; e++) { const s = n[e];
                                s instanceof rt || "Optional" === s.ngMetadataName || s === rt ? i |= lt.Optional : s instanceof ot || "SkipSelf" === s.ngMetadataName || s === ot ? i |= lt.SkipSelf : s instanceof at || "Self" === s.ngMetadataName || s === at ? i |= lt.Self : t = s instanceof st || s === st ? s.token : s } e.push(Xt(t, i)) } else e.push(Xt(n)) } return e } class Jt { get(t, e = Ut) { if (e === Ut) { const e = new Error(`NullInjectorError: No provider for ${wt(t)}!`); throw e.name = "NullInjectorError", e } return e } } class te {} class ee {}

                function ie(t, e) { t.forEach(t => Array.isArray(t) ? ie(t, e) : e(t)) }

                function ne(t, e, i) { e >= t.length ? t.push(i) : t.splice(e, 0, i) }

                function se(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] }

                function re(t, e) { const i = []; for (let n = 0; n < t; n++) i.push(e); return i }

                function ae(t, e, i) { let n = le(t, e); return n >= 0 ? t[1 | n] = i : (n = ~n, function(t, e, i, n) { let s = t.length; if (s == e) t.push(i, n);
                        else if (1 === s) t.push(n, t[0]), t[0] = i;
                        else { for (s--, t.push(t[s - 1], t[s]); s > e;) t[s] = t[s - 2], s--;
                            t[e] = i, t[e + 1] = n } }(t, n, e, i)), n }

                function oe(t, e) { const i = le(t, e); if (i >= 0) return t[1 | i] }

                function le(t, e) { return function(t, e, i) { let n = 0,
                            s = t.length >> 1; for (; s !== n;) { const i = n + (s - n >> 1),
                                r = t[i << 1]; if (e === r) return i << 1;
                            r > e ? s = i : n = i + 1 } return ~(s << 1) }(t, e) } const ce = function() { var t = { OnPush: 0, Default: 1 }; return t[t.OnPush] = "OnPush", t[t.Default] = "Default", t }(),
                    he = function() { var t = { Emulated: 0, Native: 1, None: 2, ShadowDom: 3 }; return t[t.Emulated] = "Emulated", t[t.Native] = "Native", t[t.None] = "None", t[t.ShadowDom] = "ShadowDom", t }(),
                    de = {},
                    ue = []; let me = 0;

                function pe(t) { return it(() => { const e = t.type,
                            i = e.prototype,
                            n = {},
                            s = { type: e, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: n, inputs: null, outputs: null, exportAs: t.exportAs || null, onChanges: null, onInit: i.ngOnInit || null, doCheck: i.ngDoCheck || null, afterContentInit: i.ngAfterContentInit || null, afterContentChecked: i.ngAfterContentChecked || null, afterViewInit: i.ngAfterViewInit || null, afterViewChecked: i.ngAfterViewChecked || null, onDestroy: i.ngOnDestroy || null, onPush: t.changeDetection === ce.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || ue, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || he.Emulated, id: "c", styles: t.styles || ue, _: null, setInput: null, schemas: t.schemas || null, tView: null },
                            r = t.directives,
                            a = t.features,
                            o = t.pipes; return s.id += me++, s.inputs = ve(t.inputs, n), s.outputs = ve(t.outputs), a && a.forEach(t => t(s)), s.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(ge) : null, s.pipeDefs = o ? () => ("function" == typeof o ? o() : o).map(_e) : null, s }) }

                function fe(t, e, i) { const n = t.\u0275cmp;
                    n.directiveDefs = () => e.map(ge), n.pipeDefs = () => i.map(_e) }

                function ge(t) { return xe(t) || function(t) { return t[Mt] || null }(t) }

                function _e(t) { return function(t) { return t[Pt] || null }(t) } const be = {};

                function ye(t) { const e = { type: t.type, bootstrap: t.bootstrap || ue, declarations: t.declarations || ue, imports: t.imports || ue, exports: t.exports || ue, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && it(() => { be[t.id] = t.type }), e }

                function ve(t, e) { if (null == t) return de; const i = {}; for (const n in t)
                        if (t.hasOwnProperty(n)) { let s = t[n],
                                r = s;
                            Array.isArray(s) && (r = s[1], s = s[0]), i[s] = n, e && (e[s] = r) } return i } const we = pe;

                function Ce(t) { return { type: t.type, name: t.name, factory: null, pure: !1 !== t.pure, onDestroy: t.type.prototype.ngOnDestroy || null } }

                function xe(t) { return t[Rt] || null }

                function Se(t, e) { return t.hasOwnProperty(Lt) ? t[Lt] : null }

                function ke(t, e) { const i = t[Ft] || null; if (!i && !0 === e) throw new Error(`Type ${wt(t)} does not have '\u0275mod' property.`); return i }

                function Ee(t) { return Array.isArray(t) && "object" == typeof t[1] }

                function De(t) { return Array.isArray(t) && !0 === t[1] }

                function Ae(t) { return 0 != (8 & t.flags) }

                function Ie(t) { return 2 == (2 & t.flags) }

                function Te(t) { return 1 == (1 & t.flags) }

                function Oe(t) { return null !== t.template }

                function Re(t) { return 0 != (512 & t[2]) } let Me = void 0;

                function Pe() { return void 0 !== Me ? Me : "undefined" != typeof document ? document : void 0 }

                function Fe(t) { return !!t.listen } const Ne = { createRenderer: (t, e) => Pe() };

                function Le(t) { for (; Array.isArray(t);) t = t[0]; return t }

                function Be(t, e) { return Le(e[t + 19]) }

                function Ve(t, e) { return Le(e[t.index]) }

                function ze(t, e) { return t.data[e + 19] }

                function Ue(t, e) { return t[e + 19] }

                function He(t, e) { const i = e[t]; return Ee(i) ? i : i[0] }

                function je(t) { const e = function(t) { return t.__ngContext__ || null }(t); return e ? Array.isArray(e) ? e : e.lView : null }

                function Ge(t) { return 4 == (4 & t[2]) }

                function $e(t) { return 128 == (128 & t[2]) }

                function We(t, e) { return null === t || null == e ? null : t[e] }

                function qe(t) { t[18] = 0 } const Ye = { lFrame: fi(null), bindingsEnabled: !0, checkNoChangesMode: !1 };

                function Xe() { return Ye.bindingsEnabled }

                function Ke() { return Ye.lFrame.lView }

                function Ze() { return Ye.lFrame.tView }

                function Qe(t) { Ye.lFrame.contextLView = t }

                function Je() { return Ye.lFrame.previousOrParentTNode }

                function ti(t, e) { Ye.lFrame.previousOrParentTNode = t, Ye.lFrame.isParent = e }

                function ei() { return Ye.lFrame.isParent }

                function ii() { Ye.lFrame.isParent = !1 }

                function ni() { return Ye.checkNoChangesMode }

                function si(t) { Ye.checkNoChangesMode = t }

                function ri() { const t = Ye.lFrame; let e = t.bindingRootIndex; return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e }

                function ai() { return Ye.lFrame.bindingIndex }

                function oi() { return Ye.lFrame.bindingIndex++ }

                function li(t) { const e = Ye.lFrame,
                        i = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, i }

                function ci(t, e) { const i = Ye.lFrame;
                    i.bindingIndex = i.bindingRootIndex = t, i.currentDirectiveIndex = e }

                function hi() { return Ye.lFrame.currentQueryIndex }

                function di(t) { Ye.lFrame.currentQueryIndex = t }

                function ui(t, e) { const i = pi();
                    Ye.lFrame = i, i.previousOrParentTNode = e, i.lView = t }

                function mi(t, e) { const i = pi(),
                        n = t[1];
                    Ye.lFrame = i, i.previousOrParentTNode = e, i.lView = t, i.tView = n, i.contextLView = t, i.bindingIndex = n.bindingStartIndex }

                function pi() { const t = Ye.lFrame,
                        e = null === t ? null : t.child; return null === e ? fi(t) : e }

                function fi(t) { const e = { previousOrParentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: 0, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentSanitizer: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null }; return null !== t && (t.child = e), e }

                function gi() { const t = Ye.lFrame; return Ye.lFrame = t.parent, t.previousOrParentTNode = null, t.lView = null, t } const _i = gi;

                function bi() { const t = gi();
                    t.isParent = !0, t.tView = null, t.selectedIndex = 0, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.currentSanitizer = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 }

                function yi() { return Ye.lFrame.selectedIndex }

                function vi(t) { Ye.lFrame.selectedIndex = t }

                function wi() { const t = Ye.lFrame; return ze(t.tView, t.selectedIndex) }

                function Ci() { Ye.lFrame.currentNamespace = "http://www.w3.org/2000/svg" }

                function xi() { Ye.lFrame.currentNamespace = null }

                function Si(t, e) { for (let i = e.directiveStart, n = e.directiveEnd; i < n; i++) { const e = t.data[i];
                        e.afterContentInit && (t.contentHooks || (t.contentHooks = [])).push(-i, e.afterContentInit), e.afterContentChecked && ((t.contentHooks || (t.contentHooks = [])).push(i, e.afterContentChecked), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(i, e.afterContentChecked)), e.afterViewInit && (t.viewHooks || (t.viewHooks = [])).push(-i, e.afterViewInit), e.afterViewChecked && ((t.viewHooks || (t.viewHooks = [])).push(i, e.afterViewChecked), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(i, e.afterViewChecked)), null != e.onDestroy && (t.destroyHooks || (t.destroyHooks = [])).push(i, e.onDestroy) } }

                function ki(t, e, i) { Ai(t, e, 3, i) }

                function Ei(t, e, i, n) {
                    (3 & t[2]) === i && Ai(t, e, i, n) }

                function Di(t, e) { let i = t[2];
                    (3 & i) === e && (i &= 1023, i += 1, t[2] = i) }

                function Ai(t, e, i, n) { const s = null != n ? n : -1; let r = 0; for (let a = void 0 !== n ? 65535 & t[18] : 0; a < e.length; a++)
                        if ("number" == typeof e[a + 1]) { if (r = e[a], null != n && r >= n) break } else e[a] < 0 && (t[18] += 65536), (r < s || -1 == s) && (Ii(t, i, e, a), t[18] = (4294901760 & t[18]) + a + 2), a++ }

                function Ii(t, e, i, n) { const s = i[n] < 0,
                        r = i[n + 1],
                        a = t[s ? -i[n] : i[n]];
                    s ? t[2] >> 10 < t[18] >> 16 && (3 & t[2]) === e && (t[2] += 1024, r.call(a)) : r.call(a) } class Ti { constructor(t, e, i) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = i } }

                function Oi(t, e, i) { const n = Fe(t); let s = 0; for (; s < i.length;) { const r = i[s]; if ("number" == typeof r) { if (0 !== r) break;
                            s++; const a = i[s++],
                                o = i[s++],
                                l = i[s++];
                            n ? t.setAttribute(e, o, l, a) : e.setAttributeNS(a, o, l) } else { const a = r,
                                o = i[++s];
                            Mi(a) ? n && t.setProperty(e, a, o) : n ? t.setAttribute(e, a, o) : e.setAttribute(a, o), s++ } } return s }

                function Ri(t) { return 3 === t || 4 === t || 6 === t }

                function Mi(t) { return 64 === t.charCodeAt(0) }

                function Pi(t, e) { if (null === e || 0 === e.length);
                    else if (null === t || 0 === t.length) t = e.slice();
                    else { let i = -1; for (let n = 0; n < e.length; n++) { const s = e[n]; "number" == typeof s ? i = s : 0 === i || Fi(t, i, s, null, -1 === i || 2 === i ? e[++n] : null) } } return t }

                function Fi(t, e, i, n, s) { let r = 0,
                        a = t.length; if (-1 === e) a = -1;
                    else
                        for (; r < t.length;) { const i = t[r++]; if ("number" == typeof i) { if (i === e) { a = -1; break } if (i > e) { a = r - 1; break } } }
                    for (; r < t.length;) { const e = t[r]; if ("number" == typeof e) break; if (e === i) { if (null === n) return void(null !== s && (t[r + 1] = s)); if (n === t[r + 1]) return void(t[r + 2] = s) } r++, null !== n && r++, null !== s && r++ } - 1 !== a && (t.splice(a, 0, e), r = a + 1), t.splice(r++, 0, i), null !== n && t.splice(r++, 0, n), null !== s && t.splice(r++, 0, s) }

                function Ni(t) { return -1 !== t }

                function Li(t) { return 32767 & t }

                function Bi(t) { return t >> 16 }

                function Vi(t, e) { let i = Bi(t),
                        n = e; for (; i > 0;) n = n[15], i--; return n }

                function zi(t) { return "string" == typeof t ? t : null == t ? "" : "" + t }

                function Ui(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : zi(t) } const Hi = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(Ot))();

                function ji(t) { return { name: "body", target: t.ownerDocument.body } }

                function Gi(t) { return t instanceof Function ? t() : t } let $i = !0;

                function Wi(t) { const e = $i; return $i = t, e } let qi = 0;

                function Yi(t, e) { const i = Ki(t, e); if (-1 !== i) return i; const n = e[1];
                    n.firstCreatePass && (t.injectorIndex = e.length, Xi(n.data, t), Xi(e, null), Xi(n.blueprint, null)); const s = Zi(t, e),
                        r = t.injectorIndex; if (Ni(s)) { const t = Li(s),
                            i = Vi(s, e),
                            n = i[1].data; for (let s = 0; s < 8; s++) e[r + s] = i[t + s] | n[t + s] } return e[r + 8] = s, r }

                function Xi(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) }

                function Ki(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null == e[t.injectorIndex + 8] ? -1 : t.injectorIndex }

                function Zi(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let i = e[6],
                        n = 1; for (; i && -1 === i.injectorIndex;) i = (e = e[15]) ? e[6] : null, n++; return i ? i.injectorIndex | n << 16 : -1 }

                function Qi(t, e, i) {! function(t, e, i) { let n = "string" != typeof i ? i[Bt] : i.charCodeAt(0) || 0;
                        null == n && (n = i[Bt] = qi++); const s = 255 & n,
                            r = 1 << s,
                            a = 64 & s,
                            o = 32 & s,
                            l = e.data;
                        128 & s ? a ? o ? l[t + 7] |= r : l[t + 6] |= r : o ? l[t + 5] |= r : l[t + 4] |= r : a ? o ? l[t + 3] |= r : l[t + 2] |= r : o ? l[t + 1] |= r : l[t] |= r }(t, e, i) }

                function Ji(t, e, i, n = lt.Default, s) { if (null !== t) { const s = function(t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t[Bt]; return "number" == typeof e && e > 0 ? 255 & e : e }(i); if ("function" == typeof s) { ui(e, t); try { const t = s(); if (null != t || n & lt.Optional) return t; throw new Error(`No provider for ${Ui(i)}!`) } finally { _i() } } else if ("number" == typeof s) { if (-1 === s) return new on(t, e); let r = null,
                                a = Ki(t, e),
                                o = -1,
                                l = n & lt.Host ? e[16][6] : null; for ((-1 === a || n & lt.SkipSelf) && (o = -1 === a ? Zi(t, e) : e[a + 8], an(n, !1) ? (r = e[1], a = Li(o), e = Vi(o, e)) : a = -1); - 1 !== a;) { o = e[a + 8]; const t = e[1]; if (rn(s, a, t.data)) { const t = en(a, e, i, r, n, l); if (t !== tn) return t } an(n, e[1].data[a + 8] === l) && rn(s, a, e) ? (r = t, a = Li(o), e = Vi(o, e)) : a = -1 } } } if (n & lt.Optional && void 0 === s && (s = null), 0 == (n & (lt.Self | lt.Host))) { const t = e[9],
                            r = qt(void 0); try { return t ? t.get(i, s, n & lt.Optional) : Zt(i, s, n & lt.Optional) } finally { qt(r) } } if (n & lt.Optional) return s; throw new Error(`NodeInjector: NOT_FOUND [${Ui(i)}]`) } const tn = {};

                function en(t, e, i, n, s, r) { const a = e[1],
                        o = a.data[t + 8],
                        l = nn(o, a, i, null == n ? Ie(o) && $i : n != a && 3 === o.type, s & lt.Host && r === o); return null !== l ? sn(e, a, l, o) : tn }

                function nn(t, e, i, n, s) { const r = t.providerIndexes,
                        a = e.data,
                        o = 65535 & r,
                        l = t.directiveStart,
                        c = r >> 16,
                        h = s ? o + c : t.directiveEnd; for (let d = n ? o : o + c; d < h; d++) { const t = a[d]; if (d < l && i === t || d >= l && t.type === i) return d } if (s) { const t = a[l]; if (t && Oe(t) && t.type === i) return l } return null }

                function sn(t, e, i, n) { let s = t[i]; const r = e.data; if (s instanceof Ti) { const a = s; if (a.resolving) throw new Error(`Circular dep for ${Ui(r[i])}`); const o = Wi(a.canSeeViewProviders); let l;
                        a.resolving = !0, a.injectImpl && (l = qt(a.injectImpl)), ui(t, n); try { s = t[i] = a.factory(void 0, r, t, n), e.firstCreatePass && i >= n.directiveStart && function(t, e, i) { const { onChanges: n, onInit: s, doCheck: r } = e;
                                n && ((i.preOrderHooks || (i.preOrderHooks = [])).push(t, n), (i.preOrderCheckHooks || (i.preOrderCheckHooks = [])).push(t, n)), s && (i.preOrderHooks || (i.preOrderHooks = [])).push(-t, s), r && ((i.preOrderHooks || (i.preOrderHooks = [])).push(t, r), (i.preOrderCheckHooks || (i.preOrderCheckHooks = [])).push(t, r)) }(i, r[i], e) } finally { a.injectImpl && qt(l), Wi(o), a.resolving = !1, _i() } } return s }

                function rn(t, e, i) { const n = 64 & t,
                        s = 32 & t; let r; return r = 128 & t ? n ? s ? i[e + 7] : i[e + 6] : s ? i[e + 5] : i[e + 4] : n ? s ? i[e + 3] : i[e + 2] : s ? i[e + 1] : i[e], !!(r & 1 << t) }

                function an(t, e) { return !(t & lt.Self || t & lt.Host && e) } class on { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return Ji(this._tNode, this._lView, t, void 0, e) } }

                function ln(t) { return it(() => { const e = Object.getPrototypeOf(t.prototype).constructor,
                            i = e[Lt] || function t(e) { const i = e; if (Et(e)) return () => { const e = t(kt(i)); return e ? e() : null }; let n = Se(i); if (null === n) { const t = ft(i);
                                    n = t && t.factory } return n || null }(e); return null !== i ? i : t => new t }) }

                function cn(t) { return t.ngDebugContext }

                function hn(t) { return t.ngOriginalError }

                function dn(t, ...e) { t.error(...e) } class un { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t),
                            i = this._findContext(t),
                            n = function(t) { return t.ngErrorLogger || dn }(t);
                        n(this._console, "ERROR", t), e && n(this._console, "ORIGINAL ERROR", e), i && n(this._console, "ERROR CONTEXT", i) } _findContext(t) { return t ? cn(t) ? cn(t) : this._findContext(hn(t)) : null } _findOriginalError(t) { let e = hn(t); for (; e && hn(e);) e = hn(e); return e } } class mn { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + " (see http://g.co/ng/security#xss)" } } class pn extends mn { getTypeName() { return "HTML" } } class fn extends mn { getTypeName() { return "Style" } } class gn extends mn { getTypeName() { return "Script" } } class _n extends mn { getTypeName() { return "URL" } } class bn extends mn { getTypeName() { return "ResourceURL" } }

                function yn(t) { return t instanceof mn ? t.changingThisBreaksApplicationSecurity : t }

                function vn(t, e) { const i = wn(t); if (null != i && i !== e) { if ("ResourceURL" === i && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${i} (see http://g.co/ng/security#xss)`) } return i === e }

                function wn(t) { return t instanceof mn && t.getTypeName() || null } let Cn = !0,
                    xn = !1;

                function Sn() { return xn = !0, Cn } class kn { constructor(t) { this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"); let e = this.inertDocument.body; if (null == e) { const t = this.inertDocument.createElement("html");
                            this.inertDocument.appendChild(t), e = this.inertDocument.createElement("body"), t.appendChild(e) } e.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', !e.querySelector || e.querySelector("svg") ? (e.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', this.getInertBodyElement = e.querySelector && e.querySelector("svg img") && function() { try { return !!window.DOMParser } catch (t) { return !1 } }() ? this.getInertBodyElement_DOMParser : this.getInertBodyElement_InertDocument) : this.getInertBodyElement = this.getInertBodyElement_XHR } getInertBodyElement_XHR(t) { t = "<body><remove></remove>" + t + "</body>"; try { t = encodeURI(t) } catch (n) { return null } const e = new XMLHttpRequest;
                        e.responseType = "document", e.open("GET", "data:text/html;charset=utf-8," + t, !1), e.send(void 0); const i = e.response.body; return i.removeChild(i.firstChild), i } getInertBodyElement_DOMParser(t) { t = "<body><remove></remove>" + t + "</body>"; try { const e = (new window.DOMParser).parseFromString(t, "text/html").body; return e.removeChild(e.firstChild), e } catch (e) { return null } } getInertBodyElement_InertDocument(t) { const e = this.inertDocument.createElement("template"); if ("content" in e) return e.innerHTML = t, e; const i = this.inertDocument.createElement("body"); return i.innerHTML = t, this.defaultDoc.documentMode && this.stripCustomNsAttrs(i), i } stripCustomNsAttrs(t) { const e = t.attributes; for (let n = e.length - 1; 0 < n; n--) { const i = e.item(n).name; "xmlns:ns1" !== i && 0 !== i.indexOf("ns1:") || t.removeAttribute(i) } let i = t.firstChild; for (; i;) i.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(i), i = i.nextSibling } } const En = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi,
                    Dn = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;

                function An(t) { return (t = String(t)).match(En) || t.match(Dn) ? t : (Sn() && console.warn(`WARNING: sanitizing unsafe URL value ${t} (see http://g.co/ng/security#xss)`), "unsafe:" + t) }

                function In(t) { const e = {}; for (const i of t.split(",")) e[i] = !0; return e }

                function Tn(...t) { const e = {}; for (const i of t)
                        for (const t in i) i.hasOwnProperty(t) && (e[t] = !0); return e } const On = In("area,br,col,hr,img,wbr"),
                    Rn = In("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
                    Mn = In("rp,rt"),
                    Pn = Tn(Mn, Rn),
                    Fn = Tn(On, Tn(Rn, In("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Tn(Mn, In("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Pn),
                    Nn = In("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),
                    Ln = In("srcset"),
                    Bn = Tn(Nn, Ln, In("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), In("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),
                    Vn = In("script,style,template");
                class zn { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild,
                            i = !0; for (; e;)
                            if (e.nodeType === Node.ELEMENT_NODE ? i = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, i && e.firstChild) e = e.firstChild;
                            else
                                for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let t = this.checkClobberedElement(e, e.nextSibling); if (t) { e = t; break } e = this.checkClobberedElement(e, e.parentNode) }
                        return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!Fn.hasOwnProperty(e)) return this.sanitizedSomething = !0, !Vn.hasOwnProperty(e);
                        this.buf.push("<"), this.buf.push(e); const i = t.attributes; for (let s = 0; s < i.length; s++) { const t = i.item(s),
                                e = t.name,
                                r = e.toLowerCase(); if (!Bn.hasOwnProperty(r)) { this.sanitizedSomething = !0; continue } let a = t.value;
                            Nn[r] && (a = An(a)), Ln[r] && (n = a, a = (n = String(n)).split(",").map(t => An(t.trim())).join(", ")), this.buf.push(" ", e, '="', jn(a), '"') } var n; return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase();
                        Fn.hasOwnProperty(e) && !On.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(jn(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return e } } const Un = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    Hn = /([^\#-~ |!])/g;

                function jn(t) { return t.replace(/&/g, "&amp;").replace(Un, (function(t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" })).replace(Hn, (function(t) { return "&#" + t.charCodeAt(0) + ";" })).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Gn;

                function $n(t, e) { let i = null; try { Gn = Gn || new kn(t); let n = e ? String(e) : "";
                        i = Gn.getInertBodyElement(n); let s = 5,
                            r = n;
                        do { if (0 === s) throw new Error("Failed to sanitize html because the input is unstable");
                            s--, n = r, r = i.innerHTML, i = Gn.getInertBodyElement(n) } while (n !== r); const a = new zn,
                            o = a.sanitizeChildren(Wn(i) || i); return Sn() && a.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss"), o } finally { if (i) { const t = Wn(i) || i; for (; t.firstChild;) t.removeChild(t.firstChild) } } }

                function Wn(t) { return "content" in t && function(t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } const qn = function() { var t = { NONE: 0, HTML: 1, STYLE: 2, SCRIPT: 3, URL: 4, RESOURCE_URL: 5 }; return t[t.NONE] = "NONE", t[t.HTML] = "HTML", t[t.STYLE] = "STYLE", t[t.SCRIPT] = "SCRIPT", t[t.URL] = "URL", t[t.RESOURCE_URL] = "RESOURCE_URL", t }(),
                    Yn = new RegExp("^([-,.\"'%_!# a-zA-Z0-9]+|(?:(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?|(?:rgb|hsl)a?|(?:repeating-)?(?:linear|radial)-gradient|(?:attr|calc|var))\\([-0-9.%, #a-zA-Z]+\\))$", "g"),
                    Xn = /^url\(([^)]+)\)$/;

                function Kn(t) { const e = Qn(); return e ? e.sanitize(qn.HTML, t) || "" : vn(t, "HTML") ? yn(t) : $n(Pe(), zi(t)) }

                function Zn(t) { const e = Qn(); return e ? e.sanitize(qn.URL, t) || "" : vn(t, "URL") ? yn(t) : An(zi(t)) }

                function Qn() { const t = Ke(); return t && t[12] }

                function Jn(t, e) { t.__ngContext__ = e }

                function ts(t) { throw new Error(`Multiple components match node with tagname ${t.tagName}`) }

                function es() { throw new Error("Cannot mix multi providers and regular providers") }

                function is(t, e, i) { let n = t.length; for (;;) { const s = t.indexOf(e, i); if (-1 === s) return s; if (0 === s || t.charCodeAt(s - 1) <= 32) { const i = e.length; if (s + i === n || t.charCodeAt(s + i) <= 32) return s } i = s + 1 } }

                function ns(t, e, i) { let n = 0; for (; n < t.length;) { let s = t[n++]; if (i && "class" === s) { if (s = t[n], -1 !== is(s.toLowerCase(), e, 0)) return !0 } else if (1 === s) { for (; n < t.length && "string" == typeof(s = t[n++]);)
                                if (s.toLowerCase() === e) return !0; return !1 } } return !1 }

                function ss(t, e, i) { return e === (0 !== t.type || i ? t.tagName : "ng-template") }

                function rs(t, e, i) { let n = 4; const s = t.attrs || [],
                        r = function(t) { for (let e = 0; e < t.length; e++)
                                if (Ri(t[e])) return e; return t.length }(s); let a = !1; for (let o = 0; o < e.length; o++) { const l = e[o]; if ("number" != typeof l) { if (!a)
                                if (4 & n) { if (n = 2 | 1 & n, "" !== l && !ss(t, l, i) || "" === l && 1 === e.length) { if (as(n)) return !1;
                                        a = !0 } } else { const c = 8 & n ? l : e[++o]; if (8 & n && null !== t.attrs) { if (!ns(t.attrs, c, i)) { if (as(n)) return !1;
                                            a = !0 } continue } const h = os(8 & n ? "class" : l, s, 0 == t.type && "ng-template" !== t.tagName, i); if (-1 === h) { if (as(n)) return !1;
                                        a = !0; continue } if ("" !== c) { let t;
                                        t = h > r ? "" : s[h + 1].toLowerCase(); const e = 8 & n ? t : null; if (e && -1 !== is(e, c, 0) || 2 & n && c !== t) { if (as(n)) return !1;
                                            a = !0 } } } } else { if (!a && !as(n) && !as(l)) return !1; if (a && as(l)) continue;
                            a = !1, n = l | 1 & n } } return as(n) || a }

                function as(t) { return 0 == (1 & t) }

                function os(t, e, i, n) { if (null === e) return -1; let s = 0; if (n || !i) { let i = !1; for (; s < e.length;) { const n = e[s]; if (n === t) return s; if (3 === n || 6 === n) i = !0;
                            else { if (1 === n || 2 === n) { let t = e[++s]; for (;
                                        "string" == typeof t;) t = e[++s]; continue } if (4 === n) break; if (0 === n) { s += 4; continue } } s += i ? 1 : 2 } return -1 } return function(t, e) { let i = t.indexOf(4); if (i > -1)
                            for (i++; i < t.length;) { if (t[i] === e) return i;
                                i++ }
                        return -1 }(e, t) }

                function ls(t, e, i = !1) { for (let n = 0; n < e.length; n++)
                        if (rs(t, e[n], i)) return !0; return !1 }

                function cs(t, e) { t: for (let i = 0; i < e.length; i++) { const n = e[i]; if (t.length === n.length) { for (let e = 0; e < t.length; e++)
                                if (t[e] !== n[e]) continue t; return !0 } }
                    return !1 }

                function hs(t, e) { return t ? ":not(" + e.trim() + ")" : e }

                function ds(t) { let e = t[0],
                        i = 1,
                        n = 2,
                        s = "",
                        r = !1; for (; i < t.length;) { let a = t[i]; if ("string" == typeof a)
                            if (2 & n) { const e = t[++i];
                                s += "[" + a + (e.length > 0 ? '="' + e + '"' : "") + "]" } else 8 & n ? s += "." + a : 4 & n && (s += " " + a);
                        else "" === s || as(a) || (e += hs(r, s), s = ""), n = a, r = r || !as(n);
                        i++ } return "" !== s && (e += hs(r, s)), e } const us = {};

                function ms(t) { const e = t[3]; return De(e) ? e[3] : e }

                function ps(t) { fs(Ze(), Ke(), yi() + t, ni()) }

                function fs(t, e, i, n) { if (!n)
                        if (3 == (3 & e[2])) { const n = t.preOrderCheckHooks;
                            null !== n && ki(e, n, i) } else { const n = t.preOrderHooks;
                            null !== n && Ei(e, n, 0, i) } vi(i) }

                function gs(t, e) { return t << 17 | e << 2 }

                function _s(t) { return t >> 17 & 32767 }

                function bs(t) { return 2 | t }

                function ys(t) { return (131068 & t) >> 2 }

                function vs(t, e) { return -131069 & t | e << 2 }

                function ws(t) { return 1 | t }

                function Cs(t, e) { const i = t.contentQueries; if (null !== i)
                        for (let n = 0; n < i.length; n += 2) { const s = i[n],
                                r = i[n + 1]; if (-1 !== r) { const i = t.data[r];
                                di(s), i.contentQueries(2, e[r], r) } } }

                function xs(t, e, i) { return Fe(e) ? e.createElement(t, i) : null === i ? e.createElement(t) : e.createElementNS(i, t) }

                function Ss(t, e, i, n, s, r, a, o, l, c) { const h = e.blueprint.slice(); return h[0] = s, h[2] = 140 | n, qe(h), h[3] = h[15] = t, h[8] = i, h[10] = a || t && t[10], h[11] = o || t && t[11], h[12] = l || t && t[12] || null, h[9] = c || t && t[9] || null, h[6] = r, h[16] = 2 == e.type ? t[16] : h, h }

                function ks(t, e, i, n, s, r) { const a = i + 19,
                        o = t.data[a] || function(t, e, i, n, s, r) { const a = Je(),
                                o = ei(),
                                l = o ? a : a && a.parent,
                                c = t.data[i] = Fs(0, l && l !== e ? l : null, n, i, s, r); return null === t.firstChild && (t.firstChild = c), a && (!o || null != a.child || null === c.parent && 2 !== a.type ? o || (a.next = c) : a.child = c), c }(t, e, a, n, s, r); return ti(o, !0), o }

                function Es(t, e, i) { mi(e, e[6]); try { const n = t.viewQuery;
                        null !== n && sr(1, n, i); const s = t.template;
                        null !== s && Is(t, e, s, 1, i), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && Cs(t, e), t.staticViewQueries && sr(2, t.viewQuery, i); const r = t.components;
                        null !== r && function(t, e) { for (let i = 0; i < e.length; i++) Js(t, e[i]) }(e, r) } finally { e[2] &= -5, bi() } }

                function Ds(t, e, i, n) { const s = e[2]; if (256 == (256 & s)) return;
                    mi(e, e[6]); const r = ni(); try { qe(e), Ye.lFrame.bindingIndex = t.bindingStartIndex, null !== i && Is(t, e, i, 2, n); const a = 3 == (3 & s); if (!r)
                            if (a) { const i = t.preOrderCheckHooks;
                                null !== i && ki(e, i, null) } else { const i = t.preOrderHooks;
                                null !== i && Ei(e, i, 0, null), Di(e, 0) } if (function(t) { let e = t[13]; for (; null !== e;) { let i; if (De(e) && (i = e[2]) >> 1 == -1) { for (let t = 9; t < e.length; t++) { const i = e[t],
                                                n = i[1];
                                            $e(i) && Ds(n, i, n.template, i[8]) } 0 != (1 & i) && Zs(e, t[16]) } e = e[4] } }(e), null !== t.contentQueries && Cs(t, e), !r)
                            if (a) { const i = t.contentCheckHooks;
                                null !== i && ki(e, i) } else { const i = t.contentHooks;
                                null !== i && Ei(e, i, 1), Di(e, 1) }!
                        function(t, e) { try { const i = t.expandoInstructions; if (null !== i) { let n = t.expandoStartIndex,
                                        s = -1,
                                        r = -1; for (let t = 0; t < i.length; t++) { const a = i[t]; "number" == typeof a ? a <= 0 ? (r = 0 - a, vi(r), n += 9 + i[++t], s = n) : n += a : (null !== a && (ci(n, s), a(2, e[s])), s++) } } } finally { vi(-1) } }(t, e); const o = t.components;
                        null !== o && function(t, e) { for (let i = 0; i < e.length; i++) Qs(t, e[i]) }(e, o); const l = t.viewQuery; if (null !== l && sr(2, l, n), !r)
                            if (a) { const i = t.viewCheckHooks;
                                null !== i && ki(e, i) } else { const i = t.viewHooks;
                                null !== i && Ei(e, i, 2), Di(e, 2) }! 0 === t.firstUpdatePass && (t.firstUpdatePass = !1), r || (e[2] &= -73) } finally { bi() } }

                function As(t, e, i, n) { const s = e[10],
                        r = !ni(),
                        a = Ge(e); try { r && !a && s.begin && s.begin(), a && Es(t, e, n), Ds(t, e, i, n) } finally { r && !a && s.end && s.end() } }

                function Is(t, e, i, n, s) { const r = yi(); try { vi(-1), 2 & n && e.length > 19 && fs(t, e, 0, ni()), i(n, s) } finally { vi(r) } }

                function Ts(t, e, i) { if (Ae(e)) { const n = e.directiveEnd; for (let s = e.directiveStart; s < n; s++) { const e = t.data[s];
                            e.contentQueries && e.contentQueries(1, i[s], s) } } }

                function Os(t, e, i) { Xe() && (function(t, e, i, n) { const s = i.directiveStart,
                            r = i.directiveEnd;
                        t.firstCreatePass || Yi(i, e), Jn(n, e); const a = i.initialInputs; for (let o = s; o < r; o++) { const n = t.data[o],
                                r = Oe(n);
                            r && qs(e, i, n); const l = sn(e, t, o, i);
                            Jn(l, e), null !== a && Ys(0, o - s, l, n, 0, a), r && (He(i.index, e)[8] = l) } }(t, e, i, Ve(i, e)), 128 == (128 & i.flags) && function(t, e, i) { const n = i.directiveStart,
                            s = i.directiveEnd,
                            r = t.expandoInstructions,
                            a = t.firstCreatePass,
                            o = i.index - 19; try { vi(o); for (let i = n; i < s; i++) { const n = t.data[i],
                                    s = e[i];
                                null !== n.hostBindings || 0 !== n.hostVars || null !== n.hostAttrs ? Us(n, s) : a && r.push(null) } } finally { vi(-1) } }(t, e, i)) }

                function Rs(t, e, i = Ve) { const n = e.localNames; if (null !== n) { let s = e.index + 1; for (let r = 0; r < n.length; r += 2) { const a = n[r + 1],
                                o = -1 === a ? i(e, t) : t[a];
                            t[s++] = o } } }

                function Ms(t) { return t.tView || (t.tView = Ps(1, -1, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts)) }

                function Ps(t, e, i, n, s, r, a, o, l, c) { const h = 19 + n,
                        d = h + s,
                        u = function(t, e) { const i = []; for (let n = 0; n < e; n++) i.push(n < t ? null : us); return i }(h, d); return u[1] = { type: t, id: e, blueprint: u, template: i, queries: null, viewQuery: o, node: null, data: u.slice().fill(null, h), bindingStartIndex: h, expandoStartIndex: d, expandoInstructions: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof r ? r() : r, pipeRegistry: "function" == typeof a ? a() : a, firstChild: null, schemas: l, consts: c } }

                function Fs(t, e, i, n, s, r) { return { type: i, index: n, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, tagName: s, attrs: r, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, residualStyles: void 0, classes: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }

                function Ns(t, e, i) { for (let n in t)
                        if (t.hasOwnProperty(n)) { const s = t[n];
                            (i = null === i ? {} : i).hasOwnProperty(n) ? i[n].push(e, s) : i[n] = [e, s] } return i }

                function Ls(t, e, i, n, s, r, a, o) { const l = Ve(e, i); let c, h = e.inputs; var d;!o && null != h && (c = h[n]) ? (hr(t, i, c, n, s), Ie(e) && function(t, e) { const i = He(e, t);
                        16 & i[2] || (i[2] |= 64) }(i, e.index)) : 3 === e.type && (n = "class" === (d = n) ? "className" : "for" === d ? "htmlFor" : "formaction" === d ? "formAction" : "innerHtml" === d ? "innerHTML" : "readonly" === d ? "readOnly" : "tabindex" === d ? "tabIndex" : d, s = null != a ? a(s, e.tagName || "", n) : s, Fe(r) ? r.setProperty(l, n, s) : Mi(n) || (l.setProperty ? l.setProperty(n, s) : l[n] = s)) }

                function Bs(t, e, i, n) { let s = !1; if (Xe()) { const r = function(t, e, i) { const n = t.directiveRegistry; let s = null; if (n)
                                    for (let r = 0; r < n.length; r++) { const a = n[r];
                                        ls(i, a.selectors, !1) && (s || (s = []), Qi(Yi(i, e), t, a.type), Oe(a) ? (2 & i.flags && ts(i), js(t, i), s.unshift(a)) : s.push(a)) }
                                return s }(t, e, i),
                            a = null === n ? null : { "": -1 }; if (null !== r) { let n = 0;
                            s = !0, $s(i, t.data.length, r.length); for (let t = 0; t < r.length; t++) { const e = r[t];
                                e.providersResolver && e.providersResolver(e) } Hs(t, i, r.length); let o = !1,
                                l = !1; for (let s = 0; s < r.length; s++) { const c = r[s];
                                i.mergedAttrs = Pi(i.mergedAttrs, c.hostAttrs), Ws(t, e, c), Gs(t.data.length - 1, c, a), null !== c.contentQueries && (i.flags |= 8), null === c.hostBindings && null === c.hostAttrs && 0 === c.hostVars || (i.flags |= 128), !o && (c.onChanges || c.onInit || c.doCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(i.index - 19), o = !0), l || !c.onChanges && !c.doCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(i.index - 19), l = !0), Vs(t, c), n += c.hostVars }! function(t, e) { const i = e.directiveEnd,
                                    n = t.data,
                                    s = e.attrs,
                                    r = []; let a = null,
                                    o = null; for (let l = e.directiveStart; l < i; l++) { const t = n[l],
                                        e = t.inputs;
                                    r.push(null !== s ? Xs(e, s) : null), a = Ns(e, l, a), o = Ns(t.outputs, l, o) } null !== a && (a.hasOwnProperty("class") && (e.flags |= 16), a.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = r, e.inputs = a, e.outputs = o }(t, i), zs(t, e, n) } a && function(t, e, i) { if (e) { const n = t.localNames = []; for (let t = 0; t < e.length; t += 2) { const s = i[e[t + 1]]; if (null == s) throw new Error(`Export of name '${e[t+1]}' not found!`);
                                    n.push(e[t], s) } } }(i, n, a) } return i.mergedAttrs = Pi(i.mergedAttrs, i.attrs), s }

                function Vs(t, e) { const i = t.expandoInstructions;
                    i.push(e.hostBindings), 0 !== e.hostVars && i.push(e.hostVars) }

                function zs(t, e, i) { for (let n = 0; n < i; n++) e.push(us), t.blueprint.push(us), t.data.push(null) }

                function Us(t, e) { null !== t.hostBindings && t.hostBindings(1, e) }

                function Hs(t, e, i) { const n = 19 - e.index,
                        s = t.data.length - (65535 & e.providerIndexes);
                    (t.expandoInstructions || (t.expandoInstructions = [])).push(n, s, i) }

                function js(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) }

                function Gs(t, e, i) { if (i) { if (e.exportAs)
                            for (let n = 0; n < e.exportAs.length; n++) i[e.exportAs[n]] = t;
                        Oe(e) && (i[""] = t) } }

                function $s(t, e, i) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + i, t.providerIndexes = e }

                function Ws(t, e, i) { t.data.push(i); const n = i.factory || (i.factory = Se(i.type)),
                        s = new Ti(n, Oe(i), null);
                    t.blueprint.push(s), e.push(s) }

                function qs(t, e, i) { const n = Ve(e, t),
                        s = Ms(i),
                        r = t[10],
                        a = tr(t, Ss(t, s, null, i.onPush ? 64 : 16, n, e, r, r.createRenderer(n, i)));
                    t[e.index] = a }

                function Ys(t, e, i, n, s, r) { const a = r[e]; if (null !== a) { const t = n.setInput; for (let e = 0; e < a.length;) { const s = a[e++],
                                r = a[e++],
                                o = a[e++];
                            null !== t ? n.setInput(i, o, s, r) : i[r] = o } } }

                function Xs(t, e) { let i = null,
                        n = 0; for (; n < e.length;) { const s = e[n]; if (0 !== s)
                            if (5 !== s) { if ("number" == typeof s) break;
                                t.hasOwnProperty(s) && (null === i && (i = []), i.push(s, t[s], e[n + 1])), n += 2 } else n += 2;
                        else n += 4 } return i }

                function Ks(t, e, i, n) { return new Array(t, !0, -2, e, null, null, n, i, null) }

                function Zs(t, e) { const i = t[5]; for (let n = 0; n < i.length; n++) { const t = i[n],
                            s = t[3][3][16]; if (s !== e && 0 == (16 & s[2])) { const e = t[1];
                            Ds(e, t, e.template, t[8]) } } }

                function Qs(t, e) { const i = He(e, t); if ($e(i) && 80 & i[2]) { const t = i[1];
                        Ds(t, i, t.template, i[8]) } }

                function Js(t, e) { const i = He(e, t),
                        n = i[1];! function(t, e) { for (let i = e.length; i < t.blueprint.length; i++) e.push(t.blueprint[i]) }(n, i), Es(n, i, i[8]) }

                function tr(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e }

                function er(t) { for (; t;) { t[2] |= 64; const e = ms(t); if (Re(t) && !e) return t;
                        t = e } return null }

                function ir(t, e, i) { const n = e[10];
                    n.begin && n.begin(); try { Ds(t, e, t.template, i) } catch (s) { throw cr(e, s), s } finally { n.end && n.end() } }

                function nr(t) {! function(t) { for (let e = 0; e < t.components.length; e++) { const i = t.components[e],
                                n = je(i),
                                s = n[1];
                            As(s, n, s.template, i) } }(t[8]) }

                function sr(t, e, i) { di(0), e(t, i) } const rr = (() => Promise.resolve(null))();

                function ar(t) { return t[7] || (t[7] = []) }

                function or(t) { return t.cleanup || (t.cleanup = []) }

                function lr(t, e) { return function(t) { for (; Array.isArray(t);) { if ("object" == typeof t[1]) return t;
                            t = t[0] } return null }(e[t.index])[11] }

                function cr(t, e) { const i = t[9],
                        n = i ? i.get(un, null) : null;
                    n && n.handleError(e) }

                function hr(t, e, i, n, s) { for (let r = 0; r < i.length;) { const a = i[r++],
                            o = i[r++],
                            l = e[a],
                            c = t.data[a];
                        null !== c.setInput ? c.setInput(l, s, n, o) : l[o] = s } }

                function dr(t, e, i) { const n = Be(e, t),
                        s = t[11];
                    Fe(s) ? s.setValue(n, i) : n.textContent = i }

                function ur(t, e) { const i = e[3]; return -1 === t.index ? De(i) ? i : null : i }

                function mr(t, e) { const i = ur(t, e); return i ? kr(e[11], i[7]) : null }

                function pr(t, e, i, n, s) { if (null != n) { let r, a = !1;
                        De(n) ? r = n : Ee(n) && (a = !0, n = n[0]); const o = Le(n);
                        0 === t && null !== i ? null == s ? xr(e, i, o) : Cr(e, i, o, s || null) : 1 === t && null !== i ? Cr(e, i, o, s || null) : 2 === t ? function(t, e, i) { const n = kr(t, e);
                            n && function(t, e, i, n) { Fe(t) ? t.removeChild(e, i, n) : e.removeChild(i) }(t, n, e, i) }(e, o, a) : 3 === t && e.destroyNode(o), null != r && function(t, e, i, n, s) { const r = i[7];
                            r !== Le(i) && pr(e, t, n, r, s); for (let a = 9; a < i.length; a++) { const s = i[a];
                                Tr(s[1], s, t, e, n, r) } }(e, t, r, i, s) } }

                function fr(t, e, i, n) { const s = mr(t.node, e);
                    s && Tr(t, e, e[11], i ? 1 : 2, s, n) }

                function gr(t, e) { const i = t[5],
                        n = i.indexOf(e);
                    i.splice(n, 1) }

                function _r(t, e) { if (t.length <= 9) return; const i = 9 + e,
                        n = t[i]; if (n) { const s = n[17];
                        null !== s && s !== t && gr(s, n), e > 0 && (t[i - 1][4] = n[4]); const r = se(t, 9 + e);
                        fr(n[1], n, !1, null); const a = r[5];
                        null !== a && a.detachView(r[1]), n[3] = null, n[4] = null, n[2] &= -129 } return n }

                function br(t, e) { if (!(256 & e[2])) { const i = e[11];
                        Fe(i) && i.destroyNode && Tr(t, e, i, 3, null, null),
                            function(t) { let e = t[13]; if (!e) return vr(t[1], t); for (; e;) { let i = null; if (Ee(e)) i = e[13];
                                    else { const t = e[9];
                                        t && (i = t) } if (!i) { for (; e && !e[4] && e !== t;) Ee(e) && vr(e[1], e), e = yr(e, t);
                                        null === e && (e = t), Ee(e) && vr(e[1], e), i = e && e[4] } e = i } }(e) } }

                function yr(t, e) { let i; return Ee(t) && (i = t[6]) && 2 === i.type ? ur(i, t) : t[3] === e ? null : t[3] }

                function vr(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256,
                            function(t, e) { let i; if (null != t && null != (i = t.destroyHooks))
                                    for (let n = 0; n < i.length; n += 2) { const t = e[i[n]]; if (!(t instanceof Ti)) { const e = i[n + 1]; if (Array.isArray(e))
                                                for (let i = 0; i < e.length; i += 2) e[i + 1].call(t[e[i]]);
                                            else e.call(t) } } }(t, e),
                            function(t, e) { const i = t.cleanup; if (null !== i) { const t = e[7]; for (let n = 0; n < i.length - 1; n += 2)
                                        if ("string" == typeof i[n]) { const s = i[n + 1],
                                                r = "function" == typeof s ? s(e) : Le(e[s]),
                                                a = t[i[n + 2]],
                                                o = i[n + 3]; "boolean" == typeof o ? r.removeEventListener(i[n], a, o) : o >= 0 ? t[o]() : t[-o].unsubscribe(), n += 2 } else i[n].call(t[i[n + 1]]);
                                    e[7] = null } }(t, e); const i = e[6];
                        i && 3 === i.type && Fe(e[11]) && e[11].destroy(); const n = e[17]; if (null !== n && De(e[3])) { n !== e[3] && gr(n, e); const i = e[5];
                            null !== i && i.detachView(t) } } }

                function wr(t, e, i) { let n = e.parent; for (; null != n && (4 === n.type || 5 === n.type);) n = (e = n).parent; if (null == n) { const t = i[6]; return 2 === t.type ? mr(t, i) : i[0] } if (e && 5 === e.type && 4 & e.flags) return Ve(e, i).parentNode; if (2 & n.flags) { const e = t.data,
                            i = e[e[n.index].directiveStart].encapsulation; if (i !== he.ShadowDom && i !== he.Native) return null } return Ve(n, i) }

                function Cr(t, e, i, n) { Fe(t) ? t.insertBefore(e, i, n) : e.insertBefore(i, n, !0) }

                function xr(t, e, i) { Fe(t) ? t.appendChild(e, i) : e.appendChild(i) }

                function Sr(t, e, i, n) { null !== n ? Cr(t, e, i, n) : xr(t, e, i) }

                function kr(t, e) { return Fe(t) ? t.parentNode(e) : e.parentNode }

                function Er(t, e) { if (2 === t.type) { const i = ur(t, e); return null === i ? null : Ar(i.indexOf(e, 9) - 9, i) } return 4 === t.type || 5 === t.type ? Ve(t, e) : null }

                function Dr(t, e, i, n) { const s = wr(t, n, e); if (null != s) { const t = e[11],
                            r = Er(n.parent || e[6], e); if (Array.isArray(i))
                            for (let e = 0; e < i.length; e++) Sr(t, s, i[e], r);
                        else Sr(t, s, i, r) } }

                function Ar(t, e) { const i = 9 + t + 1; if (i < e.length) { const t = e[i],
                            n = t[1].firstChild; if (null !== n) return function t(e, i) { if (null !== i) { const n = i.type; if (3 === n) return Ve(i, e); if (0 === n) return Ar(-1, e[i.index]); if (4 === n || 5 === n) { const n = i.child; if (null !== n) return t(e, n); { const t = e[i.index]; return De(t) ? Ar(-1, t) : Le(t) } } { const n = e[16],
                                        s = n[6],
                                        r = ms(n),
                                        a = s.projection[i.projection]; return null != a ? t(r, a) : t(e, i.next) } } return null }(t, n) } return e[7] }

                function Ir(t, e, i, n, s, r, a) { for (; null != i;) { const o = n[i.index],
                            l = i.type;
                        a && 0 === e && (o && Jn(Le(o), n), i.flags |= 4), 64 != (64 & i.flags) && (4 === l || 5 === l ? (Ir(t, e, i.child, n, s, r, !1), pr(e, t, s, o, r)) : 1 === l ? Or(t, e, n, i, s, r) : pr(e, t, s, o, r)), i = a ? i.projectionNext : i.next } }

                function Tr(t, e, i, n, s, r) { Ir(i, n, t.node.child, e, s, r, !1) }

                function Or(t, e, i, n, s, r) { const a = i[16],
                        o = a[6].projection[n.projection]; if (Array.isArray(o))
                        for (let l = 0; l < o.length; l++) pr(e, t, s, o[l], r);
                    else Ir(t, e, o, a[3], s, r, !0) }

                function Rr(t, e, i) { Fe(t) ? t.setAttribute(e, "style", i) : e.style.cssText = i }

                function Mr(t, e, i) { Fe(t) ? "" === i ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", i) : e.className = i } class Pr { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._viewContainerRef = null, this._tViewNode = null } get rootNodes() { const t = this._lView; return null == t[0] ? function t(e, i, n, s, r = !1) { for (; null !== n;) { const a = i[n.index]; if (null !== a && s.push(Le(a)), De(a))
                                    for (let e = 9; e < a.length; e++) { const i = a[e],
                                            n = i[1].firstChild;
                                        null !== n && t(i[1], i, n, s) }
                                const o = n.type; if (4 === o || 5 === o) t(e, i, n.child, s);
                                else if (1 === o) { const e = i[16],
                                        r = e[6],
                                        a = ms(e); let o = r.projection[n.projection];
                                    null !== o && null !== a && t(a[1], a, o, s, !0) } n = r ? n.projectionNext : n.next } return s }(t[1], t, t[6].child, []) : [] } get context() { return this._lView[8] } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this);
                        else if (this._viewContainerRef) { const t = this._viewContainerRef.indexOf(this);
                            t > -1 && this._viewContainerRef.detach(t), this._viewContainerRef = null } br(this._lView[1], this._lView) } onDestroy(t) { var e, i, n;
                        e = this._lView[1], n = t, ar(i = this._lView).push(n), e.firstCreatePass && or(e).push(i[7].length - 1, null) } markForCheck() { er(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { ir(this._lView[1], this._lView, this.context) } checkNoChanges() {! function(t, e, i) { si(!0); try { ir(t, e, i) } finally { si(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef(t) { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!");
                        this._viewContainerRef = t } detachFromAppRef() { var t;
                        this._appRef = null, Tr(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!");
                        this._appRef = t } } class Fr extends Pr { constructor(t) { super(t), this._view = t } detectChanges() { nr(this._view) } checkNoChanges() {! function(t) { si(!0); try { nr(t) } finally { si(!1) } }(this._view) } get context() { return null } } let Nr, Lr, Br;

                function Vr(t, e, i) { return Nr || (Nr = class extends t {}), new Nr(Ve(e, i)) }

                function zr(t, e, i, n) { return Lr || (Lr = class extends t { constructor(t, e, i) { super(), this._declarationView = t, this._declarationTContainer = e, this.elementRef = i } createEmbeddedView(t) { const e = this._declarationTContainer.tViews,
                                i = Ss(this._declarationView, e, t, 16, null, e.node);
                            i[17] = this._declarationView[this._declarationTContainer.index]; const n = this._declarationView[5];
                            null !== n && (i[5] = n.createEmbeddedView(e)), Es(e, i, t); const s = new Pr(i); return s._tViewNode = i[6], s } }), 0 === i.type ? new Lr(n, i, Vr(e, i, n)) : null }

                function Ur(t, e, i, n) { let s;
                    Br || (Br = class extends t { constructor(t, e, i) { super(), this._lContainer = t, this._hostTNode = e, this._hostView = i } get element() { return Vr(e, this._hostTNode, this._hostView) } get injector() { return new on(this._hostTNode, this._hostView) } get parentInjector() { const t = Zi(this._hostTNode, this._hostView),
                                e = Vi(t, this._hostView),
                                i = function(t, e, i) { if (i.parent && -1 !== i.parent.injectorIndex) { const t = i.parent.injectorIndex; let e = i.parent; for (; null != e.parent && t == e.parent.injectorIndex;) e = e.parent; return e } let n = Bi(t),
                                        s = e,
                                        r = e[6]; for (; n > 1;) s = s[15], r = s[6], n--; return r }(t, this._hostView, this._hostTNode); return Ni(t) && null != i ? new on(i, e) : new on(null, this._hostView) } clear() { for (; this.length > 0;) this.remove(this.length - 1) } get(t) { return null !== this._lContainer[8] && this._lContainer[8][t] || null } get length() { return this._lContainer.length - 9 } createEmbeddedView(t, e, i) { const n = t.createEmbeddedView(e || {}); return this.insert(n, i), n } createComponent(t, e, i, n, s) { const r = i || this.parentInjector; if (!s && null == t.ngModule && r) { const t = r.get(te, null);
                                t && (s = t) } const a = t.create(r, n, void 0, s); return this.insert(a.hostView, e), a } insert(t, e) { const i = t._lView,
                                n = i[1]; if (t.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!"); if (this.allocateContainerIfNeeded(), De(i[3])) { const e = this.indexOf(t); if (-1 !== e) this.detach(e);
                                else { const e = i[3],
                                        n = new Br(e, e[6], e[3]);
                                    n.detach(n.indexOf(t)) } } const s = this._adjustIndex(e); return function(t, e, i, n) { const s = 9 + n,
                                    r = i.length;
                                n > 0 && (i[s - 1][4] = e), n < r - 9 ? (e[4] = i[s], ne(i, 9 + n, e)) : (i.push(e), e[4] = null), e[3] = i; const a = e[17];
                                null !== a && i !== a && function(t, e) { const i = t[5],
                                        n = e[3][3][16];
                                    16 != (16 & n[2]) && e[16] !== n && (t[2] |= 1), null === i ? t[5] = [e] : i.push(e) }(a, e); const o = e[5];
                                null !== o && o.insertView(t), e[2] |= 128 }(n, i, this._lContainer, s), fr(n, i, !0, Ar(s, this._lContainer)), t.attachToViewContainerRef(this), ne(this._lContainer[8], s, t), t } move(t, e) { if (t.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!"); return this.insert(t, e) } indexOf(t) { const e = this._lContainer[8]; return null !== e ? e.indexOf(t) : -1 } remove(t) { this.allocateContainerIfNeeded(); const e = this._adjustIndex(t, -1);
                            (function(t, e) { const i = _r(t, e);
                                i && br(i[1], i) })(this._lContainer, e), se(this._lContainer[8], e) } detach(t) { this.allocateContainerIfNeeded(); const e = this._adjustIndex(t, -1),
                                i = _r(this._lContainer, e); return i && null != se(this._lContainer[8], e) ? new Pr(i) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } allocateContainerIfNeeded() { null === this._lContainer[8] && (this._lContainer[8] = []) } }); const r = n[i.index]; if (De(r)) s = r,
                        function(t, e) { t[2] = -2 }(s);
                    else { let t; if (4 === i.type) t = Le(r);
                        else if (t = n[11].createComment(""), Re(n)) { const e = n[11],
                                s = Ve(i, n);
                            Cr(e, kr(e, s), t, function(t, e) { return Fe(t) ? t.nextSibling(e) : e.nextSibling }(e, s)) } else Dr(n[1], n, t, i);
                        n[i.index] = s = Ks(r, n, t, i), tr(n, s) } return new Br(s, i, n) }

                function Hr(t = !1) { return function(t, e, i) { if (!i && Ie(t)) { const i = He(t.index, e); return new Pr(i, i) } return 3 === t.type || 0 === t.type || 4 === t.type || 5 === t.type ? new Pr(e[16], e) : null }(Je(), Ke(), t) } let jr = (() => { class t {} return t.__NG_ELEMENT_ID__ = () => Gr(), t })(); const Gr = Hr,
                    $r = new Vt("Set Injector scope."),
                    Wr = {},
                    qr = {},
                    Yr = []; let Xr = void 0;

                function Kr() { return void 0 === Xr && (Xr = new Jt), Xr }

                function Zr(t, e = null, i = null, n) { return new Qr(t, i, e || Kr(), n) } class Qr { constructor(t, e, i, n = null) { this.parent = i, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = [];
                        e && ie(e, i => this.processProvider(i, t, e)), ie([t], t => this.processInjectorType(t, [], s)), this.records.set(zt, ea(void 0, this)); const r = this.records.get($r);
                        this.scope = null != r ? r.value : null, this.source = n || ("object" == typeof t ? null : wt(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = Ut, i = lt.Default) { this.assertNotDestroyed(); const n = Wt(this); try { if (!(i & lt.SkipSelf)) { let e = this.records.get(t); if (void 0 === e) { const i = ("function" == typeof(s = t) || "object" == typeof s && s instanceof Vt) && mt(t);
                                    e = i && this.injectableDefInScope(i) ? ea(Jr(t), Wr) : null, this.records.set(t, e) } if (null != e) return this.hydrate(t, e) } return (i & lt.Self ? Kr() : this.parent).get(t, e = i & lt.Optional && e === Ut ? null : e) } catch (r) { if ("NullInjectorError" === r.name) { if ((r.ngTempTokenPath = r.ngTempTokenPath || []).unshift(wt(t)), n) throw r; return function(t, e, i, n) { const s = t.ngTempTokenPath; throw e.__source && s.unshift(e.__source), t.message = function(t, e, i, n = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let s = wt(e); if (Array.isArray(e)) s = e.map(wt).join(" -> ");
                                        else if ("object" == typeof e) { let t = []; for (let i in e)
                                                if (e.hasOwnProperty(i)) { let n = e[i];
                                                    t.push(i + ":" + ("string" == typeof n ? JSON.stringify(n) : wt(n))) } s = `{${t.join(", ")}}` } return `${i}${n?"("+n+")":""}[${s}]: ${t.replace(Ht,"\n  ")}` }("\n" + t.message, s, i, n), t.ngTokenPath = s, t.ngTempTokenPath = null, t }(r, t, "R3InjectorError", this.source) } throw r } finally { Wt(n) } var s } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((e, i) => t.push(wt(i))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, i) { if (!(t = kt(t))) return !1; let n = ft(t); const s = null == n && t.ngModule || void 0,
                            r = void 0 === s ? t : s,
                            a = -1 !== i.indexOf(r); if (void 0 !== s && (n = ft(s)), null == n) return !1; if (null != n.imports && !a) { let t;
                            i.push(r); try { ie(n.imports, n => { this.processInjectorType(n, e, i) && (void 0 === t && (t = []), t.push(n)) }) } finally {} if (void 0 !== t)
                                for (let e = 0; e < t.length; e++) { const { ngModule: i, providers: n } = t[e];
                                    ie(n, t => this.processProvider(t, i, n || Yr)) } } this.injectorDefTypes.add(r), this.records.set(r, ea(n.factory, Wr)); const o = n.providers; if (null != o && !a) { const e = t;
                            ie(o, t => this.processProvider(t, e, o)) } return void 0 !== s && void 0 !== t.providers } processProvider(t, e, i) { let n = na(t = kt(t)) ? t : kt(t && t.provide); const s = function(t, e, i) { return ia(t) ? ea(void 0, t.useValue) : ea(ta(t, e, i), Wr) }(t, e, i); if (na(t) || !0 !== t.multi) { const t = this.records.get(n);
                            t && void 0 !== t.multi && es() } else { let e = this.records.get(n);
                            e ? void 0 === e.multi && es() : (e = ea(void 0, Wr, !0), e.factory = () => Qt(e.multi), this.records.set(n, e)), n = t, e.multi.push(t) } this.records.set(n, s) } hydrate(t, e) { var i; return e.value === qr ? function(t) { throw new Error(`Cannot instantiate cyclic dependency! ${t}`) }(wt(t)) : e.value === Wr && (e.value = qr, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (i = e.value) && "object" == typeof i && "function" == typeof i.ngOnDestroy && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { return !!t.providedIn && ("string" == typeof t.providedIn ? "any" === t.providedIn || t.providedIn === this.scope : this.injectorDefTypes.has(t.providedIn)) } }

                function Jr(t) { const e = mt(t),
                        i = null !== e ? e.factory : Se(t); if (null !== i) return i; const n = ft(t); if (null !== n) return n.factory; if (t instanceof Vt) throw new Error(`Token ${wt(t)} is missing a \u0275prov definition.`); if (t instanceof Function) return function(t) { const e = t.length; if (e > 0) { const i = re(e, "?"); throw new Error(`Can't resolve all parameters for ${wt(t)}: (${i.join(", ")}).`) } const i = function(t) { const e = t && (t[gt] || t[yt] || t[bt] && t[bt]()); if (e) { const i = function(t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${i}" that inherits its @Injectable decorator but does not provide one itself.\n` + `This will become an error in v10. Please add @Injectable() to the "${i}" class.`), e } return null }(t); return null !== i ? () => i.factory(t) : () => new t }(t); throw new Error("unreachable") }

                function ta(t, e, i) { let n = void 0; if (na(t)) { const e = kt(t); return Se(e) || Jr(e) } if (ia(t)) n = () => kt(t.useValue);
                    else if ((s = t) && s.useFactory) n = () => t.useFactory(...Qt(t.deps || []));
                    else if (function(t) { return !(!t || !t.useExisting) }(t)) n = () => Xt(kt(t.useExisting));
                    else { const s = kt(t && (t.useClass || t.provide)); if (s || function(t, e, i) { let n = ""; throw t && e && (n = ` - only instances of Provider and Type are allowed, got: [${e.map(t=>t==i?"?"+i+"?":"...").join(", ")}]`), new Error(`Invalid provider for the NgModule '${wt(t)}'` + n) }(e, i, t), ! function(t) { return !!t.deps }(t)) return Se(s) || Jr(s);
                        n = () => new s(...Qt(t.deps)) } var s; return n }

                function ea(t, e, i = !1) { return { factory: t, value: e, multi: i ? [] : void 0 } }

                function ia(t) { return null !== t && "object" == typeof t && jt in t }

                function na(t) { return "function" == typeof t } const sa = function(t, e, i) { return function(t, e = null, i = null, n) { const s = Zr(t, e, i, n); return s._resolveInjectorDefTypes(), s }({ name: i }, e, t, i) }; let ra = (() => { class t { static create(t, e) { return Array.isArray(t) ? sa(t, e, "") : sa(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = Ut, t.NULL = new Jt, t.\u0275prov = dt({ token: t, providedIn: "any", factory: () => Xt(zt) }), t.__NG_ELEMENT_ID__ = -1, t })(); const aa = new Vt("AnalyzeForEntryComponents"); let oa = new Map; const la = new Set;

                function ca(t) { return "string" == typeof t ? t : t.text() }

                function ha(t, e) { let i = t.styles,
                        n = t.classes,
                        s = 0; for (let r = 0; r < e.length; r++) { const t = e[r]; "number" == typeof t ? s = t : 1 == s ? n = Ct(n, t) : 2 == s && (i = Ct(i, t + ": " + e[++r] + ";")) } null !== i && (t.styles = i), null !== n && (t.classes = n) } let da = null;

                function ua() { if (!da) { const t = Ot.Symbol; if (t && t.iterator) da = t.iterator;
                        else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const i = t[e]; "entries" !== i && "size" !== i && Map.prototype[i] === Map.prototype.entries && (da = i) } } } return da }

                function ma(t, e) { return t === e || "number" == typeof t && "number" == typeof e && isNaN(t) && isNaN(e) } class pa { constructor(t) { this.wrapped = t } static wrap(t) { return new pa(t) } static unwrap(t) { return pa.isWrapped(t) ? t.wrapped : t } static isWrapped(t) { return t instanceof pa } }

                function fa(t) { return !!ga(t) && (Array.isArray(t) || !(t instanceof Map) && ua() in t) }

                function ga(t) { return null !== t && ("function" == typeof t || "object" == typeof t) }

                function _a(t, e, i) { return t[e] = i }

                function ba(t, e, i) { return !Object.is(t[e], i) && (t[e] = i, !0) }

                function ya(t, e, i, n) { const s = ba(t, e, i); return ba(t, e + 1, n) || s }

                function va(t, e, i, n) { const s = Ke(); return ba(s, oi(), e) && (Ze(), function(t, e, i, n, s, r) { const a = Ve(t, e),
                            o = e[11]; if (null == n) Fe(o) ? o.removeAttribute(a, i, r) : a.removeAttribute(i);
                        else { const e = null == s ? zi(n) : s(n, t.tagName || "", i);
                            Fe(o) ? o.setAttribute(a, i, e, r) : r ? a.setAttributeNS(r, i, e) : a.setAttribute(i, e) } }(wi(), s, t, e, i, n)), va }

                function wa(t, e, i, n) { return ba(t, oi(), i) ? e + zi(i) + n : us }

                function Ca(t, e, i, n, s, r, a, o) { const l = Ke(),
                        c = Ze(),
                        h = t + 19,
                        d = c.firstCreatePass ? function(t, e, i, n, s, r, a, o, l) { const c = e.consts,
                                h = ks(e, i[6], t, 0, a || null, We(c, o));
                            Bs(e, i, h, We(c, l)), Si(e, h); const d = h.tViews = Ps(2, -1, n, s, r, e.directiveRegistry, e.pipeRegistry, null, e.schemas, c),
                                u = Fs(0, null, 2, -1, null, null); return u.injectorIndex = h.injectorIndex, d.node = u, null !== e.queries && (e.queries.template(e, h), d.queries = e.queries.embeddedTView(h)), h }(t, c, l, e, i, n, s, r, a) : c.data[h];
                    ti(d, !1); const u = l[11].createComment("");
                    Dr(c, l, u, d), Jn(u, l), tr(l, l[h] = Ks(u, l, u, d)), Te(d) && Os(c, l, d), null != a && Rs(l, d, o) }

                function xa(t) { return Ue(Ye.lFrame.contextLView, t) }

                function Sa(t, e = lt.Default) { const i = Ke(); return null == i ? Xt(t, e) : Ji(Je(), i, kt(t), e) }

                function ka(t) { return function(t, e) { if ("class" === e) return t.classes; if ("style" === e) return t.styles; const i = t.attrs; if (i) { const t = i.length; let n = 0; for (; n < t;) { const s = i[n]; if (Ri(s)) break; if (0 === s) n += 2;
                                else if ("number" == typeof s)
                                    for (n++; n < t && "string" == typeof i[n];) n++;
                                else { if (s === e) return i[n + 1];
                                    n += 2 } } } return null }(Je(), t) }

                function Ea() { throw new Error("invalid") }

                function Da(t, e, i) { const n = Ke(); return ba(n, oi(), e) && Ls(Ze(), wi(), n, t, e, n[11], i, !1), Da }

                function Aa(t, e, i, n, s) { const r = s ? "class" : "style";
                    hr(t, i, e.inputs[r], r, n) }

                function Ia(t, e, i, n) { const s = Ke(),
                        r = Ze(),
                        a = 19 + t,
                        o = s[11],
                        l = s[a] = xs(e, o, Ye.lFrame.currentNamespace),
                        c = r.firstCreatePass ? function(t, e, i, n, s, r, a) { const o = e.consts,
                                l = We(o, r),
                                c = ks(e, i[6], t, 3, s, l); return Bs(e, i, c, We(o, a)), null !== c.mergedAttrs && ha(c, c.mergedAttrs), null !== e.queries && e.queries.elementStart(e, c), c }(t, r, s, 0, e, i, n) : r.data[a];
                    ti(c, !0); const h = c.mergedAttrs;
                    null !== h && Oi(o, l, h); const d = c.classes;
                    null !== d && Mr(o, l, d); const u = c.styles;
                    null !== u && Rr(o, l, u), Dr(r, s, l, c), 0 === Ye.lFrame.elementDepthCount && Jn(l, s), Ye.lFrame.elementDepthCount++, Te(c) && (Os(r, s, c), Ts(r, c, s)), null !== n && Rs(s, c) }

                function Ta() { let t = Je();
                    ei() ? ii() : (t = t.parent, ti(t, !1)); const e = t;
                    Ye.lFrame.elementDepthCount--; const i = Ze();
                    i.firstCreatePass && (Si(i, t), Ae(t) && i.queries.elementEnd(t)), null !== e.classes && function(t) { return 0 != (16 & t.flags) }(e) && Aa(i, e, Ke(), e.classes, !0), null !== e.styles && function(t) { return 0 != (32 & t.flags) }(e) && Aa(i, e, Ke(), e.styles, !1) }

                function Oa(t, e, i, n) { Ia(t, e, i, n), Ta() }

                function Ra(t, e, i) { const n = Ke(),
                        s = Ze(),
                        r = t + 19,
                        a = s.firstCreatePass ? function(t, e, i, n, s) { const r = e.consts,
                                a = We(r, n),
                                o = ks(e, i[6], t, 4, "ng-container", a); return null !== a && ha(o, a), Bs(e, i, o, We(r, s)), null !== e.queries && e.queries.elementStart(e, o), o }(t, s, n, e, i) : s.data[r];
                    ti(a, !0); const o = n[r] = n[11].createComment("");
                    Dr(s, n, o, a), Jn(o, n), Te(a) && (Os(s, n, a), Ts(s, a, n)), null != i && Rs(n, a) }

                function Ma() { let t = Je(); const e = Ze();
                    ei() ? ii() : (t = t.parent, ti(t, !1)), e.firstCreatePass && (Si(e, t), Ae(t) && e.queries.elementEnd(t)) }

                function Pa(t, e, i) { Ra(t, e, i), Ma() }

                function Fa() { return Ke() }

                function Na(t) { return !!t && "function" == typeof t.then }

                function La(t) { return !!t && "function" == typeof t.subscribe }

                function Ba(t, e, i = !1, n) { const s = Ke(),
                        r = Ze(),
                        a = Je(); return za(r, s, s[11], a, t, e, i, n), Ba }

                function Va(t, e, i = !1, n) { const s = Je(),
                        r = Ke(),
                        a = lr(s, r); return za(Ze(), r, a, s, t, e, i, n), Va }

                function za(t, e, i, n, s, r, a = !1, o) { const l = Te(n),
                        c = t.firstCreatePass && (t.cleanup || (t.cleanup = [])),
                        h = ar(e); let d = !0; if (3 === n.type) { const u = Ve(n, e),
                            m = o ? o(u) : de,
                            p = m.target || u,
                            f = h.length,
                            g = o ? t => o(Le(t[n.index])).target : n.index; if (Fe(i)) { let a = null; if (!o && l && (a = function(t, e, i, n) { const s = t.cleanup; if (null != s)
                                        for (let r = 0; r < s.length - 1; r += 2) { const t = s[r]; if (t === i && s[r + 1] === n) { const t = e[7],
                                                    i = s[r + 2]; return t.length > i ? t[i] : null } "string" == typeof t && (r += 2) }
                                    return null }(t, e, s, n.index)), null !== a)(a.__ngLastListenerFn__ || a).__ngNextListenerFn__ = r, a.__ngLastListenerFn__ = r, d = !1;
                            else { r = Ha(n, e, r, !1); const t = i.listen(m.name || p, s, r);
                                h.push(r, t), c && c.push(s, g, f, f + 1) } } else r = Ha(n, e, r, !0), p.addEventListener(s, r, a), h.push(r), c && c.push(s, g, f, a) } const u = n.outputs; let m; if (d && null !== u && (m = u[s])) { const t = m.length; if (t)
                            for (let i = 0; i < t; i += 2) { const t = e[m[i]][m[i + 1]].subscribe(r),
                                    a = h.length;
                                h.push(r, t), c && c.push(s, n.index, a, -(a + 1)) } } }

                function Ua(t, e, i) { try { return !1 !== e(i) } catch (n) { return cr(t, n), !1 } }

                function Ha(t, e, i, n) { return function s(r) { if (r === Function) return i; const a = 2 & t.flags ? He(t.index, e) : e;
                        0 == (32 & e[2]) && er(a); let o = Ua(e, i, r),
                            l = s.__ngNextListenerFn__; for (; l;) o = Ua(e, l, r) && o, l = l.__ngNextListenerFn__; return n && !1 === o && (r.preventDefault(), r.returnValue = !1), o } }

                function ja(t = 1) { return function(t) { return (Ye.lFrame.contextLView = function(t, e) { for (; t > 0;) e = e[15], t--; return e }(t, Ye.lFrame.contextLView))[8] }(t) }

                function Ga(t, e) { let i = null; const n = function(t) { const e = t.attrs; if (null != e) { const t = e.indexOf(5); if (0 == (1 & t)) return e[t + 1] } return null }(t); for (let s = 0; s < e.length; s++) { const r = e[s]; if ("*" !== r) { if (null === n ? ls(t, r, !0) : cs(n, r)) return s } else i = s } return i }

                function $a(t) { const e = Ke()[16][6]; if (!e.projection) { const i = e.projection = re(t ? t.length : 1, null),
                            n = i.slice(); let s = e.child; for (; null !== s;) { const e = t ? Ga(s, t) : 0;
                            null !== e && (n[e] ? n[e].projectionNext = s : i[e] = s, n[e] = s), s = s.next } } }

                function Wa(t, e = 0, i) { const n = Ke(),
                        s = Ze(),
                        r = ks(s, n[6], t, 1, null, i || null);
                    null === r.projection && (r.projection = e), ii(),
                        function(t, e, i) { Or(e[11], 0, e, i, wr(t, i, e), Er(i.parent || e[6], e)) }(s, n, r) }

                function qa(t, e, i) { return Ya(t, "", e, "", i), qa }

                function Ya(t, e, i, n, s) { const r = Ke(),
                        a = wa(r, e, i, n); return a !== us && Ls(Ze(), wi(), r, t, a, r[11], s, !1), Ya } const Xa = [];

                function Ka(t, e, i, n, s) { const r = t[i + 1],
                        a = null === e; let o = n ? _s(r) : ys(r),
                        l = !1; for (; 0 !== o && (!1 === l || a);) { const i = t[o + 1];
                        Za(t[o], e) && (l = !0, t[o + 1] = n ? ws(i) : bs(i)), o = n ? _s(i) : ys(i) } l && (t[i + 1] = n ? bs(r) : ws(r)) }

                function Za(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && le(t, e) >= 0 } const Qa = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 };

                function Ja(t) { return t.substring(Qa.key, Qa.keyEnd) }

                function to(t, e) { const i = Qa.textEnd; return i === e ? -1 : (e = Qa.keyEnd = function(t, e, i) { for (; e < i && t.charCodeAt(e) > 32;) e++; return e }(t, Qa.key = e, i), eo(t, e, i)) }

                function eo(t, e, i) { for (; e < i && t.charCodeAt(e) <= 32;) e++; return e }

                function io(t, e, i) { return ao(t, e, i, !1), io }

                function no(t, e) { return ao(t, e, null, !0), no }

                function so(t) { oo(ae, ro, t, !0) }

                function ro(t, e) { for (let i = function(t) { return function(t) { Qa.key = 0, Qa.keyEnd = 0, Qa.value = 0, Qa.valueEnd = 0, Qa.textEnd = t.length }(t), to(t, eo(t, 0, Qa.textEnd)) }(e); i >= 0; i = to(e, i)) ae(t, Ja(e), !0) }

                function ao(t, e, i, n) { const s = Ke(),
                        r = Ze(),
                        a = li(2); if (r.firstUpdatePass && co(r, t, a, n), e !== us && ba(s, a, e)) { let o;
                        null == i && (o = function() { const t = Ye.lFrame; return null === t ? null : t.currentSanitizer }()) && (i = o), mo(r, r.data[yi() + 19], s, s[11], t, s[a + 1] = function(t, e) { return null == t || ("function" == typeof e ? t = e(t) : "string" == typeof e ? t += e : "object" == typeof t && (t = wt(yn(t)))), t }(e, i), n, a) } }

                function oo(t, e, i, n) { const s = Ze(),
                        r = li(2);
                    s.firstUpdatePass && co(s, null, r, n); const a = Ke(); if (i !== us && ba(a, r, i)) { const o = s.data[yi() + 19]; if (go(o, n) && !lo(s, r)) { let t = n ? o.classes : o.styles;
                            null !== t && (i = Ct(t, i || "")), Aa(s, o, a, i, n) } else ! function(t, e, i, n, s, r, a, o) { s === us && (s = Xa); let l = 0,
                                c = 0,
                                h = 0 < s.length ? s[0] : null,
                                d = 0 < r.length ? r[0] : null; for (; null !== h || null !== d;) { const u = l < s.length ? s[l + 1] : void 0,
                                    m = c < r.length ? r[c + 1] : void 0; let p = null,
                                    f = void 0;
                                h === d ? (l += 2, c += 2, u !== m && (p = d, f = m)) : null === d || null !== h && h < d ? (l += 2, p = h) : (c += 2, p = d, f = m), null !== p && mo(t, e, i, n, p, f, a, o), h = l < s.length ? s[l] : null, d = c < r.length ? r[c] : null } }(s, o, a, a[11], a[r + 1], a[r + 1] = function(t, e, i) { if (null == i || "" === i) return Xa; const n = [],
                                s = yn(i); if (Array.isArray(s))
                                for (let r = 0; r < s.length; r++) t(n, s[r], !0);
                            else if ("object" == typeof s)
                                for (const r in s) s.hasOwnProperty(r) && t(n, r, s[r]);
                            else "string" == typeof s && e(n, s); return n }(t, e, i), n, r) } }

                function lo(t, e) { return e >= t.expandoStartIndex }

                function co(t, e, i, n) { const s = t.data; if (null === s[i + 1]) { const r = s[yi() + 19],
                            a = lo(t, i);
                        go(r, n) && null === e && !a && (e = !1), e = function(t, e, i, n) { const s = function(t) { const e = Ye.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] }(t); let r = n ? e.residualClasses : e.residualStyles; if (null === s) 0 === (n ? e.classBindings : e.styleBindings) && (i = uo(i = ho(null, t, e, i, n), e.attrs, n), r = null);
                                else { const a = e.directiveStylingLast; if (-1 === a || t[a] !== s)
                                        if (i = ho(s, t, e, i, n), null === r) { let i = function(t, e, i) { const n = i ? e.classBindings : e.styleBindings; if (0 !== ys(n)) return t[_s(n)] }(t, e, n);
                                            void 0 !== i && Array.isArray(i) && (i = ho(null, t, e, i[1], n), i = uo(i, e.attrs, n), function(t, e, i, n) { t[_s(i ? e.classBindings : e.styleBindings)] = n }(t, e, n, i)) } else r = function(t, e, i) { let n = void 0; const s = e.directiveEnd; for (let r = 1 + e.directiveStylingLast; r < s; r++) n = uo(n, t[r].hostAttrs, i); return uo(n, e.attrs, i) }(t, e, n) } return void 0 !== r && (n ? e.residualClasses = r : e.residualStyles = r), i }(s, r, e, n),
                            function(t, e, i, n, s, r) { let a = r ? e.classBindings : e.styleBindings,
                                    o = _s(a),
                                    l = ys(a);
                                t[n] = i; let c, h = !1; if (Array.isArray(i)) { const t = i;
                                    c = t[1], (null === c || le(t, c) > 0) && (h = !0) } else c = i; if (s)
                                    if (0 !== l) { const e = _s(t[o + 1]);
                                        t[n + 1] = gs(e, o), 0 !== e && (t[e + 1] = vs(t[e + 1], n)), t[o + 1] = 131071 & t[o + 1] | n << 17 } else t[n + 1] = gs(o, 0), 0 !== o && (t[o + 1] = vs(t[o + 1], n)), o = n;
                                else t[n + 1] = gs(l, 0), 0 === o ? o = n : t[l + 1] = vs(t[l + 1], n), l = n;
                                h && (t[n + 1] = bs(t[n + 1])), Ka(t, c, n, !0), Ka(t, c, n, !1),
                                    function(t, e, i, n, s) { const r = s ? t.residualClasses : t.residualStyles;
                                        null != r && "string" == typeof e && le(r, e) >= 0 && (i[n + 1] = ws(i[n + 1])) }(e, c, t, n, r), a = gs(o, l), r ? e.classBindings = a : e.styleBindings = a }(s, r, e, i, a, n) } }

                function ho(t, e, i, n, s) { let r = null; const a = i.directiveEnd; let o = i.directiveStylingLast; for (-1 === o ? o = i.directiveStart : o++; o < a && (r = e[o], n = uo(n, r.hostAttrs, s), r !== t);) o++; return null !== t && (i.directiveStylingLast = o), n }

                function uo(t, e, i) { const n = i ? 1 : 2; let s = -1; if (null !== e)
                        for (let r = 0; r < e.length; r++) { const a = e[r]; "number" == typeof a ? s = a : s === n && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), ae(t, a, !!i || e[++r])) }
                    return void 0 === t ? null : t }

                function mo(t, e, i, n, s, r, a, o) { if (3 !== e.type) return; const l = t.data,
                        c = l[o + 1];
                    fo(1 == (1 & c) ? po(l, e, i, s, ys(c), a) : void 0) || (fo(r) || function(t) { return 2 == (2 & t) }(c) && (r = po(l, null, i, s, o, a)), function(t, e, i, n, s) { const r = Fe(t); if (e) s ? r ? t.addClass(i, n) : i.classList.add(n) : r ? t.removeClass(i, n) : i.classList.remove(n);
                        else { const e = -1 == n.indexOf("-") ? void 0 : 2;
                            null == s ? r ? t.removeStyle(i, n, e) : i.style.removeProperty(n) : r ? t.setStyle(i, n, s, e) : i.style.setProperty(n, s) } }(n, a, Be(yi(), i), s, r)) }

                function po(t, e, i, n, s, r) { const a = null === e; let o = void 0; for (; s > 0;) { const e = t[s],
                            r = Array.isArray(e),
                            l = r ? e[1] : e,
                            c = null === l; let h = i[s + 1];
                        h === us && (h = c ? Xa : void 0); let d = c ? oe(h, n) : l === n ? h : void 0; if (r && !fo(d) && (d = oe(e, n)), fo(d) && (o = d, a)) return o; const u = t[s + 1];
                        s = a ? _s(u) : ys(u) } if (null !== e) { let t = r ? e.residualClasses : e.residualStyles;
                        null != t && (o = oe(t, n)) } return o }

                function fo(t) { return void 0 !== t }

                function go(t, e) { return 0 != (t.flags & (e ? 16 : 32)) }

                function _o(t, e = "") { const i = Ke(),
                        n = Ze(),
                        s = t + 19,
                        r = n.firstCreatePass ? ks(n, i[6], t, 3, null, null) : n.data[s],
                        a = i[s] = function(t, e) { return Fe(e) ? e.createText(t) : e.createTextNode(t) }(e, i[11]);
                    Dr(n, i, a, r), ti(r, !1) }

                function bo(t) { return yo("", t, ""), bo }

                function yo(t, e, i) { const n = Ke(),
                        s = wa(n, t, e, i); return s !== us && dr(n, yi(), s), yo }

                function vo(t, e, i, n, s) { const r = Ke(),
                        a = function(t, e, i, n, s, r) { const a = ya(t, ai(), i, s); return li(2), a ? e + zi(i) + n + zi(s) + r : us }(r, t, e, i, n, s); return a !== us && dr(r, yi(), a), vo }

                function wo(t, e, i, n, s, r, a) { const o = Ke(),
                        l = function(t, e, i, n, s, r, a, o) { const l = function(t, e, i, n, s) { const r = ya(t, e, i, n); return ba(t, e + 2, s) || r }(t, ai(), i, s, a); return li(3), l ? e + zi(i) + n + zi(s) + r + zi(a) + o : us }(o, t, e, i, n, s, r, a); return l !== us && dr(o, yi(), l), wo }

                function Co(t, e, i) { oo(ae, ro, wa(Ke(), t, e, i), !0) }

                function xo(t, e, i) { const n = Ke(); return ba(n, oi(), e) && Ls(Ze(), wi(), n, t, e, n[11], i, !0), xo }

                function So(t, e, i) { const n = Ke(); if (ba(n, oi(), e)) { const s = Ze(),
                            r = wi();
                        Ls(s, r, n, t, e, lr(r, n), i, !0) } return So }

                function ko(t, e) { const i = je(t)[1],
                        n = i.data.length - 1;
                    Si(i, { directiveStart: n, directiveEnd: n + 1 }) }

                function Eo(t) { let e = Object.getPrototypeOf(t.type.prototype).constructor,
                        i = !0; const n = [t]; for (; e;) { let s = void 0; if (Oe(t)) s = e.\u0275cmp || e.\u0275dir;
                        else { if (e.\u0275cmp) throw new Error("Directives cannot inherit Components");
                            s = e.\u0275dir } if (s) { if (i) { n.push(s); const e = t;
                                e.inputs = Do(t.inputs), e.declaredInputs = Do(t.declaredInputs), e.outputs = Do(t.outputs); const i = s.hostBindings;
                                i && To(t, i); const r = s.viewQuery,
                                    a = s.contentQueries; if (r && Ao(t, r), a && Io(t, a), ht(t.inputs, s.inputs), ht(t.declaredInputs, s.declaredInputs), ht(t.outputs, s.outputs), Oe(s) && s.data.animation) { const e = t.data;
                                    e.animation = (e.animation || []).concat(s.data.animation) } e.afterContentChecked = e.afterContentChecked || s.afterContentChecked, e.afterContentInit = t.afterContentInit || s.afterContentInit, e.afterViewChecked = t.afterViewChecked || s.afterViewChecked, e.afterViewInit = t.afterViewInit || s.afterViewInit, e.doCheck = t.doCheck || s.doCheck, e.onDestroy = t.onDestroy || s.onDestroy, e.onInit = t.onInit || s.onInit } const e = s.features; if (e)
                                for (let n = 0; n < e.length; n++) { const s = e[n];
                                    s && s.ngInherit && s(t), s === Eo && (i = !1) } } e = Object.getPrototypeOf(e) }! function(t) { let e = 0,
                            i = null; for (let n = t.length - 1; n >= 0; n--) { const s = t[n];
                            s.hostVars = e += s.hostVars, s.hostAttrs = Pi(s.hostAttrs, i = Pi(i, s.hostAttrs)) } }(n) }

                function Do(t) { return t === de ? {} : t === ue ? [] : t }

                function Ao(t, e) { const i = t.viewQuery;
                    t.viewQuery = i ? (t, n) => { e(t, n), i(t, n) } : e }

                function Io(t, e) { const i = t.contentQueries;
                    t.contentQueries = i ? (t, n, s) => { e(t, n, s), i(t, n, s) } : e }

                function To(t, e) { const i = t.hostBindings;
                    t.hostBindings = i ? (t, n) => { e(t, n), i(t, n) } : e } class Oo { constructor(t, e, i) { this.previousValue = t, this.currentValue = e, this.firstChange = i } isFirstChange() { return this.firstChange } }

                function Ro(t) { t.type.prototype.ngOnChanges && (t.setInput = Mo, t.onChanges = function() { const t = Po(this),
                            e = t && t.current; if (e) { const i = t.previous; if (i === de) t.previous = e;
                            else
                                for (let t in e) i[t] = e[t];
                            t.current = null, this.ngOnChanges(e) } }) }

                function Mo(t, e, i, n) { const s = Po(t) || function(t, e) { return t.__ngSimpleChanges__ = e }(t, { previous: de, current: null }),
                        r = s.current || (s.current = {}),
                        a = s.previous,
                        o = this.declaredInputs[i],
                        l = a[o];
                    r[o] = new Oo(l && l.currentValue, e, a === de), t[n] = e }

                function Po(t) { return t.__ngSimpleChanges__ || null }

                function Fo(t, e, i, n, s) { if (t = kt(t), Array.isArray(t))
                        for (let r = 0; r < t.length; r++) Fo(t[r], e, i, n, s);
                    else { const r = Ze(),
                            a = Ke(); let o = na(t) ? t : kt(t.provide),
                            l = ta(t); const c = Je(),
                            h = 65535 & c.providerIndexes,
                            d = c.directiveStart,
                            u = c.providerIndexes >> 16; if (na(t) || !t.multi) { const n = new Ti(l, s, Sa),
                                m = Bo(o, e, s ? h : h + u, d); - 1 === m ? (Qi(Yi(c, a), r, o), No(r, t, e.length), e.push(o), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 65536), i.push(n), a.push(n)) : (i[m] = n, a[m] = n) } else { const m = Bo(o, e, h + u, d),
                                p = Bo(o, e, h, h + u),
                                f = m >= 0 && i[m],
                                g = p >= 0 && i[p]; if (s && !g || !s && !f) { Qi(Yi(c, a), r, o); const h = function(t, e, i, n, s) { const r = new Ti(t, i, Sa); return r.multi = [], r.index = e, r.componentProviders = 0, Lo(r, s, n && !i), r }(s ? zo : Vo, i.length, s, n, l);!s && g && (i[p].providerFactory = h), No(r, t, e.length, 0), e.push(o), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 65536), i.push(h), a.push(h) } else No(r, t, m > -1 ? m : p, Lo(i[s ? p : m], l, !s && n));!s && n && g && i[p].componentProviders++ } } }

                function No(t, e, i, n) { const s = na(e); if (s || e.useClass) { const r = (e.useClass || e).prototype.ngOnDestroy; if (r) { const a = t.destroyHooks || (t.destroyHooks = []); if (!s && e.multi) { const t = a.indexOf(i); - 1 === t ? a.push(i, [n, r]) : a[t + 1].push(n, r) } else a.push(i, r) } } }

                function Lo(t, e, i) { return i && t.componentProviders++, t.multi.push(e) - 1 }

                function Bo(t, e, i, n) { for (let s = i; s < n; s++)
                        if (e[s] === t) return s; return -1 }

                function Vo(t, e, i, n) { return Uo(this.multi, []) }

                function zo(t, e, i, n) { const s = this.multi; let r; if (this.providerFactory) { const t = this.providerFactory.componentProviders,
                            e = sn(i, i[1], this.providerFactory.index, n);
                        r = e.slice(0, t), Uo(s, r); for (let i = t; i < e.length; i++) r.push(e[i]) } else r = [], Uo(s, r); return r }

                function Uo(t, e) { for (let i = 0; i < t.length; i++) e.push((0, t[i])()); return e }

                function Ho(t, e = []) { return i => { i.providersResolver = (i, n) => function(t, e, i) { const n = Ze(); if (n.firstCreatePass) { const s = Oe(t);
                                Fo(i, n.data, n.blueprint, s, !0), Fo(e, n.data, n.blueprint, s, !1) } }(i, n ? n(t) : t, e) } } Ro.ngInherit = !0;
                class jo {} class Go { resolveComponentFactory(t) { throw function(t) { const e = Error(`No component factory found for ${wt(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(t) } } let $o = (() => { class t {} return t.NULL = new Go, t })(),
                    Wo = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = () => qo(t), t })(); const qo = function(t) { return Vr(t, Je(), Ke()) };
                class Yo {} const Xo = function() { var t = { Important: 1, DashCase: 2 }; return t[t.Important] = "Important", t[t.DashCase] = "DashCase", t }(); let Ko = (() => { class t {} return t.__NG_ELEMENT_ID__ = () => Zo(), t })(); const Zo = function() { const t = Ke(),
                        e = He(Je().index, t); return function(t) { const e = t[11]; if (Fe(e)) return e; throw new Error("Cannot inject Renderer2 when the application uses Renderer3!") }(Ee(e) ? e : t) }; let Qo = (() => { class t {} return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => null }), t })();
                class Jo { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const tl = new Jo("9.1.1");
                class el { constructor() {} supports(t) { return fa(t) } create(t) { return new nl(t) } } const il = (t, e) => e;
                class nl { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || il } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next) t(e) } forEachOperation(t) { let e = this._itHead,
                            i = this._removalsHead,
                            n = 0,
                            s = null; for (; e || i;) { const r = !i || e && e.currentIndex < ol(i, n, s) ? e : i,
                                a = ol(r, n, s),
                                o = r.currentIndex; if (r === i) n--, i = i._nextRemoved;
                            else if (e = e._next, null == r.previousIndex) n++;
                            else { s || (s = []); const t = a - n,
                                    e = o - n; if (t != e) { for (let i = 0; i < t; i++) { const n = i < s.length ? s[i] : s[i] = 0,
                                            r = n + i;
                                        e <= r && r < t && (s[i] = n + 1) } s[r.previousIndex] = e - t } } a !== o && t(r, a, o) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious) t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded) t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved) t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved) t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange) t(e) } diff(t) { if (null == t && (t = []), !fa(t)) throw new Error(`Error trying to diff '${wt(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() {} check(t) { this._reset(); let e, i, n, s = this._itHead,
                            r = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++) i = t[e], n = this._trackByFn(e, i), null !== s && ma(s.trackById, n) ? (r && (s = this._verifyReinsertion(s, i, n, e)), ma(s.item, i) || this._addIdentityChange(s, i)) : (s = this._mismatch(s, i, n, e), r = !0), s = s._next } else e = 0,
                            function(t, e) { if (Array.isArray(t))
                                    for (let i = 0; i < t.length; i++) e(t[i]);
                                else { const i = t[ua()](); let n; for (; !(n = i.next()).done;) e(n.value) } }(t, t => { n = this._trackByFn(e, t), null !== s && ma(s.trackById, n) ? (r && (s = this._verifyReinsertion(s, t, n, e)), ma(s.item, t) || this._addIdentityChange(s, t)) : (s = this._mismatch(s, t, n, e), r = !0), s = s._next, e++ }), this.length = e; return this._truncate(s), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t, e; for (t = this._previousItHead = this._itHead; null !== t; t = t._next) t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded) t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = e) t.previousIndex = t.currentIndex, e = t._nextMoved;
                            this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, i, n) { let s; return null === t ? s = this._itTail : (s = t._prev, this._remove(t)), null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(i, n)) ? (ma(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, s, n)) : null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (ma(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, s, n)) : t = this._addAfter(new sl(e, i), s, n), t } _verifyReinsertion(t, e, i, n) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null); return null !== s ? t = this._reinsertAfter(s, t._prev, n) : t.currentIndex != n && (t.currentIndex = n, this._addToMoves(t, n)), t } _truncate(t) { for (; null !== t;) { const e = t._next;
                            this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, i) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const n = t._prevRemoved,
                            s = t._nextRemoved; return null === n ? this._removalsHead = s : n._nextRemoved = s, null === s ? this._removalsTail = n : s._prevRemoved = n, this._insertAfter(t, e, i), this._addToMoves(t, i), t } _moveAfter(t, e, i) { return this._unlink(t), this._insertAfter(t, e, i), this._addToMoves(t, i), t } _addAfter(t, e, i) { return this._insertAfter(t, e, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, i) { const n = null === e ? this._itHead : e._next; return t._next = n, t._prev = e, null === n ? this._itTail = t : n._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new al), this._linkedRecords.put(t), t.currentIndex = i, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev,
                            i = t._next; return null === e ? this._itHead = i : e._next = i, null === i ? this._itTail = e : i._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new al), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class sl { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class rl { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let i; for (i = this._head; null !== i; i = i._nextDup)
                            if ((null === e || e <= i.currentIndex) && ma(i.trackById, t)) return i; return null } remove(t) { const e = t._prevDup,
                            i = t._nextDup; return null === e ? this._head = i : e._nextDup = i, null === i ? this._tail = e : i._prevDup = e, null === this._head } } class al { constructor() { this.map = new Map } put(t) { const e = t.trackById; let i = this.map.get(e);
                        i || (i = new rl, this.map.set(e, i)), i.add(t) } get(t, e) { const i = this.map.get(t); return i ? i.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } }

                function ol(t, e, i) { const n = t.previousIndex; if (null === n) return n; let s = 0; return i && n < i.length && (s = i[n]), n + e + s } class ll { constructor() {} supports(t) { return t instanceof Map || ga(t) } create() { return new cl } } class cl { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next) t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious) t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged) t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded) t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved) t(e) } diff(t) { if (t) { if (!(t instanceof Map || ga(t))) throw new Error(`Error trying to diff '${wt(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() {} check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, i) => { if (e && e.key === i) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next;
                                else { const n = this._getOrCreateRecordForKey(i, t);
                                    e = this._insertBeforeOrAppend(e, n) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved) t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const i = t._prev; return e._next = t, e._prev = i, t._prev = e, i && (i._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const i = this._records.get(t);
                            this._maybeAddToChanges(i, e); const n = i._prev,
                                s = i._next; return n && (n._next = s), s && (s._prev = n), i._next = null, i._prev = null, i } const i = new hl(t); return this._records.set(t, i), i.currentValue = e, this._addToAdditions(i), i } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next) t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged) t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded) t.previousValue = t.currentValue;
                            this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { ma(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(i => e(t[i], i)) } } class hl { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } let dl = (() => { class t { constructor(t) { this.factories = t } static create(e, i) { if (null != i) { const t = i.factories.slice();
                                    e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: i => { if (!i) throw new Error("Cannot extend IterableDiffers without a parent injector"); return t.create(e, i) }, deps: [
                                        [t, new ot, new rt]
                                    ] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${i=t,i.name||typeof i}'`); var i } } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => new t([new el]) }), t })(),
                    ul = (() => { class t { constructor(t) { this.factories = t } static create(e, i) { if (i) { const t = i.factories.slice();
                                    e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: i => { if (!i) throw new Error("Cannot extend KeyValueDiffers without a parent injector"); return t.create(e, i) }, deps: [
                                        [t, new ot, new rt]
                                    ] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => new t([new ll]) }), t })(); const ml = [new ll],
                    pl = new dl([new el]),
                    fl = new ul(ml); let gl = (() => { class t {} return t.__NG_ELEMENT_ID__ = () => _l(t, Wo), t })(); const _l = function(t, e) { return zr(t, e, Je(), Ke()) }; let bl = (() => { class t {} return t.__NG_ELEMENT_ID__ = () => yl(t, Wo), t })(); const yl = function(t, e) { return Ur(t, e, Je(), Ke()) },
                    vl = {};
                class wl extends $o { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = xe(t); return new Sl(e, this.ngModule) } }

                function Cl(t) { const e = []; for (let i in t) t.hasOwnProperty(i) && e.push({ propName: t[i], templateName: i }); return e } const xl = new Vt("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Hi });
                class Sl extends jo { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(ds).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return Cl(this.componentDef.inputs) } get outputs() { return Cl(this.componentDef.outputs) } create(t, e, i, n) { const s = (n = n || this.ngModule) ? function(t, e) { return { get: (i, n, s) => { const r = t.get(i, vl, s); return r !== vl || n === vl ? r : e.get(i, n, s) } } }(t, n.injector) : t,
                            r = s.get(Yo, Ne),
                            a = s.get(Qo, null),
                            o = r.createRenderer(null, this.componentDef),
                            l = this.componentDef.selectors[0][0] || "div",
                            c = i ? function(t, e, i) { if (Fe(t)) return t.selectRootElement(e, i === he.ShadowDom); let n = "string" == typeof e ? t.querySelector(e) : e; return n.textContent = "", n }(o, i, this.componentDef.encapsulation) : xs(l, r.createRenderer(null, this.componentDef), function(t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(l)),
                            h = this.componentDef.onPush ? 576 : 528,
                            d = "string" == typeof i && /^#root-ng-internal-isolated-\d+/.test(i),
                            u = { components: [], scheduler: Hi, clean: rr, playerHandler: null, flags: 0 },
                            m = Ps(0, -1, null, 1, 0, null, null, null, null, null),
                            p = Ss(null, m, u, h, null, null, r, o, a, s); let f, g;
                        mi(p, null); try { const t = function(t, e, i, n, s, r) { const a = i[1];
                                i[19] = t; const o = ks(a, null, 0, 3, null, null),
                                    l = o.mergedAttrs = e.hostAttrs;
                                null !== l && (ha(o, l), null !== t && (Oi(s, t, l), null !== o.classes && Mr(s, t, o.classes), null !== o.styles && Rr(s, t, o.styles))); const c = n.createRenderer(t, e),
                                    h = Ss(i, Ms(e), null, e.onPush ? 64 : 16, i[19], o, n, c, void 0); return a.firstCreatePass && (Qi(Yi(o, i), a, e.type), js(a, o), $s(o, i.length, 1)), tr(i, h), i[19] = h }(c, this.componentDef, p, r, o); if (c)
                                if (i) Oi(o, c, ["ng-version", tl.full]);
                                else { const { attrs: t, classes: e } = function(t) { const e = [],
                                            i = []; let n = 1,
                                            s = 2; for (; n < t.length;) { let r = t[n]; if ("string" == typeof r) 2 === s ? "" !== r && e.push(r, t[++n]) : 8 === s && i.push(r);
                                            else { if (!as(s)) break;
                                                s = r } n++ } return { attrs: e, classes: i } }(this.componentDef.selectors[0]);
                                    t && Oi(o, c, t), e && e.length > 0 && Mr(o, c, e.join(" ")) } g = ze(p[1], 0), e && (g.projection = e.map(t => Array.from(t))), f = function(t, e, i, n, s) { const r = i[1],
                                    a = function(t, e, i) { const n = Je();
                                        t.firstCreatePass && (i.providersResolver && i.providersResolver(i), Hs(t, n, 1), Ws(t, e, i)); const s = sn(e, t, e.length - 1, n);
                                        Jn(s, e); const r = Ve(n, e); return r && Jn(r, e), s }(r, i, e);
                                n.components.push(a), t[8] = a, s && s.forEach(t => t(a, e)), e.contentQueries && e.contentQueries(1, a, i.length - 1); const o = Je(); if (r.firstCreatePass && (null !== e.hostBindings || null !== e.hostAttrs)) { vi(o.index - 19); const t = i[1];
                                    Vs(t, e), zs(t, i, e.hostVars), Us(e, a) } return a }(t, this.componentDef, p, u, [ko]), Es(m, p, null) } finally { bi() } const _ = new kl(this.componentType, f, Vr(Wo, g, p), p, g); return i && !d || (_.hostView._tViewNode.child = g), _ } } class kl extends class {} { constructor(t, e, i, n, s) { super(), this.location = i, this._rootLView = n, this._tNode = s, this.destroyCbs = [], this.instance = e, this.hostView = this.changeDetectorRef = new Fr(n), this.hostView._tViewNode = function(t, e, i, n) { let s = t.node; return null == s && (t.node = s = Fs(0, null, 2, -1, null, null)), n[6] = s }(n[1], 0, 0, n), this.componentType = t } get injector() { return new on(this._tNode, this._rootLView) } destroy() { this.destroyCbs && (this.destroyCbs.forEach(t => t()), this.destroyCbs = null, !this.hostView.destroyed && this.hostView.destroy()) } onDestroy(t) { this.destroyCbs && this.destroyCbs.push(t) } } const El = void 0; var Dl = ["en", [
                        ["a", "p"],
                        ["AM", "PM"], El
                    ],
                    [
                        ["AM", "PM"], El, El
                    ],
                    [
                        ["S", "M", "T", "W", "T", "F", "S"],
                        ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                        ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                        ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                    ], El, [
                        ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
                        ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                        ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
                    ], El, [
                        ["B", "A"],
                        ["BC", "AD"],
                        ["Before Christ", "Anno Domini"]
                    ], 0, [6, 0],
                    ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"],
                    ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"],
                    ["{1}, {0}", El, "{1} 'at' {0}", El],
                    [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"],
                    ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr",
                    function(t) { let e = Math.floor(Math.abs(t)),
                            i = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === i ? 1 : 5 }
                ]; let Al = {};

                function Il(t) { const e = function(t) { return t.toLowerCase().replace(/_/g, "-") }(t); let i = Tl(e); if (i) return i; const n = e.split("-")[0]; if (i = Tl(n), i) return i; if ("en" === n) return Dl; throw new Error(`Missing locale data for the locale "${t}".`) }

                function Tl(t) { return t in Al || (Al[t] = Ot.ng && Ot.ng.common && Ot.ng.common.locales && Ot.ng.common.locales[t]), Al[t] } const Ol = function() { var t = { LocaleId: 0, DayPeriodsFormat: 1, DayPeriodsStandalone: 2, DaysFormat: 3, DaysStandalone: 4, MonthsFormat: 5, MonthsStandalone: 6, Eras: 7, FirstDayOfWeek: 8, WeekendRange: 9, DateFormat: 10, TimeFormat: 11, DateTimeFormat: 12, NumberSymbols: 13, NumberFormats: 14, CurrencyCode: 15, CurrencySymbol: 16, CurrencyName: 17, Currencies: 18, Directionality: 19, PluralCase: 20, ExtraData: 21 }; return t[t.LocaleId] = "LocaleId", t[t.DayPeriodsFormat] = "DayPeriodsFormat", t[t.DayPeriodsStandalone] = "DayPeriodsStandalone", t[t.DaysFormat] = "DaysFormat", t[t.DaysStandalone] = "DaysStandalone", t[t.MonthsFormat] = "MonthsFormat", t[t.MonthsStandalone] = "MonthsStandalone", t[t.Eras] = "Eras", t[t.FirstDayOfWeek] = "FirstDayOfWeek", t[t.WeekendRange] = "WeekendRange", t[t.DateFormat] = "DateFormat", t[t.TimeFormat] = "TimeFormat", t[t.DateTimeFormat] = "DateTimeFormat", t[t.NumberSymbols] = "NumberSymbols", t[t.NumberFormats] = "NumberFormats", t[t.CurrencyCode] = "CurrencyCode", t[t.CurrencySymbol] = "CurrencySymbol", t[t.CurrencyName] = "CurrencyName", t[t.Currencies] = "Currencies", t[t.Directionality] = "Directionality", t[t.PluralCase] = "PluralCase", t[t.ExtraData] = "ExtraData", t }(); let Rl = "en-US";

                function Ml(t) { var e, i;
                    i = "Expected localeId to be defined", null == (e = t) && function(t, e, i, n) { throw new Error(`ASSERTION ERROR: ${t}` + ` [Expected=> null != ${e} <=Actual]`) }(i, e), "string" == typeof t && (Rl = t.toLowerCase().replace(/_/g, "-")) } const Pl = new Map;
                class Fl extends te { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new wl(this); const i = ke(t),
                            n = t[Nt] || null;
                        n && Ml(n), this._bootstrapComponents = Gi(i.bootstrap), this._r3Injector = Zr(t, e, [{ provide: te, useValue: this }, { provide: $o, useValue: this.componentFactoryResolver }], wt(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = ra.THROW_IF_NOT_FOUND, i = lt.Default) { return t === ra || t === te || t === zt ? this : this._r3Injector.get(t, e, i) } destroy() { const t = this._r3Injector;!t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Nl extends ee { constructor(t) { super(), this.moduleType = t, null !== ke(t) && function t(e) { if (null !== e.\u0275mod.id) { const t = e.\u0275mod.id;
                                (function(t, e, i) { if (e && e !== i) throw new Error(`Duplicate module registered for ${t} - ${wt(e)} vs ${wt(e.name)}`) })(t, Pl.get(t), e), Pl.set(t, e) } let i = e.\u0275mod.imports;
                            i instanceof Function && (i = i()), i && i.forEach(e => t(e)) }(t) } create(t) { return new Fl(this.moduleType, t) } }

                function Ll(t, e, i) { const n = ri() + t,
                        s = Ke(); return s[n] === us ? _a(s, n, i ? e.call(i) : e()) : function(t, e) { return t[e] }(s, n) }

                function Bl(t, e, i, n, s) { return function(t, e, i, n, s, r, a) { const o = e + i; return ya(t, o, s, r) ? _a(t, o + 2, a ? n.call(a, s, r) : n(s, r)) : Vl(t, o + 2) }(Ke(), ri(), t, e, i, n, s) }

                function Vl(t, e) { const i = t[e]; return i === us ? void 0 : i }

                function zl(t, e, i, n, s, r) { const a = e + i; return ba(t, a, s) ? _a(t, a + 1, r ? n.call(r, s) : n(s)) : Vl(t, a + 1) }

                function Ul(t, e) { const i = Ze(); let n; const s = t + 19;
                    i.firstCreatePass ? (n = function(t, e) { if (e)
                            for (let i = e.length - 1; i >= 0; i--) { const n = e[i]; if (t === n.name) return n }
                        throw new Error(`The pipe '${t}' could not be found!`) }(e, i.pipeRegistry), i.data[s] = n, n.onDestroy && (i.destroyHooks || (i.destroyHooks = [])).push(s, n.onDestroy)) : n = i.data[s]; const r = n.factory || (n.factory = Se(n.type)),
                        a = qt(Sa),
                        o = r(); return qt(a),
                        function(t, e, i, n) { const s = i + 19;
                            s >= t.data.length && (t.data[s] = null, t.blueprint[s] = null), e[s] = n }(i, Ke(), t, o), o }

                function Hl(t, e, i) { const n = Ke(),
                        s = Ue(n, t); return function(t, e) { return pa.isWrapped(e) && (e = pa.unwrap(e), t[ai()] = us), e }(n, function(t, e) { return t[1].data[e + 19].pure }(n, t) ? zl(n, ri(), e, s.transform, i, s) : s.transform(i)) } class jl extends k { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, i) { let n, s = t => null,
                            r = () => null;
                        t && "object" == typeof t ? (n = this.__isAsync ? e => { setTimeout(() => t.next(e)) } : e => { t.next(e) }, t.error && (s = this.__isAsync ? e => { setTimeout(() => t.error(e)) } : e => { t.error(e) }), t.complete && (r = this.__isAsync ? () => { setTimeout(() => t.complete()) } : () => { t.complete() })) : (n = this.__isAsync ? e => { setTimeout(() => t(e)) } : e => { t(e) }, e && (s = this.__isAsync ? t => { setTimeout(() => e(t)) } : t => { e(t) }), i && (r = this.__isAsync ? () => { setTimeout(() => i()) } : () => { i() })); const a = super.subscribe(n, s, r); return t instanceof d && t.add(a), a } }

                function Gl() { return this._results[ua()]() } class $l { constructor() { this.dirty = !0, this._results = [], this.changes = new jl, this.length = 0; const t = ua(),
                            e = $l.prototype;
                        e[t] || (e[t] = Gl) } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t) { this._results = function t(e, i) { void 0 === i && (i = e); for (let n = 0; n < e.length; n++) { let s = e[n];
                                Array.isArray(s) ? (i === e && (i = e.slice(0, n)), t(s, i)) : i !== e && i.push(s) } return i }(t), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], this.first = this._results[0] } notifyOnChanges() { this.changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } class Wl { constructor(t) { this.queryList = t, this.matches = null } clone() { return new Wl(this.queryList) } setDirty() { this.queryList.setDirty() } } class ql { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const i = null !== t.contentQueries ? t.contentQueries[0] : e.length,
                                n = []; for (let t = 0; t < i; t++) { const i = e.getByIndex(t);
                                n.push(this.queries[i.indexInDeclarationView].clone()) } return new ql(n) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++) null !== hc(t, e).matches && this.queries[e].setDirty() } } class Yl { constructor(t, e, i, n = null) { this.predicate = t, this.descendants = e, this.isStatic = i, this.read = n } } class Xl { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let i = 0; i < this.queries.length; i++) this.queries[i].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++) this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let i = 0; i < this.length; i++) { const n = null !== e ? e.length : 0,
                                s = this.getByIndex(i).embeddedTView(t, n);
                            s && (s.indexInDeclarationView = i, null !== e ? e.push(s) : e = [s]) } return null !== e ? new Xl(e) : null } template(t, e) { for (let i = 0; i < this.queries.length; i++) this.queries[i].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class Kl { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new Kl(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && !1 === this.metadata.descendants) { const e = this._declarationNodeIndex; let i = t.parent; for (; null !== i && 4 === i.type && i.index !== e;) i = i.parent; return e === (null !== i ? i.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { if (Array.isArray(this.metadata.predicate)) { const i = this.metadata.predicate; for (let n = 0; n < i.length; n++) this.matchTNodeWithReadOption(t, e, Zl(e, i[n])) } else { const i = this.metadata.predicate;
                            i === gl ? 0 === e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, nn(e, t, i, !1, !1)) } } matchTNodeWithReadOption(t, e, i) { if (null !== i) { const n = this.metadata.read; if (null !== n)
                                if (n === Wo || n === bl || n === gl && 0 === e.type) this.addMatch(e.index, -2);
                                else { const i = nn(e, t, n, !1, !1);
                                    null !== i && this.addMatch(e.index, i) } else this.addMatch(e.index, i) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } }

                function Zl(t, e) { const i = t.localNames; if (null !== i)
                        for (let n = 0; n < i.length; n += 2)
                            if (i[n] === e) return i[n + 1]; return null }

                function Ql(t, e, i, n) { return -1 === i ? function(t, e) { return 3 === t.type || 4 === t.type ? Vr(Wo, t, e) : 0 === t.type ? zr(gl, Wo, t, e) : null }(e, t) : -2 === i ? function(t, e, i) { return i === Wo ? Vr(Wo, e, t) : i === gl ? zr(gl, Wo, e, t) : i === bl ? Ur(bl, Wo, e, t) : void 0 }(t, e, n) : sn(t, t[1], i, e) }

                function Jl(t, e, i, n) { const s = e[5].queries[n]; if (null === s.matches) { const n = t.data,
                            r = i.matches,
                            a = []; for (let t = 0; t < r.length; t += 2) { const s = r[t];
                            a.push(s < 0 ? null : Ql(e, n[s], r[t + 1], i.metadata.read)) } s.matches = a } return s.matches }

                function tc(t) { const e = Ke(),
                        i = Ze(),
                        n = hi();
                    di(n + 1); const s = hc(i, n); if (t.dirty && Ge(e) === s.metadata.isStatic) { if (null === s.matches) t.reset([]);
                        else { const r = s.crossesNgTemplate ? function t(e, i, n, s) { const r = e.queries.getByIndex(n),
                                    a = r.matches; if (null !== a) { const o = Jl(e, i, r, n); for (let e = 0; e < a.length; e += 2) { const n = a[e]; if (n > 0) s.push(o[e / 2]);
                                        else { const r = a[e + 1],
                                                o = i[-n]; for (let e = 9; e < o.length; e++) { const i = o[e];
                                                i[17] === i[3] && t(i[1], i, r, s) } if (null !== o[5]) { const e = o[5]; for (let i = 0; i < e.length; i++) { const n = e[i];
                                                    t(n[1], n, r, s) } } } } } return s }(i, e, n, []) : Jl(i, e, s, n);
                            t.reset(r), t.notifyOnChanges() } return !0 } return !1 }

                function ec(t, e, i) { nc(Ze(), Ke(), t, e, i, !0) }

                function ic(t, e, i) { nc(Ze(), Ke(), t, e, i, !1) }

                function nc(t, e, i, n, s, r) { t.firstCreatePass && (cc(t, new Yl(i, n, r, s), -1), r && (t.staticViewQueries = !0)), lc(t, e) }

                function sc(t, e, i, n) { ac(Ze(), Ke(), e, i, n, !1, Je(), t) }

                function rc(t, e, i, n) { ac(Ze(), Ke(), e, i, n, !0, Je(), t) }

                function ac(t, e, i, n, s, r, a, o) { t.firstCreatePass && (cc(t, new Yl(i, n, r, s), a.index), function(t, e) { const i = t.contentQueries || (t.contentQueries = []);
                        e !== (t.contentQueries.length ? i[i.length - 1] : -1) && i.push(t.queries.length - 1, e) }(t, o), r && (t.staticContentQueries = !0)), lc(t, e) }

                function oc() { return t = Ke(), e = hi(), t[5].queries[e].queryList; var t, e }

                function lc(t, e) { const i = new $l;! function(t, e, i, n) { const s = ar(e);
                        s.push(i), t.firstCreatePass && or(t).push(n, s.length - 1) }(t, e, i, i.destroy), null === e[5] && (e[5] = new ql), e[5].queries.push(new Wl(i)) }

                function cc(t, e, i) { null === t.queries && (t.queries = new Xl), t.queries.track(new Kl(e, i)) }

                function hc(t, e) { return t.queries.getByIndex(e) }

                function dc(t, e) { return zr(gl, Wo, t, e) } const uc = new Vt("Application Initializer"); let mc = (() => { class t { constructor(t) { this.appInits = t, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [],
                                e = () => { this.done = !0, this.resolve() }; if (this.appInits)
                                for (let i = 0; i < this.appInits.length; i++) { const e = this.appInits[i]();
                                    Na(e) && t.push(e) } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uc, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const pc = new Vt("AppId"),
                    fc = { provide: pc, useFactory: function() { return `${gc()}${gc()}${gc()}` }, deps: [] };

                function gc() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const _c = new Vt("Platform Initializer"),
                    bc = new Vt("Platform ID"),
                    yc = new Vt("appBootstrapListener"); let vc = (() => { class t { log(t) { console.log(t) } warn(t) { console.warn(t) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const wc = new Vt("LocaleId"),
                    Cc = new Vt("DefaultCurrencyCode");
                class xc { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const Sc = function(t) { return new Nl(t) },
                    kc = Sc,
                    Ec = function(t) { return Promise.resolve(Sc(t)) },
                    Dc = function(t) { const e = Sc(t),
                            i = Gi(ke(t).declarations).reduce((t, e) => { const i = xe(e); return i && t.push(new Sl(i)), t }, []); return new xc(e, i) },
                    Ac = Dc,
                    Ic = function(t) { return Promise.resolve(Dc(t)) }; let Tc = (() => { class t { constructor() { this.compileModuleSync = kc, this.compileModuleAsync = Ec, this.compileModuleAndAllComponentsSync = Ac, this.compileModuleAndAllComponentsAsync = Ic } clearCache() {} clearCacheFor(t) {} getModuleId(t) {} } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Oc = new Vt("compilerOptions"),
                    Rc = (() => Promise.resolve(0))();

                function Mc(t) { "undefined" == typeof Zone ? Rc.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Pc { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new jl(!1), this.onMicrotaskEmpty = new jl(!1), this.onStable = new jl(!1), this.onError = new jl(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js");
                        Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), this.shouldCoalesceEventChangeDetection = e, this.lastRequestAnimationFrameId = -1, this.nativeRequestAnimationFrame = function() { let t = Ot.requestAnimationFrame,
                                    e = Ot.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const i = t[Zone.__symbol__("OriginalDelegate")];
                                    i && (t = i); const n = e[Zone.__symbol__("OriginalDelegate")];
                                    n && (e = n) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame,
                            function(t) { const e = !!t.shouldCoalesceEventChangeDetection && t.nativeRequestAnimationFrame && (() => {! function(t) {-1 === t.lastRequestAnimationFrameId && (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(Ot, () => { t.lastRequestAnimationFrameId = -1, Bc(t), Lc(t) }), Bc(t)) }(t) });
                                t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0, maybeDelayChangeDetection: e }, onInvokeTask: (i, n, s, r, a, o) => { try { return Vc(t), i.invokeTask(s, r, a, o) } finally { e && "eventTask" === r.type && e(), zc(t) } }, onInvoke: (e, i, n, s, r, a, o) => { try { return Vc(t), e.invoke(n, s, r, a, o) } finally { zc(t) } }, onHasTask: (e, i, n, s) => { e.hasTask(n, s), i === n && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, Bc(t), Lc(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (e, i, n, s) => (e.handleError(n, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) }(this) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Pc.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Pc.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, i) { return this._inner.run(t, e, i) } runTask(t, e, i, n) { const s = this._inner,
                            r = s.scheduleEventTask("NgZoneEvent: " + n, t, Nc, Fc, Fc); try { return s.runTask(r, e, i) } finally { s.cancelTask(r) } } runGuarded(t, e, i) { return this._inner.runGuarded(t, e, i) } runOutsideAngular(t) { return this._outer.run(t) } }

                function Fc() {} const Nc = {};

                function Lc(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } }

                function Bc(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || t.shouldCoalesceEventChangeDetection && -1 !== t.lastRequestAnimationFrameId) }

                function Vc(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) }

                function zc(t) { t._nesting--, Lc(t) } class Uc { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new jl, this.onMicrotaskEmpty = new jl, this.onStable = new jl, this.onError = new jl } run(t, e, i) { return t.apply(e, i) } runGuarded(t, e, i) { return t.apply(e, i) } runOutsideAngular(t) { return t() } runTask(t, e, i, n) { return t.apply(e, i) } } let Hc = (() => { class t { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Pc.assertNotInAngularZone(), Mc(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Mc(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop();
                                        clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 });
                                else { let t = this.getPendingTasks();
                                    this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, i) { let n = -1;
                                e && e > 0 && (n = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== n), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: n, updateCb: i }) } whenStable(t, e, i) { if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
                                this.addCallback(t, e, i), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, i) { return [] } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Pc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(),
                    jc = (() => { class t { constructor() { this._applications = new Map, Wc.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return Wc.findTestabilityInTree(this, t, e) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();
                class Gc { addToWindow(t) {} findTestabilityInTree(t, e, i) { return null } } let $c, Wc = new Gc,
                    qc = function(t, e, i) { const n = t.get(Oc, []).concat(e),
                            s = new Nl(i); if (0 === oa.size) return Promise.resolve(s); const r = function(t) { const e = []; return t.forEach(t => t && e.push(...t)), e }(n.map(t => t.providers)); if (0 === r.length) return Promise.resolve(s); const a = function() { const t = Ot.ng; if (!t || !t.\u0275compilerFacade) throw new Error("Angular JIT compilation failed: '@angular/compiler' not loaded!\n  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\n  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\n  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping."); return t.\u0275compilerFacade }(),
                            o = ra.create({ providers: r }).get(a.ResourceLoader); return function(t) { const e = [],
                                i = new Map;

                            function n(t) { let e = i.get(t); if (!e) { const n = (t => Promise.resolve(o.get(t)))(t);
                                    i.set(t, e = n.then(ca)) } return e } return oa.forEach((t, i) => { const s = [];
                                t.templateUrl && s.push(n(t.templateUrl).then(e => { t.template = e })); const r = t.styleUrls,
                                    a = t.styles || (t.styles = []),
                                    o = t.styles.length;
                                r && r.forEach((e, i) => { a.push(""), s.push(n(e).then(n => { a[o + i] = n, r.splice(r.indexOf(e), 1), 0 == r.length && (t.styleUrls = void 0) })) }); const l = Promise.all(s).then(() => function(t) { la.delete(t) }(i));
                                e.push(l) }), oa = new Map, Promise.all(e).then(() => {}) }().then(() => s) }; const Yc = new Vt("AllowMultipleToken");
                class Xc { constructor(t, e) { this.name = t, this.token = e } }

                function Kc(t, e, i = []) { const n = `Platform: ${e}`,
                        s = new Vt(n); return (e = []) => { let r = Zc(); if (!r || r.injector.get(Yc, !1))
                            if (t) t(i.concat(e).concat({ provide: s, useValue: !0 }));
                            else { const t = i.concat(e).concat({ provide: s, useValue: !0 }, { provide: $r, useValue: "platform" });! function(t) { if ($c && !$c.destroyed && !$c.injector.get(Yc, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one.");
                                    $c = t.get(Qc); const e = t.get(_c, null);
                                    e && e.forEach(t => t()) }(ra.create({ providers: t, name: n })) } return function(t) { const e = Zc(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(s) } }

                function Zc() { return $c && !$c.destroyed ? $c : null } let Qc = (() => { class t { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const i = function(t, e) { let i; return i = "noop" === t ? new Uc : ("zone.js" === t ? void 0 : t) || new Pc({ enableLongStackTrace: Sn(), shouldCoalesceEventChangeDetection: e }), i }(e ? e.ngZone : void 0, e && e.ngZoneEventCoalescing || !1),
                                n = [{ provide: Pc, useValue: i }]; return i.run(() => { const e = ra.create({ providers: n, parent: this.injector, name: t.moduleType.name }),
                                    s = t.create(e),
                                    r = s.injector.get(un, null); if (!r) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return s.onDestroy(() => eh(this._modules, s)), i.runOutsideAngular(() => i.onError.subscribe({ next: t => { r.handleError(t) } })),
                                    function(t, e, i) { try { const n = i(); return Na(n) ? n.catch(i => { throw e.runOutsideAngular(() => t.handleError(i)), i }) : n } catch (n) { throw e.runOutsideAngular(() => t.handleError(n)), n } }(r, i, () => { const t = s.injector.get(mc); return t.runInitializers(), t.donePromise.then(() => (Ml(s.injector.get(wc, "en-US") || "en-US"), this._moduleDoBootstrap(s), s)) }) }) } bootstrapModule(t, e = []) { const i = Jc({}, e); return qc(this.injector, i, t).then(t => this.bootstrapModuleFactory(t, i)) } _moduleDoBootstrap(t) { const e = t.injector.get(th); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t));
                            else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${wt(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` + "Please define one of these.");
                                t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!");
                            this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function(e) { return new(e || t)(Xt(ra)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();

                function Jc(t, e) { return Array.isArray(e) ? e.reduce(Jc, t) : Object.assign(Object.assign({}, t), e) } let th = (() => { class t { constructor(t, e, i, n, s, r) { this._zone = t, this._console = e, this._injector = i, this._exceptionHandler = n, this._componentFactoryResolver = s, this._initStatus = r, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = Sn(), this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const a = new v(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }),
                                o = new v(t => { let e;
                                    this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { Pc.assertNotInAngularZone(), Mc(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const i = this._zone.onUnstable.subscribe(() => { Pc.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), i.unsubscribe() } });
                            this.isStable = q(a, o.pipe(et())) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let i;
                            i = t instanceof jo ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(i.componentType); const n = i.isBoundToModule ? void 0 : this._injector.get(te),
                                s = i.create(ra.NULL, [], e || i.selector, n);
                            s.onDestroy(() => { this._unloadComponent(s) }); const r = s.injector.get(Hc, null); return r && s.injector.get(jc).registerApplication(s.location.nativeElement, r), this._loadComponent(s), Sn() && this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."), s } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let t of this._views) t.detectChanges(); if (this._enforceNoNewChanges)
                                    for (let t of this._views) t.checkNoChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const e = t;
                            this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t;
                            eh(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(yc, []).concat(this._bootstrapListeners).forEach(e => e(t)) } _unloadComponent(t) { this.detachView(t.hostView), eh(this.components, t) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()) } get viewCount() { return this._views.length } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Pc), Xt(vc), Xt(ra), Xt(un), Xt($o), Xt(mc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();

                function eh(t, e) { const i = t.indexOf(e);
                    i > -1 && t.splice(i, 1) } class ih {} class nh {} const sh = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let rh = (() => { class t { constructor(t, e) { this._compiler = t, this._config = e || sh } load(t) { return this.loadAndCompile(t) } loadAndCompile(t) { let [e, n] = t.split("#"); return void 0 === n && (n = "default"), i("zn8P")(e).then(t => t[n]).then(t => ah(t, e, n)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, n] = t.split("#"), s = "NgFactory"; return void 0 === n && (n = "default", s = ""), i("zn8P")(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[n + s]).then(t => ah(t, e, n)) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Tc), Xt(nh, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();

                function ah(t, e, i) { if (!t) throw new Error(`Cannot find '${i}' in '${e}'`); return t } const oh = Kc(null, "core", [{ provide: bc, useValue: "unknown" }, { provide: Qc, deps: [ra] }, { provide: jc, deps: [] }, { provide: vc, deps: [] }]),
                    lh = [{ provide: th, useClass: th, deps: [Pc, vc, ra, un, $o, mc] }, { provide: xl, deps: [Pc], useFactory: function(t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;) e.pop()() }),
                                function(t) { e.push(t) } } }, { provide: mc, useClass: mc, deps: [
                            [new rt, uc]
                        ] }, { provide: Tc, useClass: Tc, deps: [] }, fc, { provide: dl, useFactory: function() { return pl }, deps: [] }, { provide: ul, useFactory: function() { return fl }, deps: [] }, { provide: wc, useFactory: function(t) { return Ml(t = t || "undefined" != typeof $localize && $localize.locale || "en-US"), t }, deps: [
                            [new st(wc), new rt, new ot]
                        ] }, { provide: Cc, useValue: "USD" }]; let ch = (() => { class t { constructor(t) {} } return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t)(Xt(th)) }, providers: lh }), t })(),
                    hh = null;

                function dh() { return hh } const uh = new Vt("DocumentToken"); let mh = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: ph, token: t, providedIn: "platform" }), t })();

                function ph() { return Xt(gh) } const fh = new Vt("Location Initialized"); let gh = (() => { class t extends mh { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = dh().getLocation(), this._history = dh().getHistory() } getBaseHrefFromDOM() { return dh().getBaseHref(this._doc) } onPopState(t) { dh().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", t, !1) } onHashChange(t) { dh().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", t, !1) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, i) { _h() ? this._history.pushState(t, e, i) : this.location.hash = i } replaceState(t, e, i) { _h() ? this._history.replaceState(t, e, i) : this.location.hash = i } forward() { this._history.forward() } back() { this._history.back() } getState() { return this._history.state } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh)) }, t.\u0275prov = dt({ factory: bh, token: t, providedIn: "platform" }), t })();

                function _h() { return !!window.history.pushState }

                function bh() { return new gh(Xt(uh)) }

                function yh(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let i = 0; return t.endsWith("/") && i++, e.startsWith("/") && i++, 2 == i ? t + e.substring(1) : 1 == i ? t + e : t + "/" + e }

                function vh(t) { const e = t.match(/#|\?|$/),
                        i = e && e.index || t.length; return t.slice(0, i - ("/" === t[i - 1] ? 1 : 0)) + t.slice(i) }

                function wh(t) { return t && "?" !== t[0] ? "?" + t : t } let Ch = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: xh, token: t, providedIn: "root" }), t })();

                function xh(t) { const e = Xt(uh).location; return new kh(Xt(mh), e && e.origin || "") } const Sh = new Vt("appBaseHref"); let kh = (() => { class t extends Ch { constructor(t, e) { if (super(), this._platformLocation = t, null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
                                this._baseHref = e } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return yh(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + wh(this._platformLocation.search),
                                    i = this._platformLocation.hash; return i && t ? `${e}${i}` : e } pushState(t, e, i, n) { const s = this.prepareExternalUrl(i + wh(n));
                                this._platformLocation.pushState(t, e, s) } replaceState(t, e, i, n) { const s = this.prepareExternalUrl(i + wh(n));
                                this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function(e) { return new(e || t)(Xt(mh), Xt(Sh, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(),
                    Eh = (() => { class t extends Ch { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", null != e && (this._baseHref = e) } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = yh(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, i, n) { let s = this.prepareExternalUrl(i + wh(n));
                                0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, e, s) } replaceState(t, e, i, n) { let s = this.prepareExternalUrl(i + wh(n));
                                0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function(e) { return new(e || t)(Xt(mh), Xt(Sh, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(),
                    Dh = (() => { class t { constructor(t, e) { this._subject = new jl, this._urlChangeListeners = [], this._platformStrategy = t; const i = this._platformStrategy.getBaseHref();
                                this._platformLocation = e, this._baseHref = vh(Ih(i)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + wh(e)) } normalize(e) { return t.stripTrailingSlash(function(t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, Ih(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", i = null) { this._platformStrategy.pushState(i, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + wh(e)), i) } replaceState(t, e = "", i = null) { this._platformStrategy.replaceState(i, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + wh(e)), i) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } onUrlChange(t) { this._urlChangeListeners.push(t), this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) }) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(i => i(t, e)) } subscribe(t, e, i) { return this._subject.subscribe({ next: t, error: e, complete: i }) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Ch), Xt(mh)) }, t.normalizeQueryParams = wh, t.joinWithSlash = yh, t.stripTrailingSlash = vh, t.\u0275prov = dt({ factory: Ah, token: t, providedIn: "root" }), t })();

                function Ah() { return new Dh(Xt(Ch), Xt(mh)) }

                function Ih(t) { return t.replace(/\/index.html$/, "") } const Th = { ADP: [void 0, void 0, 0], AFN: [void 0, void 0, 0], ALL: [void 0, void 0, 0], AMD: [void 0, void 0, 2], AOA: [void 0, "Kz"], ARS: [void 0, "$"], AUD: ["A$", "$"], BAM: [void 0, "KM"], BBD: [void 0, "$"], BDT: [void 0, "\u09f3"], BHD: [void 0, void 0, 3], BIF: [void 0, void 0, 0], BMD: [void 0, "$"], BND: [void 0, "$"], BOB: [void 0, "Bs"], BRL: ["R$"], BSD: [void 0, "$"], BWP: [void 0, "P"], BYN: [void 0, "\u0440.", 2], BYR: [void 0, void 0, 0], BZD: [void 0, "$"], CAD: ["CA$", "$", 2], CHF: [void 0, void 0, 2], CLF: [void 0, void 0, 4], CLP: [void 0, "$", 0], CNY: ["CN\xa5", "\xa5"], COP: [void 0, "$", 2], CRC: [void 0, "\u20a1", 2], CUC: [void 0, "$"], CUP: [void 0, "$"], CZK: [void 0, "K\u010d", 2], DJF: [void 0, void 0, 0], DKK: [void 0, "kr", 2], DOP: [void 0, "$"], EGP: [void 0, "E\xa3"], ESP: [void 0, "\u20a7", 0], EUR: ["\u20ac"], FJD: [void 0, "$"], FKP: [void 0, "\xa3"], GBP: ["\xa3"], GEL: [void 0, "\u20be"], GIP: [void 0, "\xa3"], GNF: [void 0, "FG", 0], GTQ: [void 0, "Q"], GYD: [void 0, "$", 2], HKD: ["HK$", "$"], HNL: [void 0, "L"], HRK: [void 0, "kn"], HUF: [void 0, "Ft", 2], IDR: [void 0, "Rp", 2], ILS: ["\u20aa"], INR: ["\u20b9"], IQD: [void 0, void 0, 0], IRR: [void 0, void 0, 0], ISK: [void 0, "kr", 0], ITL: [void 0, void 0, 0], JMD: [void 0, "$"], JOD: [void 0, void 0, 3], JPY: ["\xa5", void 0, 0], KHR: [void 0, "\u17db"], KMF: [void 0, "CF", 0], KPW: [void 0, "\u20a9", 0], KRW: ["\u20a9", void 0, 0], KWD: [void 0, void 0, 3], KYD: [void 0, "$"], KZT: [void 0, "\u20b8"], LAK: [void 0, "\u20ad", 0], LBP: [void 0, "L\xa3", 0], LKR: [void 0, "Rs"], LRD: [void 0, "$"], LTL: [void 0, "Lt"], LUF: [void 0, void 0, 0], LVL: [void 0, "Ls"], LYD: [void 0, void 0, 3], MGA: [void 0, "Ar", 0], MGF: [void 0, void 0, 0], MMK: [void 0, "K", 0], MNT: [void 0, "\u20ae", 2], MRO: [void 0, void 0, 0], MUR: [void 0, "Rs", 2], MXN: ["MX$", "$"], MYR: [void 0, "RM"], NAD: [void 0, "$"], NGN: [void 0, "\u20a6"], NIO: [void 0, "C$"], NOK: [void 0, "kr", 2], NPR: [void 0, "Rs"], NZD: ["NZ$", "$"], OMR: [void 0, void 0, 3], PHP: [void 0, "\u20b1"], PKR: [void 0, "Rs", 2], PLN: [void 0, "z\u0142"], PYG: [void 0, "\u20b2", 0], RON: [void 0, "lei"], RSD: [void 0, void 0, 0], RUB: [void 0, "\u20bd"], RUR: [void 0, "\u0440."], RWF: [void 0, "RF", 0], SBD: [void 0, "$"], SEK: [void 0, "kr", 2], SGD: [void 0, "$"], SHP: [void 0, "\xa3"], SLL: [void 0, void 0, 0], SOS: [void 0, void 0, 0], SRD: [void 0, "$"], SSP: [void 0, "\xa3"], STD: [void 0, void 0, 0], STN: [void 0, "Db"], SYP: [void 0, "\xa3", 0], THB: [void 0, "\u0e3f"], TMM: [void 0, void 0, 0], TND: [void 0, void 0, 3], TOP: [void 0, "T$"], TRL: [void 0, void 0, 0], TRY: [void 0, "\u20ba"], TTD: [void 0, "$"], TWD: ["NT$", "$", 2], TZS: [void 0, void 0, 2], UAH: [void 0, "\u20b4"], UGX: [void 0, void 0, 0], USD: ["$"], UYI: [void 0, void 0, 0], UYU: [void 0, "$"], UYW: [void 0, void 0, 4], UZS: [void 0, void 0, 2], VEF: [void 0, "Bs", 2], VND: ["\u20ab", void 0, 0], VUV: [void 0, void 0, 0], XAF: ["FCFA", void 0, 0], XCD: ["EC$", "$"], XOF: ["CFA", void 0, 0], XPF: ["CFPF", void 0, 0], XXX: ["\xa4"], YER: [void 0, void 0, 0], ZAR: [void 0, "R"], ZMK: [void 0, void 0, 0], ZMW: [void 0, "ZK"], ZWD: [void 0, void 0, 0] },
                    Oh = function() { var t = { Decimal: 0, Percent: 1, Currency: 2, Scientific: 3 }; return t[t.Decimal] = "Decimal", t[t.Percent] = "Percent", t[t.Currency] = "Currency", t[t.Scientific] = "Scientific", t }(),
                    Rh = function() { var t = { Zero: 0, One: 1, Two: 2, Few: 3, Many: 4, Other: 5 }; return t[t.Zero] = "Zero", t[t.One] = "One", t[t.Two] = "Two", t[t.Few] = "Few", t[t.Many] = "Many", t[t.Other] = "Other", t }(),
                    Mh = function() { var t = { Format: 0, Standalone: 1 }; return t[t.Format] = "Format", t[t.Standalone] = "Standalone", t }(),
                    Ph = function() { var t = { Narrow: 0, Abbreviated: 1, Wide: 2, Short: 3 }; return t[t.Narrow] = "Narrow", t[t.Abbreviated] = "Abbreviated", t[t.Wide] = "Wide", t[t.Short] = "Short", t }(),
                    Fh = function() { var t = { Short: 0, Medium: 1, Long: 2, Full: 3 }; return t[t.Short] = "Short", t[t.Medium] = "Medium", t[t.Long] = "Long", t[t.Full] = "Full", t }(),
                    Nh = function() { var t = { Decimal: 0, Group: 1, List: 2, PercentSign: 3, PlusSign: 4, MinusSign: 5, Exponential: 6, SuperscriptingExponent: 7, PerMille: 8, Infinity: 9, NaN: 10, TimeSeparator: 11, CurrencyDecimal: 12, CurrencyGroup: 13 }; return t[t.Decimal] = "Decimal", t[t.Group] = "Group", t[t.List] = "List", t[t.PercentSign] = "PercentSign", t[t.PlusSign] = "PlusSign", t[t.MinusSign] = "MinusSign", t[t.Exponential] = "Exponential", t[t.SuperscriptingExponent] = "SuperscriptingExponent", t[t.PerMille] = "PerMille", t[t.Infinity] = "Infinity", t[t.NaN] = "NaN", t[t.TimeSeparator] = "TimeSeparator", t[t.CurrencyDecimal] = "CurrencyDecimal", t[t.CurrencyGroup] = "CurrencyGroup", t }();

                function Lh(t, e) { return jh(Il(t)[Ol.DateFormat], e) }

                function Bh(t, e) { return jh(Il(t)[Ol.TimeFormat], e) }

                function Vh(t, e) { return jh(Il(t)[Ol.DateTimeFormat], e) }

                function zh(t, e) { const i = Il(t),
                        n = i[Ol.NumberSymbols][e]; if (void 0 === n) { if (e === Nh.CurrencyDecimal) return i[Ol.NumberSymbols][Nh.Decimal]; if (e === Nh.CurrencyGroup) return i[Ol.NumberSymbols][Nh.Group] } return n }

                function Uh(t, e) { return Il(t)[Ol.NumberFormats][e] }

                function Hh(t) { if (!t[Ol.ExtraData]) throw new Error(`Missing extra locale data for the locale "${t[Ol.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`) }

                function jh(t, e) { for (let i = e; i > -1; i--)
                        if (void 0 !== t[i]) return t[i]; throw new Error("Locale data API: locale data undefined") }

                function Gh(t) { const [e, i] = t.split(":"); return { hours: +e, minutes: +i } } const $h = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/,
                    Wh = {},
                    qh = /((?:[^GyMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/,
                    Yh = function() { var t = { Short: 0, ShortGMT: 1, Long: 2, Extended: 3 }; return t[t.Short] = "Short", t[t.ShortGMT] = "ShortGMT", t[t.Long] = "Long", t[t.Extended] = "Extended", t }(),
                    Xh = function() { var t = { FullYear: 0, Month: 1, Date: 2, Hours: 3, Minutes: 4, Seconds: 5, FractionalSeconds: 6, Day: 7 }; return t[t.FullYear] = "FullYear", t[t.Month] = "Month", t[t.Date] = "Date", t[t.Hours] = "Hours", t[t.Minutes] = "Minutes", t[t.Seconds] = "Seconds", t[t.FractionalSeconds] = "FractionalSeconds", t[t.Day] = "Day", t }(),
                    Kh = function() { var t = { DayPeriods: 0, Days: 1, Months: 2, Eras: 3 }; return t[t.DayPeriods] = "DayPeriods", t[t.Days] = "Days", t[t.Months] = "Months", t[t.Eras] = "Eras", t }();

                function Zh(t, e) { return e && (t = t.replace(/\{([^}]+)}/g, (function(t, i) { return null != e && i in e ? e[i] : t }))), t }

                function Qh(t, e, i = "-", n, s) { let r = "";
                    (t < 0 || s && t <= 0) && (s ? t = 1 - t : (t = -t, r = i)); let a = String(t); for (; a.length < e;) a = "0" + a; return n && (a = a.substr(a.length - e)), r + a }

                function Jh(t, e, i = 0, n = !1, s = !1) { return function(r, a) { let o = function(t, e) { switch (t) {
                                case Xh.FullYear:
                                    return e.getFullYear();
                                case Xh.Month:
                                    return e.getMonth();
                                case Xh.Date:
                                    return e.getDate();
                                case Xh.Hours:
                                    return e.getHours();
                                case Xh.Minutes:
                                    return e.getMinutes();
                                case Xh.Seconds:
                                    return e.getSeconds();
                                case Xh.FractionalSeconds:
                                    return e.getMilliseconds();
                                case Xh.Day:
                                    return e.getDay();
                                default:
                                    throw new Error(`Unknown DateType value "${t}".`) } }(t, r); if ((i > 0 || o > -i) && (o += i), t === Xh.Hours) 0 === o && -12 === i && (o = 12);
                        else if (t === Xh.FractionalSeconds) return l = e, Qh(o, 3).substr(0, l); var l; const c = zh(a, Nh.MinusSign); return Qh(o, e, c, n, s) } }

                function td(t, e, i = Mh.Format, n = !1) { return function(s, r) { return function(t, e, i, n, s, r) { switch (i) {
                                case Kh.Months:
                                    return function(t, e, i) { const n = Il(t),
                                            s = jh([n[Ol.MonthsFormat], n[Ol.MonthsStandalone]], e); return jh(s, i) }(e, s, n)[t.getMonth()];
                                case Kh.Days:
                                    return function(t, e, i) { const n = Il(t),
                                            s = jh([n[Ol.DaysFormat], n[Ol.DaysStandalone]], e); return jh(s, i) }(e, s, n)[t.getDay()];
                                case Kh.DayPeriods:
                                    const a = t.getHours(),
                                        o = t.getMinutes(); if (r) { const t = function(t) { const e = Il(t); return Hh(e), (e[Ol.ExtraData][2] || []).map(t => "string" == typeof t ? Gh(t) : [Gh(t[0]), Gh(t[1])]) }(e),
                                            i = function(t, e, i) { const n = Il(t);
                                                Hh(n); const s = jh([n[Ol.ExtraData][0], n[Ol.ExtraData][1]], e) || []; return jh(s, i) || [] }(e, s, n); let r; if (t.forEach((t, e) => { if (Array.isArray(t)) { const { hours: n, minutes: s } = t[0], { hours: l, minutes: c } = t[1];
                                                    a >= n && o >= s && (a < l || a === l && o < c) && (r = i[e]) } else { const { hours: n, minutes: s } = t;
                                                    n === a && s === o && (r = i[e]) } }), r) return r } return function(t, e, i) { const n = Il(t),
                                            s = jh([n[Ol.DayPeriodsFormat], n[Ol.DayPeriodsStandalone]], e); return jh(s, i) }(e, s, n)[a < 12 ? 0 : 1];
                                case Kh.Eras:
                                    return function(t, e) { return jh(Il(t)[Ol.Eras], e) }(e, n)[t.getFullYear() <= 0 ? 0 : 1];
                                default:
                                    throw new Error(`unexpected translation type ${i}`) } }(s, r, t, e, i, n) } }

                function ed(t) { return function(e, i, n) { const s = -1 * n,
                            r = zh(i, Nh.MinusSign),
                            a = s > 0 ? Math.floor(s / 60) : Math.ceil(s / 60); switch (t) {
                            case Yh.Short:
                                return (s >= 0 ? "+" : "") + Qh(a, 2, r) + Qh(Math.abs(s % 60), 2, r);
                            case Yh.ShortGMT:
                                return "GMT" + (s >= 0 ? "+" : "") + Qh(a, 1, r);
                            case Yh.Long:
                                return "GMT" + (s >= 0 ? "+" : "") + Qh(a, 2, r) + ":" + Qh(Math.abs(s % 60), 2, r);
                            case Yh.Extended:
                                return 0 === n ? "Z" : (s >= 0 ? "+" : "") + Qh(a, 2, r) + ":" + Qh(Math.abs(s % 60), 2, r);
                            default:
                                throw new Error(`Unknown zone width "${t}"`) } } }

                function id(t, e = !1) { return function(i, n) { let s; if (e) { const t = new Date(i.getFullYear(), i.getMonth(), 1).getDay() - 1,
                                e = i.getDate();
                            s = 1 + Math.floor((e + t) / 7) } else { const t = function(t) { const e = new Date(t, 0, 1).getDay(); return new Date(t, 0, 1 + (e <= 4 ? 4 : 11) - e) }(i.getFullYear()),
                                e = (r = i, new Date(r.getFullYear(), r.getMonth(), r.getDate() + (4 - r.getDay()))).getTime() - t.getTime();
                            s = 1 + Math.round(e / 6048e5) } var r; return Qh(s, t, zh(n, Nh.MinusSign)) } } const nd = {};

                function sd(t, e) { t = t.replace(/:/g, ""); const i = Date.parse("Jan 01, 1970 00:00:00 " + t) / 6e4; return isNaN(i) ? e : i }

                function rd(t) { return t instanceof Date && !isNaN(t.valueOf()) } const ad = /^(\d+)?\.((\d+)(-(\d+))?)?$/;

                function od(t, e, i, n, s, r, a = !1) { let o = "",
                        l = !1; if (isFinite(t)) { let c = function(t) { let e, i, n, s, r, a = Math.abs(t) + "",
                                o = 0; for ((i = a.indexOf(".")) > -1 && (a = a.replace(".", "")), (n = a.search(/e/i)) > 0 ? (i < 0 && (i = n), i += +a.slice(n + 1), a = a.substring(0, n)) : i < 0 && (i = a.length), n = 0;
                                "0" === a.charAt(n); n++); if (n === (r = a.length)) e = [0], i = 1;
                            else { for (r--;
                                    "0" === a.charAt(r);) r--; for (i -= n, e = [], s = 0; n <= r; n++, s++) e[s] = Number(a.charAt(n)) } return i > 22 && (e = e.splice(0, 21), o = i - 1, i = 1), { digits: e, exponent: o, integerLen: i } }(t);
                        a && (c = function(t) { if (0 === t.digits[0]) return t; const e = t.digits.length - t.integerLen; return t.exponent ? t.exponent += 2 : (0 === e ? t.digits.push(0, 0) : 1 === e && t.digits.push(0), t.integerLen += 2), t }(c)); let h = e.minInt,
                            d = e.minFrac,
                            u = e.maxFrac; if (r) { const t = r.match(ad); if (null === t) throw new Error(`${r} is not a valid digit info`); const e = t[1],
                                i = t[3],
                                n = t[5];
                            null != e && (h = cd(e)), null != i && (d = cd(i)), null != n ? u = cd(n) : null != i && d > u && (u = d) }! function(t, e, i) { if (e > i) throw new Error(`The minimum number of digits after fraction (${e}) is higher than the maximum (${i}).`); let n = t.digits,
                                s = n.length - t.integerLen; const r = Math.min(Math.max(e, s), i); let a = r + t.integerLen,
                                o = n[a]; if (a > 0) { n.splice(Math.max(t.integerLen, a)); for (let t = a; t < n.length; t++) n[t] = 0 } else { s = Math.max(0, s), t.integerLen = 1, n.length = Math.max(1, a = r + 1), n[0] = 0; for (let t = 1; t < a; t++) n[t] = 0 } if (o >= 5)
                                if (a - 1 < 0) { for (let e = 0; e > a; e--) n.unshift(0), t.integerLen++;
                                    n.unshift(1), t.integerLen++ } else n[a - 1]++; for (; s < Math.max(0, r); s++) n.push(0); let l = 0 !== r; const c = e + t.integerLen,
                                h = n.reduceRight((function(t, e, i, n) { return n[i] = (e += t) < 10 ? e : e - 10, l && (0 === n[i] && i >= c ? n.pop() : l = !1), e >= 10 ? 1 : 0 }), 0);
                            h && (n.unshift(h), t.integerLen++) }(c, d, u); let m = c.digits,
                            p = c.integerLen; const f = c.exponent; let g = []; for (l = m.every(t => !t); p < h; p++) m.unshift(0); for (; p < 0; p++) m.unshift(0);
                        p > 0 ? g = m.splice(p, m.length) : (g = m, m = [0]); const _ = []; for (m.length >= e.lgSize && _.unshift(m.splice(-e.lgSize, m.length).join("")); m.length > e.gSize;) _.unshift(m.splice(-e.gSize, m.length).join(""));
                        m.length && _.unshift(m.join("")), o = _.join(zh(i, n)), g.length && (o += zh(i, s) + g.join("")), f && (o += zh(i, Nh.Exponential) + "+" + f) } else o = zh(i, Nh.Infinity); return o = t < 0 && !l ? e.negPre + o + e.negSuf : e.posPre + o + e.posSuf, o }

                function ld(t, e = "-") { const i = { minInt: 1, minFrac: 0, maxFrac: 0, posPre: "", posSuf: "", negPre: "", negSuf: "", gSize: 0, lgSize: 0 },
                        n = t.split(";"),
                        s = n[0],
                        r = n[1],
                        a = -1 !== s.indexOf(".") ? s.split(".") : [s.substring(0, s.lastIndexOf("0") + 1), s.substring(s.lastIndexOf("0") + 1)],
                        o = a[0],
                        l = a[1] || "";
                    i.posPre = o.substr(0, o.indexOf("#")); for (let h = 0; h < l.length; h++) { const t = l.charAt(h); "0" === t ? i.minFrac = i.maxFrac = h + 1 : "#" === t ? i.maxFrac = h + 1 : i.posSuf += t } const c = o.split(","); if (i.gSize = c[1] ? c[1].length : 0, i.lgSize = c[2] || c[1] ? (c[2] || c[1]).length : 0, r) { const t = s.length - i.posPre.length - i.posSuf.length,
                            e = r.indexOf("#");
                        i.negPre = r.substr(0, e).replace(/'/g, ""), i.negSuf = r.substr(e + t).replace(/'/g, "") } else i.negPre = e + i.posPre, i.negSuf = i.posSuf; return i }

                function cd(t) { const e = parseInt(t); if (isNaN(e)) throw new Error("Invalid integer literal when parsing " + t); return e } class hd {}

                function dd(t, e, i, n) { let s = `=${t}`; if (e.indexOf(s) > -1) return s; if (s = i.getPluralCategory(t, n), e.indexOf(s) > -1) return s; if (e.indexOf("other") > -1) return "other"; throw new Error(`No plural message found for value "${t}"`) } let ud = (() => { class t extends hd { constructor(t) { super(), this.locale = t } getPluralCategory(t, e) { switch (function(t) { return Il(t)[Ol.PluralCase] }(e || this.locale)(t)) {
                                case Rh.Zero:
                                    return "zero";
                                case Rh.One:
                                    return "one";
                                case Rh.Two:
                                    return "two";
                                case Rh.Few:
                                    return "few";
                                case Rh.Many:
                                    return "many";
                                default:
                                    return "other" } } } return t.\u0275fac = function(e) { return new(e || t)(Xt(wc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();

                function md(t, e) { e = encodeURIComponent(e); for (const i of t.split(";")) { const t = i.indexOf("="),
                            [n, s] = -1 == t ? [i, ""] : [i.slice(0, t), i.slice(t + 1)]; if (n.trim() === e) return decodeURIComponent(s) } return null } let pd = (() => { class t { constructor(t, e, i, n) { this._iterableDiffers = t, this._keyValueDiffers = e, this._ngEl = i, this._renderer = n, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(t) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof t ? t.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(t) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof t ? t.split(/\s+/) : t, this._rawClass && (fa(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const t = this._iterableDiffer.diff(this._rawClass);
                                    t && this._applyIterableChanges(t) } else if (this._keyValueDiffer) { const t = this._keyValueDiffer.diff(this._rawClass);
                                    t && this._applyKeyValueChanges(t) } } _applyKeyValueChanges(t) { t.forEachAddedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachChangedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachRemovedItem(t => { t.previousValue && this._toggleClass(t.key, !1) }) } _applyIterableChanges(t) { t.forEachAddedItem(t => { if ("string" != typeof t.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${wt(t.item)}`);
                                    this._toggleClass(t.item, !0) }), t.forEachRemovedItem(t => this._toggleClass(t.item, !1)) } _applyClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !0)) : Object.keys(t).forEach(e => this._toggleClass(e, !!t[e]))) } _removeClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !1)) : Object.keys(t).forEach(t => this._toggleClass(t, !1))) } _toggleClass(t, e) {
                                (t = t.trim()) && t.split(/\s+/g).forEach(t => { e ? this._renderer.addClass(this._ngEl.nativeElement, t) : this._renderer.removeClass(this._ngEl.nativeElement, t) }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(dl), Sa(ul), Sa(Wo), Sa(Ko)) }, t.\u0275dir = we({ type: t, selectors: [
                                ["", "ngClass", ""]
                            ], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), t })(),
                    fd = (() => { class t { constructor(t) { this._viewContainerRef = t, this._componentRef = null, this._moduleRef = null } ngOnChanges(t) { if (this._viewContainerRef.clear(), this._componentRef = null, this.ngComponentOutlet) { const e = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector; if (t.ngComponentOutletNgModuleFactory)
                                        if (this._moduleRef && this._moduleRef.destroy(), this.ngComponentOutletNgModuleFactory) { const t = e.get(te);
                                            this._moduleRef = this.ngComponentOutletNgModuleFactory.create(t.injector) } else this._moduleRef = null; const i = (this._moduleRef ? this._moduleRef.componentFactoryResolver : e.get($o)).resolveComponentFactory(this.ngComponentOutlet);
                                    this._componentRef = this._viewContainerRef.createComponent(i, this._viewContainerRef.length, e, this.ngComponentOutletContent) } } ngOnDestroy() { this._moduleRef && this._moduleRef.destroy() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl)) }, t.\u0275dir = we({ type: t, selectors: [
                                ["", "ngComponentOutlet", ""]
                            ], inputs: { ngComponentOutlet: "ngComponentOutlet", ngComponentOutletInjector: "ngComponentOutletInjector", ngComponentOutletContent: "ngComponentOutletContent", ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory" }, features: [Ro] }), t })();
                class gd { constructor(t, e, i, n) { this.$implicit = t, this.ngForOf = e, this.index = i, this.count = n } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let _d = (() => { class t { constructor(t, e, i) { this._viewContainer = t, this._template = e, this._differs = i, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { Sn() && null != t && "function" != typeof t && console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(t)}. ` + "See https://angular.io/api/common/NgForOf#change-propagation for more information."), this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const i = this._ngForOf; if (!this._differ && i) try { this._differ = this._differs.find(i).create(this.ngForTrackBy) } catch (e) { throw new Error(`Cannot find a differ supporting object '${i}' of type '${t=i,t.name||typeof t}'. NgFor only supports binding to Iterables such as Arrays.`) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf);
                                t && this._applyChanges(t) } } _applyChanges(t) { const e = [];
                            t.forEachOperation((t, i, n) => { if (null == t.previousIndex) { const i = this._viewContainer.createEmbeddedView(this._template, new gd(null, this._ngForOf, -1, -1), null === n ? void 0 : n),
                                        s = new bd(t, i);
                                    e.push(s) } else if (null == n) this._viewContainer.remove(null === i ? void 0 : i);
                                else if (null !== i) { const s = this._viewContainer.get(i);
                                    this._viewContainer.move(s, n); const r = new bd(t, s);
                                    e.push(r) } }); for (let i = 0; i < e.length; i++) this._perViewChange(e[i].view, e[i].record); for (let i = 0, n = this._viewContainer.length; i < n; i++) { const t = this._viewContainer.get(i);
                                t.context.index = i, t.context.count = n, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl), Sa(gl), Sa(dl)) }, t.\u0275dir = we({ type: t, selectors: [
                            ["", "ngFor", "", "ngForOf", ""]
                        ], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })();
                class bd { constructor(t, e) { this.record = t, this.view = e } } let yd = (() => { class t { constructor(t, e) { this._viewContainer = t, this._context = new vd, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { wd("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { wd("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl), Sa(gl)) }, t.\u0275dir = we({ type: t, selectors: [
                            ["", "ngIf", ""]
                        ], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })();
                class vd { constructor() { this.$implicit = null, this.ngIf = null } }

                function wd(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${wt(e)}'.`) } class Cd { constructor(t, e) { this._viewContainerRef = t, this._templateRef = e, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(t) { t && !this._created ? this.create() : !t && this._created && this.destroy() } } let xd = (() => { class t { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(t) { this._ngSwitch = t, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(t) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(t) } _matchCase(t) { const e = t == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || e, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), e } _updateDefaultCases(t) { if (this._defaultViews && t !== this._defaultUsed) { this._defaultUsed = t; for (let e = 0; e < this._defaultViews.length; e++) this._defaultViews[e].enforceState(t) } } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                                ["", "ngSwitch", ""]
                            ], inputs: { ngSwitch: "ngSwitch" } }), t })(),
                    Sd = (() => { class t { constructor(t, e, i) { this.ngSwitch = i, i._addCase(), this._view = new Cd(t, e) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl), Sa(gl), Sa(xd, 1)) }, t.\u0275dir = we({ type: t, selectors: [
                                ["", "ngSwitchCase", ""]
                            ], inputs: { ngSwitchCase: "ngSwitchCase" } }), t })(),
                    kd = (() => { class t { constructor(t, e, i) { i._addDefault(new Cd(t, e)) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl), Sa(gl), Sa(xd, 1)) }, t.\u0275dir = we({ type: t, selectors: [
                                ["", "ngSwitchDefault", ""]
                            ] }), t })(),
                    Ed = (() => { class t { constructor(t) { this._localization = t, this._caseViews = {} } set ngPlural(t) { this._switchValue = t, this._updateView() } addCase(t, e) { this._caseViews[t] = e } _updateView() { this._clearViews(); const t = Object.keys(this._caseViews),
                                    e = dd(this._switchValue, t, this._localization);
                                this._activateView(this._caseViews[e]) } _clearViews() { this._activeView && this._activeView.destroy() } _activateView(t) { t && (this._activeView = t, this._activeView.create()) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(hd)) }, t.\u0275dir = we({ type: t, selectors: [
                                ["", "ngPlural", ""]
                            ], inputs: { ngPlural: "ngPlural" } }), t })(),
                    Dd = (() => { class t { constructor(t, e, i, n) { this.value = t; const s = !isNaN(Number(t));
                                n.addCase(s ? `=${t}` : t, new Cd(i, e)) } } return t.\u0275fac = function(e) { return new(e || t)(ka("ngPluralCase"), Sa(gl), Sa(bl), Sa(Ed, 1)) }, t.\u0275dir = we({ type: t, selectors: [
                                ["", "ngPluralCase", ""]
                            ] }), t })(),
                    Ad = (() => { class t { constructor(t, e, i) { this._ngEl = t, this._differs = e, this._renderer = i, this._ngStyle = null, this._differ = null } set ngStyle(t) { this._ngStyle = t, !this._differ && t && (this._differ = this._differs.find(t).create()) } ngDoCheck() { if (this._differ) { const t = this._differ.diff(this._ngStyle);
                                    t && this._applyChanges(t) } } _setStyle(t, e) { const [i, n] = t.split(".");
                                null != (e = null != e && n ? `${e}${n}` : e) ? this._renderer.setStyle(this._ngEl.nativeElement, i, e) : this._renderer.removeStyle(this._ngEl.nativeElement, i) } _applyChanges(t) { t.forEachRemovedItem(t => this._setStyle(t.key, null)), t.forEachAddedItem(t => this._setStyle(t.key, t.currentValue)), t.forEachChangedItem(t => this._setStyle(t.key, t.currentValue)) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(ul), Sa(Ko)) }, t.\u0275dir = we({ type: t, selectors: [
                                ["", "ngStyle", ""]
                            ], inputs: { ngStyle: "ngStyle" } }), t })(),
                    Id = (() => { class t { constructor(t) { this._viewContainerRef = t, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null } ngOnChanges(t) { if (this._shouldRecreateView(t)) { const t = this._viewContainerRef;
                                    this._viewRef && t.remove(t.indexOf(this._viewRef)), this._viewRef = this.ngTemplateOutlet ? t.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext) : null } else this._viewRef && this.ngTemplateOutletContext && this._updateExistingContext(this.ngTemplateOutletContext) } _shouldRecreateView(t) { const e = t.ngTemplateOutletContext; return !!t.ngTemplateOutlet || e && this._hasContextShapeChanged(e) } _hasContextShapeChanged(t) { const e = Object.keys(t.previousValue || {}),
                                    i = Object.keys(t.currentValue || {}); if (e.length === i.length) { for (let t of i)
                                        if (-1 === e.indexOf(t)) return !0; return !1 } return !0 } _updateExistingContext(t) { for (let e of Object.keys(t)) this._viewRef.context[e] = this.ngTemplateOutletContext[e] } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl)) }, t.\u0275dir = we({ type: t, selectors: [
                                ["", "ngTemplateOutlet", ""]
                            ], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet" }, features: [Ro] }), t })();

                function Td(t, e) { return Error(`InvalidPipeArgument: '${e}' for pipe '${wt(t)}'`) } class Od { createSubscription(t, e) { return t.subscribe({ next: e, error: t => { throw t } }) } dispose(t) { t.unsubscribe() } onDestroy(t) { t.unsubscribe() } } class Rd { createSubscription(t, e) { return t.then(e, t => { throw t }) } dispose(t) {} onDestroy(t) {} } const Md = new Rd,
                    Pd = new Od; let Fd = (() => { class t { constructor(t) { this._ref = t, this._latestValue = null, this._latestReturnedValue = null, this._subscription = null, this._obj = null, this._strategy = null } ngOnDestroy() { this._subscription && this._dispose() } transform(t) { return this._obj ? t !== this._obj ? (this._dispose(), this.transform(t)) : ma(this._latestValue, this._latestReturnedValue) ? this._latestReturnedValue : (this._latestReturnedValue = this._latestValue, pa.wrap(this._latestValue)) : (t && this._subscribe(t), this._latestReturnedValue = this._latestValue, this._latestValue) } _subscribe(t) { this._obj = t, this._strategy = this._selectStrategy(t), this._subscription = this._strategy.createSubscription(t, e => this._updateLatestValue(t, e)) } _selectStrategy(e) { if (Na(e)) return Md; if (La(e)) return Pd; throw Td(t, e) } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._latestReturnedValue = null, this._subscription = null, this._obj = null } _updateLatestValue(t, e) { t === this._obj && (this._latestValue = e, this._ref.markForCheck()) } } return t.\u0275fac = function(e) { return new(e || t)(function(t = lt.Default) { const e = Hr(!0); if (null != e || t & lt.Optional) return e; throw new Error("No provider for ChangeDetectorRef!") }()) }, t.\u0275pipe = Ce({ name: "async", type: t, pure: !1 }), t })(),
                    Nd = (() => { class t { transform(e) { if (!e) return e; if ("string" != typeof e) throw Td(t, e); return e.toLowerCase() } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275pipe = Ce({ name: "lowercase", type: t, pure: !0 }), t })(); const Ld = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D])\S*/g; let Bd = (() => { class t { transform(e) { if (!e) return e; if ("string" != typeof e) throw Td(t, e); return e.replace(Ld, t => t[0].toUpperCase() + t.substr(1).toLowerCase()) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275pipe = Ce({ name: "titlecase", type: t, pure: !0 }), t })(),
                    Vd = (() => { class t { transform(e) { if (!e) return e; if ("string" != typeof e) throw Td(t, e); return e.toUpperCase() } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275pipe = Ce({ name: "uppercase", type: t, pure: !0 }), t })(),
                    zd = (() => { class t { constructor(t) { this.locale = t } transform(e, i = "mediumDate", n, s) { if (null == e || "" === e || e != e) return null; try { return function(t, e, i, n) { let s = function(t) { if (rd(t)) return t; if ("number" == typeof t && !isNaN(t)) return new Date(t); if ("string" == typeof t) { t = t.trim(); const e = parseFloat(t); if (!isNaN(t - e)) return new Date(e); if (/^(\d{4}-\d{1,2}-\d{1,2})$/.test(t)) { const [e, i, n] = t.split("-").map(t => +t); return new Date(e, i - 1, n) } let i; if (i = t.match($h)) return function(t) { const e = new Date(0); let i = 0,
                                                        n = 0; const s = t[8] ? e.setUTCFullYear : e.setFullYear,
                                                        r = t[8] ? e.setUTCHours : e.setHours;
                                                    t[9] && (i = Number(t[9] + t[10]), n = Number(t[9] + t[11])), s.call(e, Number(t[1]), Number(t[2]) - 1, Number(t[3])); const a = Number(t[4] || 0) - i,
                                                        o = Number(t[5] || 0) - n,
                                                        l = Number(t[6] || 0),
                                                        c = Math.round(1e3 * parseFloat("0." + (t[7] || 0))); return r.call(e, a, o, l, c), e }(i) } const e = new Date(t); if (!rd(e)) throw new Error(`Unable to convert "${t}" into a date`); return e }(t);
                                        e = function t(e, i) { const n = function(t) { return Il(t)[Ol.LocaleId] }(e); if (Wh[n] = Wh[n] || {}, Wh[n][i]) return Wh[n][i]; let s = ""; switch (i) {
                                                case "shortDate":
                                                    s = Lh(e, Fh.Short); break;
                                                case "mediumDate":
                                                    s = Lh(e, Fh.Medium); break;
                                                case "longDate":
                                                    s = Lh(e, Fh.Long); break;
                                                case "fullDate":
                                                    s = Lh(e, Fh.Full); break;
                                                case "shortTime":
                                                    s = Bh(e, Fh.Short); break;
                                                case "mediumTime":
                                                    s = Bh(e, Fh.Medium); break;
                                                case "longTime":
                                                    s = Bh(e, Fh.Long); break;
                                                case "fullTime":
                                                    s = Bh(e, Fh.Full); break;
                                                case "short":
                                                    const i = t(e, "shortTime"),
                                                        n = t(e, "shortDate");
                                                    s = Zh(Vh(e, Fh.Short), [i, n]); break;
                                                case "medium":
                                                    const r = t(e, "mediumTime"),
                                                        a = t(e, "mediumDate");
                                                    s = Zh(Vh(e, Fh.Medium), [r, a]); break;
                                                case "long":
                                                    const o = t(e, "longTime"),
                                                        l = t(e, "longDate");
                                                    s = Zh(Vh(e, Fh.Long), [o, l]); break;
                                                case "full":
                                                    const c = t(e, "fullTime"),
                                                        h = t(e, "fullDate");
                                                    s = Zh(Vh(e, Fh.Full), [c, h]) } return s && (Wh[n][i] = s), s }(i, e) || e; let r, a = []; for (; e;) { if (r = qh.exec(e), !r) { a.push(e); break } { a = a.concat(r.slice(1)); const t = a.pop(); if (!t) break;
                                                e = t } } let o = s.getTimezoneOffset();
                                        n && (o = sd(n, o), s = function(t, e, i) { const n = t.getTimezoneOffset(); return function(t, e) { return (t = new Date(t.getTime())).setMinutes(t.getMinutes() + e), t }(t, -1 * (sd(e, n) - n)) }(s, n)); let l = ""; return a.forEach(t => { const e = function(t) { if (nd[t]) return nd[t]; let e; switch (t) {
                                                    case "G":
                                                    case "GG":
                                                    case "GGG":
                                                        e = td(Kh.Eras, Ph.Abbreviated); break;
                                                    case "GGGG":
                                                        e = td(Kh.Eras, Ph.Wide); break;
                                                    case "GGGGG":
                                                        e = td(Kh.Eras, Ph.Narrow); break;
                                                    case "y":
                                                        e = Jh(Xh.FullYear, 1, 0, !1, !0); break;
                                                    case "yy":
                                                        e = Jh(Xh.FullYear, 2, 0, !0, !0); break;
                                                    case "yyy":
                                                        e = Jh(Xh.FullYear, 3, 0, !1, !0); break;
                                                    case "yyyy":
                                                        e = Jh(Xh.FullYear, 4, 0, !1, !0); break;
                                                    case "M":
                                                    case "L":
                                                        e = Jh(Xh.Month, 1, 1); break;
                                                    case "MM":
                                                    case "LL":
                                                        e = Jh(Xh.Month, 2, 1); break;
                                                    case "MMM":
                                                        e = td(Kh.Months, Ph.Abbreviated); break;
                                                    case "MMMM":
                                                        e = td(Kh.Months, Ph.Wide); break;
                                                    case "MMMMM":
                                                        e = td(Kh.Months, Ph.Narrow); break;
                                                    case "LLL":
                                                        e = td(Kh.Months, Ph.Abbreviated, Mh.Standalone); break;
                                                    case "LLLL":
                                                        e = td(Kh.Months, Ph.Wide, Mh.Standalone); break;
                                                    case "LLLLL":
                                                        e = td(Kh.Months, Ph.Narrow, Mh.Standalone); break;
                                                    case "w":
                                                        e = id(1); break;
                                                    case "ww":
                                                        e = id(2); break;
                                                    case "W":
                                                        e = id(1, !0); break;
                                                    case "d":
                                                        e = Jh(Xh.Date, 1); break;
                                                    case "dd":
                                                        e = Jh(Xh.Date, 2); break;
                                                    case "E":
                                                    case "EE":
                                                    case "EEE":
                                                        e = td(Kh.Days, Ph.Abbreviated); break;
                                                    case "EEEE":
                                                        e = td(Kh.Days, Ph.Wide); break;
                                                    case "EEEEE":
                                                        e = td(Kh.Days, Ph.Narrow); break;
                                                    case "EEEEEE":
                                                        e = td(Kh.Days, Ph.Short); break;
                                                    case "a":
                                                    case "aa":
                                                    case "aaa":
                                                        e = td(Kh.DayPeriods, Ph.Abbreviated); break;
                                                    case "aaaa":
                                                        e = td(Kh.DayPeriods, Ph.Wide); break;
                                                    case "aaaaa":
                                                        e = td(Kh.DayPeriods, Ph.Narrow); break;
                                                    case "b":
                                                    case "bb":
                                                    case "bbb":
                                                        e = td(Kh.DayPeriods, Ph.Abbreviated, Mh.Standalone, !0); break;
                                                    case "bbbb":
                                                        e = td(Kh.DayPeriods, Ph.Wide, Mh.Standalone, !0); break;
                                                    case "bbbbb":
                                                        e = td(Kh.DayPeriods, Ph.Narrow, Mh.Standalone, !0); break;
                                                    case "B":
                                                    case "BB":
                                                    case "BBB":
                                                        e = td(Kh.DayPeriods, Ph.Abbreviated, Mh.Format, !0); break;
                                                    case "BBBB":
                                                        e = td(Kh.DayPeriods, Ph.Wide, Mh.Format, !0); break;
                                                    case "BBBBB":
                                                        e = td(Kh.DayPeriods, Ph.Narrow, Mh.Format, !0); break;
                                                    case "h":
                                                        e = Jh(Xh.Hours, 1, -12); break;
                                                    case "hh":
                                                        e = Jh(Xh.Hours, 2, -12); break;
                                                    case "H":
                                                        e = Jh(Xh.Hours, 1); break;
                                                    case "HH":
                                                        e = Jh(Xh.Hours, 2); break;
                                                    case "m":
                                                        e = Jh(Xh.Minutes, 1); break;
                                                    case "mm":
                                                        e = Jh(Xh.Minutes, 2); break;
                                                    case "s":
                                                        e = Jh(Xh.Seconds, 1); break;
                                                    case "ss":
                                                        e = Jh(Xh.Seconds, 2); break;
                                                    case "S":
                                                        e = Jh(Xh.FractionalSeconds, 1); break;
                                                    case "SS":
                                                        e = Jh(Xh.FractionalSeconds, 2); break;
                                                    case "SSS":
                                                        e = Jh(Xh.FractionalSeconds, 3); break;
                                                    case "Z":
                                                    case "ZZ":
                                                    case "ZZZ":
                                                        e = ed(Yh.Short); break;
                                                    case "ZZZZZ":
                                                        e = ed(Yh.Extended); break;
                                                    case "O":
                                                    case "OO":
                                                    case "OOO":
                                                    case "z":
                                                    case "zz":
                                                    case "zzz":
                                                        e = ed(Yh.ShortGMT); break;
                                                    case "OOOO":
                                                    case "ZZZZ":
                                                    case "zzzz":
                                                        e = ed(Yh.Long); break;
                                                    default:
                                                        return null } return nd[t] = e, e }(t);
                                            l += e ? e(s, i, o) : "''" === t ? "'" : t.replace(/(^'|'$)/g, "").replace(/''/g, "'") }), l }(e, i, s || this.locale, n) } catch (r) { throw Td(t, r.message) } } } return t.\u0275fac = function(e) { return new(e || t)(Sa(wc)) }, t.\u0275pipe = Ce({ name: "date", type: t, pure: !0 }), t })(); const Ud = /#/g; let Hd = (() => { class t { constructor(t) { this._localization = t } transform(e, i, n) { if (null == e) return ""; if ("object" != typeof i || null === i) throw Td(t, i); return i[dd(e, Object.keys(i), this._localization, n)].replace(Ud, e.toString()) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(hd)) }, t.\u0275pipe = Ce({ name: "i18nPlural", type: t, pure: !0 }), t })(),
                    jd = (() => { class t { transform(e, i) { if (null == e) return ""; if ("object" != typeof i || "string" != typeof e) throw Td(t, i); return i.hasOwnProperty(e) ? i[e] : i.hasOwnProperty("other") ? i.other : "" } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275pipe = Ce({ name: "i18nSelect", type: t, pure: !0 }), t })(),
                    Gd = (() => { class t { transform(t) { return JSON.stringify(t, null, 2) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275pipe = Ce({ name: "json", type: t, pure: !1 }), t })(),
                    $d = (() => { class t { constructor(t) { this.differs = t, this.keyValues = [] } transform(t, e = Wd) { if (!t || !(t instanceof Map) && "object" != typeof t) return null;
                                this.differ || (this.differ = this.differs.find(t).create()); const i = this.differ.diff(t); return i && (this.keyValues = [], i.forEachItem(t => { this.keyValues.push({ key: t.key, value: t.currentValue }) }), this.keyValues.sort(e)), this.keyValues } } return t.\u0275fac = function(e) { return new(e || t)(Sa(ul)) }, t.\u0275pipe = Ce({ name: "keyvalue", type: t, pure: !1 }), t })();

                function Wd(t, e) { const i = t.key,
                        n = e.key; if (i === n) return 0; if (void 0 === i) return 1; if (void 0 === n) return -1; if (null === i) return 1; if (null === n) return -1; if ("string" == typeof i && "string" == typeof n) return i < n ? -1 : 1; if ("number" == typeof i && "number" == typeof n) return i - n; if ("boolean" == typeof i && "boolean" == typeof n) return i < n ? -1 : 1; const s = String(i),
                        r = String(n); return s == r ? 0 : s < r ? -1 : 1 } let qd = (() => { class t { constructor(t) { this._locale = t } transform(e, i, n) { if (Kd(e)) return null;
                                n = n || this._locale; try { return function(t, e, i) { return od(t, ld(Uh(e, Oh.Decimal), zh(e, Nh.MinusSign)), e, Nh.Group, Nh.Decimal, i) }(Zd(e), n, i) } catch (s) { throw Td(t, s.message) } } } return t.\u0275fac = function(e) { return new(e || t)(Sa(wc)) }, t.\u0275pipe = Ce({ name: "number", type: t, pure: !0 }), t })(),
                    Yd = (() => { class t { constructor(t) { this._locale = t } transform(e, i, n) { if (Kd(e)) return null;
                                n = n || this._locale; try { return function(t, e, i) { return od(t, ld(Uh(e, Oh.Percent), zh(e, Nh.MinusSign)), e, Nh.Group, Nh.Decimal, i, !0).replace(new RegExp("%", "g"), zh(e, Nh.PercentSign)) }(Zd(e), n, i) } catch (s) { throw Td(t, s.message) } } } return t.\u0275fac = function(e) { return new(e || t)(Sa(wc)) }, t.\u0275pipe = Ce({ name: "percent", type: t, pure: !0 }), t })(),
                    Xd = (() => { class t { constructor(t, e = "USD") { this._locale = t, this._defaultCurrencyCode = e } transform(e, i, n = "symbol", s, r) { if (Kd(e)) return null;
                                r = r || this._locale, "boolean" == typeof n && (console && console.warn && console.warn('Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".'), n = n ? "symbol" : "code"); let a = i || this._defaultCurrencyCode; "code" !== n && (a = "symbol" === n || "symbol-narrow" === n ? function(t, e, i = "en") { const n = function(t) { return Il(t)[Ol.Currencies] }(i)[t] || Th[t] || [],
                                        s = n[1]; return "narrow" === e && "string" == typeof s ? s : n[0] || t }(a, "symbol" === n ? "wide" : "narrow", r) : n); try { return function(t, e, i, n, s) { const r = ld(Uh(e, Oh.Currency), zh(e, Nh.MinusSign)); return r.minFrac = function(t) { let e; const i = Th[t]; return i && (e = i[2]), "number" == typeof e ? e : 2 }(n), r.maxFrac = r.minFrac, od(t, r, e, Nh.CurrencyGroup, Nh.CurrencyDecimal, s).replace("\xa4", i).replace("\xa4", "").trim() }(Zd(e), r, a, i, s) } catch (o) { throw Td(t, o.message) } } } return t.\u0275fac = function(e) { return new(e || t)(Sa(wc), Sa(Cc)) }, t.\u0275pipe = Ce({ name: "currency", type: t, pure: !0 }), t })();

                function Kd(t) { return null == t || "" === t || t != t }

                function Zd(t) { if ("string" == typeof t && !isNaN(Number(t) - parseFloat(t))) return Number(t); if ("number" != typeof t) throw new Error(`${t} is not a number`); return t } let Qd = (() => { class t { transform(e, i, n) { if (null == e) return e; if (!this.supports(e)) throw Td(t, e); return e.slice(i, n) } supports(t) { return "string" == typeof t || Array.isArray(t) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275pipe = Ce({ name: "slice", type: t, pure: !1 }), t })(),
                    Jd = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [{ provide: hd, useClass: ud }] }), t })();

                function tu(t) { return "browser" === t } let eu = (() => { class t {} return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => new iu(Xt(uh), window, Xt(un)) }), t })();
                class iu { constructor(t, e, i) { this.document = t, this.window = e, this.errorHandler = i, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportScrollRestoration() ? [this.window.scrollX, this.window.scrollY] : [0, 0] } scrollToPosition(t) { this.supportScrollRestoration() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (this.supportScrollRestoration()) { t = this.window.CSS && this.window.CSS.escape ? this.window.CSS.escape(t) : t.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g, "\\$1"); try { const e = this.document.querySelector(`#${t}`); if (e) return void this.scrollToElement(e); const i = this.document.querySelector(`[name='${t}']`); if (i) return void this.scrollToElement(i) } catch (e) { this.errorHandler.handleError(e) } } } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history;
                            e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(),
                            i = e.left + this.window.pageXOffset,
                            n = e.top + this.window.pageYOffset,
                            s = this.offset();
                        this.window.scrollTo(i - s[0], n - s[1]) } supportScrollRestoration() { try { return !!this.window && !!this.window.scrollTo } catch (t) { return !1 } } } class nu extends class extends class {} { constructor() { super() } supportsDOMEvents() { return !0 } } { static makeCurrent() { var t;
                        t = new nu, hh || (hh = t) } getProperty(t, e) { return t[e] } log(t) { window.console && window.console.log && window.console.log(t) } logGroup(t) { window.console && window.console.group && window.console.group(t) } logGroupEnd() { window.console && window.console.groupEnd && window.console.groupEnd() } onAndCancel(t, e, i) { return t.addEventListener(e, i, !1), () => { t.removeEventListener(e, i, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { return t.parentNode && t.parentNode.removeChild(t), t } getValue(t) { return t.value } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getHistory() { return window.history } getLocation() { return window.location } getBaseHref(t) { const e = ru || (ru = document.querySelector("base"), ru) ? ru.getAttribute("href") : null; return null == e ? null : (i = e, su || (su = document.createElement("a")), su.setAttribute("href", i), "/" === su.pathname.charAt(0) ? su.pathname : "/" + su.pathname); var i } resetBaseElement() { ru = null } getUserAgent() { return window.navigator.userAgent } performanceNow() { return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime() } supportsCookies() { return !0 } getCookie(t) { return md(document.cookie, t) } } let su, ru = null; const au = new Vt("TRANSITION_ID"),
                    ou = [{ provide: uc, useFactory: function(t, e, i) { return () => { i.get(mc).donePromise.then(() => { const i = dh();
                                    Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => i.remove(t)) }) } }, deps: [au, uh, ra], multi: !0 }];
                class lu { static init() { var t;
                        t = new lu, Wc = t } addToWindow(t) { Ot.getAngularTestability = (e, i = !0) => { const n = t.findTestabilityInTree(e, i); if (null == n) throw new Error("Could not find testability for element."); return n }, Ot.getAllAngularTestabilities = () => t.getAllTestabilities(), Ot.getAllAngularRootElements = () => t.getAllRootElements(), Ot.frameworkStabilizers || (Ot.frameworkStabilizers = []), Ot.frameworkStabilizers.push(t => { const e = Ot.getAllAngularTestabilities(); let i = e.length,
                                n = !1; const s = function(e) { n = n || e, i--, 0 == i && t(n) };
                            e.forEach((function(t) { t.whenStable(s) })) }) } findTestabilityInTree(t, e, i) { if (null == e) return null; const n = t.getTestability(e); return null != n ? n : i ? dh().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } const cu = new Vt("EventManagerPlugins"); let hu = (() => { class t { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, i) { return this._findPluginFor(e).addEventListener(t, e, i) } addGlobalEventListener(t, e, i) { return this._findPluginFor(e).addGlobalEventListener(t, e, i) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const i = this._plugins; for (let n = 0; n < i.length; n++) { const e = i[n]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error(`No event manager plugin found for event ${t}`) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(cu), Xt(Pc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();
                class du { constructor(t) { this._doc = t } addGlobalEventListener(t, e, i) { const n = dh().getGlobalEventTarget(this._doc, t); if (!n) throw new Error(`Unsupported event target ${n} for event ${e}`); return this.addEventListener(n, e, i) } } let uu = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set;
                                t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) {} getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(),
                    mu = (() => { class t extends uu { constructor(t) { super(), this._doc = t, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(t.head) } _addStylesToHost(t, e) { t.forEach(t => { const i = this._doc.createElement("style");
                                    i.textContent = t, this._styleNodes.add(e.appendChild(i)) }) } addHost(t) { this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t) } removeHost(t) { this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach(e => this._addStylesToHost(t, e)) } ngOnDestroy() { this._styleNodes.forEach(t => dh().remove(t)) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const pu = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" },
                    fu = /%COMP%/g;

                function gu(t, e, i) { for (let n = 0; n < e.length; n++) { let s = e[n];
                        Array.isArray(s) ? gu(t, s, i) : (s = s.replace(fu, t), i.push(s)) } return i }

                function _u(t) { return e => { if ("__ngUnwrap__" === e) return t;!1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let bu = (() => { class t { constructor(t, e, i) { this.eventManager = t, this.sharedStylesHost = e, this.appId = i, this.rendererByCompId = new Map, this.defaultRenderer = new yu(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) {
                                case he.Emulated:
                                    { let i = this.rendererByCompId.get(e.id); return i || (i = new vu(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, i)), i.applyToHost(t), i }
                                case he.Native:
                                case he.ShadowDom:
                                    return new wu(this.eventManager, this.sharedStylesHost, t, e);
                                default:
                                    if (!this.rendererByCompId.has(e.id)) { const t = gu(e.id, e.styles, []);
                                        this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() {} end() {} } return t.\u0275fac = function(e) { return new(e || t)(Xt(hu), Xt(mu), Xt(pc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();
                class yu { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() {} createElement(t, e) { return e ? document.createElementNS(pu[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, i) { t && t.insertBefore(e, i) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let i = "string" == typeof t ? document.querySelector(t) : t; if (!i) throw new Error(`The selector "${t}" did not match any elements`); return e || (i.textContent = ""), i } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, i, n) { if (n) { e = n + ":" + e; const s = pu[n];
                            s ? t.setAttributeNS(s, e, i) : t.setAttribute(e, i) } else t.setAttribute(e, i) } removeAttribute(t, e, i) { if (i) { const n = pu[i];
                            n ? t.removeAttributeNS(n, e) : t.removeAttribute(`${i}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, i, n) { n & Xo.DashCase ? t.style.setProperty(e, i, n & Xo.Important ? "important" : "") : t.style[e] = i } removeStyle(t, e, i) { i & Xo.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, i) { t[e] = i } setValue(t, e) { t.nodeValue = e } listen(t, e, i) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, _u(i)) : this.eventManager.addEventListener(t, e, _u(i)) } } class vu extends yu { constructor(t, e, i, n) { super(t), this.component = i; const s = gu(n + "-" + i.id, i.styles, []);
                        e.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(fu, n + "-" + i.id), this.hostAttr = function(t) { return "_nghost-%COMP%".replace(fu, t) }(n + "-" + i.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const i = super.createElement(t, e); return super.setAttribute(i, this.contentAttr, ""), i } } class wu extends yu { constructor(t, e, i, n) { super(t), this.sharedStylesHost = e, this.hostEl = i, this.component = n, this.shadowRoot = n.encapsulation === he.ShadowDom ? i.attachShadow({ mode: "open" }) : i.createShadowRoot(), this.sharedStylesHost.addHost(this.shadowRoot); const s = gu(n.id, n.styles, []); for (let r = 0; r < s.length; r++) { const t = document.createElement("style");
                            t.textContent = s[r], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, i) { return super.insertBefore(this.nodeOrShadowRoot(t), e, i) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let Cu = (() => { class t extends du { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, e, i) { return t.addEventListener(e, i, !1), () => this.removeEventListener(t, e, i) } removeEventListener(t, e, i) { return t.removeEventListener(e, i) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const xu = ["alt", "control", "meta", "shift"],
                    Su = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" },
                    ku = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" },
                    Eu = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let Du = (() => { class t extends du { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, i, n) { const s = t.parseEventName(i),
                                    r = t.eventCallback(s.fullKey, n, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => dh().onAndCancel(e, s.domEventName, r)) } static parseEventName(e) { const i = e.toLowerCase().split("."),
                                    n = i.shift(); if (0 === i.length || "keydown" !== n && "keyup" !== n) return null; const s = t._normalizeKey(i.pop()); let r = ""; if (xu.forEach(t => { const e = i.indexOf(t);
                                        e > -1 && (i.splice(e, 1), r += t + ".") }), r += s, 0 != i.length || 0 === s.length) return null; const a = {}; return a.domEventName = n, a.fullKey = r, a } static getEventFullKey(t) { let e = "",
                                    i = function(t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified";
                                            e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && ku.hasOwnProperty(e) && (e = ku[e])) } return Su[e] || e }(t); return i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), xu.forEach(n => { n != i && (0, Eu[n])(t) && (e += n + ".") }), e += i, e } static eventCallback(e, i, n) { return s => { t.getEventFullKey(s) === e && n.runGuarded(() => i(s)) } } static _normalizeKey(t) { switch (t) {
                                    case "esc":
                                        return "escape";
                                    default:
                                        return t } } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(),
                    Au = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return Xt(Iu) }, token: t, providedIn: "root" }), t })(),
                    Iu = (() => { class t extends Au { constructor(t) { super(), this._doc = t } sanitize(t, e) { if (null == e) return null; switch (t) {
                                    case qn.NONE:
                                        return e;
                                    case qn.HTML:
                                        return vn(e, "HTML") ? yn(e) : $n(this._doc, String(e));
                                    case qn.STYLE:
                                        return vn(e, "Style") ? yn(e) : function(t) { if (!(t = String(t).trim())) return ""; const e = t.match(Xn); return e && An(e[1]) === e[1] || t.match(Yn) && function(t) { let e = !0,
                                                    i = !0; for (let n = 0; n < t.length; n++) { const s = t.charAt(n); "'" === s && i ? e = !e : '"' === s && e && (i = !i) } return e && i }(t) ? t : (Sn() && console.warn(`WARNING: sanitizing unsafe style value ${t} (see http://g.co/ng/security#xss).`), "unsafe") }(e);
                                    case qn.SCRIPT:
                                        if (vn(e, "Script")) return yn(e); throw new Error("unsafe value used in a script context");
                                    case qn.URL:
                                        return wn(e), vn(e, "URL") ? yn(e) : An(String(e));
                                    case qn.RESOURCE_URL:
                                        if (vn(e, "ResourceURL")) return yn(e); throw new Error("unsafe value used in a resource URL context (see http://g.co/ng/security#xss)");
                                    default:
                                        throw new Error(`Unexpected SecurityContext ${t} (see http://g.co/ng/security#xss)`) } } bypassSecurityTrustHtml(t) { return new pn(t) } bypassSecurityTrustStyle(t) { return new fn(t) } bypassSecurityTrustScript(t) { return new gn(t) } bypassSecurityTrustUrl(t) { return new _n(t) } bypassSecurityTrustResourceUrl(t) { return new bn(t) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh)) }, t.\u0275prov = dt({ factory: function() { return t = Xt(zt), new Iu(t.get(uh)); var t }, token: t, providedIn: "root" }), t })(); const Tu = Kc(oh, "browser", [{ provide: bc, useValue: "browser" }, { provide: _c, useValue: function() { nu.makeCurrent(), lu.init() }, multi: !0 }, { provide: uh, useFactory: function() { return function(t) { Me = t }(document), document }, deps: [] }]),
                    Ou = [
                        [], { provide: $r, useValue: "root" }, { provide: un, useFactory: function() { return new un }, deps: [] }, { provide: cu, useClass: Cu, multi: !0, deps: [uh, Pc, bc] }, { provide: cu, useClass: Du, multi: !0, deps: [uh] },
                        [], { provide: bu, useClass: bu, deps: [hu, mu, pc] }, { provide: Yo, useExisting: bu }, { provide: uu, useExisting: mu }, { provide: mu, useClass: mu, deps: [uh] }, { provide: Hc, useClass: Hc, deps: [Pc] }, { provide: hu, useClass: hu, deps: [cu, Pc] },
                        []
                    ]; let Ru = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: pc, useValue: e.appId }, { provide: au, useExisting: pc }, ou] } } } return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t)(Xt(t, 12)) }, providers: Ou, imports: [Jd, ch] }), t })();

                function Mu(...t) { let e = t[t.length - 1]; return D(e) ? (t.pop(), z(t, e)) : W(t) } "undefined" != typeof window && window;
                class Pu extends k { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new C; return this._value } next(t) { super.next(this._value = t) } } const Fu = (() => {
                        function t() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return t.prototype = Object.create(Error.prototype), t })(),
                    Nu = {};

                function Lu(...t) { let e = null,
                        i = null; return D(t[t.length - 1]) && (i = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && l(t[0]) && (t = t[0]), W(t, i).lift(new Bu(e)) } class Bu { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new Vu(t, this.resultSelector)) } } class Vu extends N { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(Nu), this.observables.push(t) } _complete() { const t = this.observables,
                            e = t.length; if (0 === e) this.destination.complete();
                        else { this.active = e, this.toRespond = e; for (let i = 0; i < e; i++) { const e = t[i];
                                this.add(F(this, e, e, i)) } } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, i, n, s) { const r = this.values,
                            a = this.toRespond ? r[i] === Nu ? --this.toRespond : this.toRespond : 0;
                        r[i] = e, 0 === a && (this.resultSelector ? this._tryResultSelector(r) : this.destination.next(r.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (i) { return void this.destination.error(i) } this.destination.next(e) } } const zu = new v(t => t.complete());

                function Uu(t) { return t ? function(t) { return new v(e => t.schedule(() => e.complete())) }(t) : zu }

                function Hu(t) { return new v(e => { let i; try { i = t() } catch (n) { return void e.error(n) } return (i ? U(i) : Uu()).subscribe(e) }) }

                function ju() { return $(1) }

                function Gu(t, e) { return function(i) { return i.lift(new $u(t, e)) } } class $u { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new Wu(t, this.predicate, this.thisArg)) } } class Wu extends p { constructor(t, e, i) { super(t), this.predicate = e, this.thisArg = i, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (i) { return void this.destination.error(i) } e && this.destination.next(t) } } const qu = (() => {
                    function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t })();

                function Yu(t) { return function(e) { return 0 === t ? Uu() : e.lift(new Xu(t)) } } class Xu { constructor(t) { if (this.total = t, this.total < 0) throw new qu } call(t, e) { return e.subscribe(new Ku(t, this.total)) } } class Ku extends p { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring,
                            i = this.total,
                            n = this.count++;
                        e.length < i ? e.push(t) : e[n % i] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const i = this.count >= this.total ? this.total : this.count,
                                n = this.ring; for (let s = 0; s < i; s++) { const s = e++ % i;
                                t.next(n[s]) } } t.complete() } }

                function Zu(t = tm) { return e => e.lift(new Qu(t)) } class Qu { constructor(t) { this.errorFactory = t } call(t, e) { return e.subscribe(new Ju(t, this.errorFactory)) } } class Ju extends p { constructor(t, e) { super(t), this.errorFactory = e, this.hasValue = !1 } _next(t) { this.hasValue = !0, this.destination.next(t) } _complete() { if (this.hasValue) return this.destination.complete(); { let e; try { e = this.errorFactory() } catch (t) { e = t } this.destination.error(e) } } }

                function tm() { return new Fu }

                function em(t = null) { return e => e.lift(new im(t)) } class im { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new nm(t, this.defaultValue)) } } class nm extends p { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } }

                function sm(t, e) { const i = arguments.length >= 2; return n => n.pipe(t ? Gu((e, i) => t(e, i, n)) : _, Yu(1), i ? em(e) : Zu(() => new Fu)) }

                function rm(t) { return function(e) { const i = new am(t),
                            n = e.lift(i); return i.caught = n } } class am { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new om(t, this.selector, this.caught)) } } class om extends N { constructor(t, e, i) { super(t), this.selector = e, this.caught = i } error(t) { if (!this.isStopped) { let i; try { i = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const n = new A(this, void 0, void 0);
                            this.add(n); const s = F(this, i, void 0, void 0, n);
                            s !== n && this.add(s) } } }

                function lm(t) { return e => 0 === t ? Uu() : e.lift(new cm(t)) } class cm { constructor(t) { if (this.total = t, this.total < 0) throw new qu } call(t, e) { return e.subscribe(new hm(t, this.total)) } } class hm extends p { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total,
                            i = ++this.count;
                        i <= e && (this.destination.next(t), i === e && (this.destination.complete(), this.unsubscribe())) } }

                function dm(t, e) { const i = arguments.length >= 2; return n => n.pipe(t ? Gu((e, i) => t(e, i, n)) : _, lm(1), i ? em(e) : Zu(() => new Fu)) } class um { constructor(t, e, i) { this.predicate = t, this.thisArg = e, this.source = i } call(t, e) { return e.subscribe(new mm(t, this.predicate, this.thisArg, this.source)) } } class mm extends p { constructor(t, e, i, n) { super(t), this.predicate = e, this.thisArg = i, this.source = n, this.index = 0, this.thisArg = i || this } notifyComplete(t) { this.destination.next(t), this.destination.complete() } _next(t) { let e = !1; try { e = this.predicate.call(this.thisArg, t, this.index++, this.source) } catch (i) { return void this.destination.error(i) } e || this.notifyComplete(!1) } _complete() { this.notifyComplete(!0) } }

                function pm(t, e) { return "function" == typeof e ? i => i.pipe(pm((i, n) => U(t(i, n)).pipe(L((t, s) => e(i, t, n, s))))) : e => e.lift(new fm(t)) } class fm { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new gm(t, this.project)) } } class gm extends N { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const i = this.index++; try { e = this.project(t, i) } catch (n) { return void this.destination.error(n) } this._innerSub(e, t, i) } _innerSub(t, e, i) { const n = this.innerSubscription;
                        n && n.unsubscribe(); const s = new A(this, e, i),
                            r = this.destination;
                        r.add(s), this.innerSubscription = F(this, t, void 0, void 0, s), this.innerSubscription !== s && r.add(this.innerSubscription) } _complete() { const { innerSubscription: t } = this;
                        t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = null } notifyComplete(t) { this.destination.remove(t), this.innerSubscription = null, this.isStopped && super._complete() } notifyNext(t, e, i, n, s) { this.destination.next(e) } }

                function _m(...t) { return ju()(Mu(...t)) }

                function bm(...t) { const e = t[t.length - 1]; return D(e) ? (t.pop(), i => _m(t, i, e)) : e => _m(t, e) }

                function ym(t, e) { let i = !1; return arguments.length >= 2 && (i = !0),
                        function(n) { return n.lift(new vm(t, e, i)) } } class vm { constructor(t, e, i = !1) { this.accumulator = t, this.seed = e, this.hasSeed = i } call(t, e) { return e.subscribe(new wm(t, this.accumulator, this.seed, this.hasSeed)) } } class wm extends p { constructor(t, e, i, n) { super(t), this.accumulator = e, this._seed = i, this.hasSeed = n, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t);
                        this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let i; try { i = this.accumulator(this.seed, t, e) } catch (n) { this.destination.error(n) } this.seed = i, this.destination.next(i) } }

                function Cm(t, e) { return H(t, e, 1) }

                function xm() {}

                function Sm(t, e, i) { return function(n) { return n.lift(new km(t, e, i)) } } class km { constructor(t, e, i) { this.nextOrObserver = t, this.error = e, this.complete = i } call(t, e) { return e.subscribe(new Em(t, this.nextOrObserver, this.error, this.complete)) } } class Em extends p { constructor(t, e, i, s) { super(t), this._tapNext = xm, this._tapError = xm, this._tapComplete = xm, this._tapError = i || xm, this._tapComplete = s || xm, n(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || xm, this._tapError = e.error || xm, this._tapComplete = e.complete || xm) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } }

                function Dm(t) { return e => e.lift(new Am(t)) } class Am { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new Im(t, this.callback)) } } class Im extends p { constructor(t, e) { super(t), this.add(new d(e)) } } class Tm { constructor(t, e) { this.id = t, this.url = e } } class Om extends Tm { constructor(t, e, i = "imperative", n = null) { super(t, e), this.navigationTrigger = i, this.restoredState = n } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Rm extends Tm { constructor(t, e, i) { super(t, e), this.urlAfterRedirects = i } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Mm extends Tm { constructor(t, e, i) { super(t, e), this.reason = i } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class Pm extends Tm { constructor(t, e, i) { super(t, e), this.error = i } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class Fm extends Tm { constructor(t, e, i, n) { super(t, e), this.urlAfterRedirects = i, this.state = n } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Nm extends Tm { constructor(t, e, i, n) { super(t, e), this.urlAfterRedirects = i, this.state = n } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Lm extends Tm { constructor(t, e, i, n, s) { super(t, e), this.urlAfterRedirects = i, this.state = n, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class Bm extends Tm { constructor(t, e, i, n) { super(t, e), this.urlAfterRedirects = i, this.state = n } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Vm extends Tm { constructor(t, e, i, n) { super(t, e), this.urlAfterRedirects = i, this.state = n } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class zm { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Um { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class Hm { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')` } } class jm { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')` } } class Gm { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')` } } class $m { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')` } } class Wm { constructor(t, e, i) { this.routerEvent = t, this.position = e, this.anchor = i } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')` } } let qm = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                            ["ng-component"]
                        ], decls: 1, vars: 0, template: function(t, e) { 1 & t && Oa(0, "router-outlet") }, directives: function() { return [Jf] }, encapsulation: 2 }), t })();
                class Ym { constructor(t) { this.params = t || {} } has(t) { return this.params.hasOwnProperty(t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } }

                function Xm(t) { return new Ym(t) }

                function Km(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e }

                function Zm(t, e, i) { const n = i.path.split("/"); if (n.length > t.length) return null; if ("full" === i.pathMatch && (e.hasChildren() || n.length < t.length)) return null; const s = {}; for (let r = 0; r < n.length; r++) { const e = n[r],
                            i = t[r]; if (e.startsWith(":")) s[e.substring(1)] = i;
                        else if (e !== i.path) return null } return { consumed: t.slice(0, n.length), posParams: s } } class Qm { constructor(t, e) { this.routes = t, this.module = e } }

                function Jm(t, e = "") { for (let i = 0; i < t.length; i++) { const n = t[i];
                        tp(n, ep(e, n)) } }

                function tp(t, e) { if (!t) throw new Error(`\n      Invalid configuration of route '${e}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `); if (Array.isArray(t)) throw new Error(`Invalid configuration of route '${e}': Array cannot be specified`); if (!t.component && !t.children && !t.loadChildren && t.outlet && "primary" !== t.outlet) throw new Error(`Invalid configuration of route '${e}': a componentless route without children or loadChildren cannot have a named outlet set`); if (t.redirectTo && t.children) throw new Error(`Invalid configuration of route '${e}': redirectTo and children cannot be used together`); if (t.redirectTo && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': redirectTo and loadChildren cannot be used together`); if (t.children && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': children and loadChildren cannot be used together`); if (t.redirectTo && t.component) throw new Error(`Invalid configuration of route '${e}': redirectTo and component cannot be used together`); if (t.path && t.matcher) throw new Error(`Invalid configuration of route '${e}': path and matcher cannot be used together`); if (void 0 === t.redirectTo && !t.component && !t.children && !t.loadChildren) throw new Error(`Invalid configuration of route '${e}'. One of the following must be provided: component, redirectTo, children or loadChildren`); if (void 0 === t.path && void 0 === t.matcher) throw new Error(`Invalid configuration of route '${e}': routes must have either a path or a matcher specified`); if ("string" == typeof t.path && "/" === t.path.charAt(0)) throw new Error(`Invalid configuration of route '${e}': path cannot start with a slash`); if ("" === t.path && void 0 !== t.redirectTo && void 0 === t.pathMatch) throw new Error(`Invalid configuration of route '{path: "${e}", redirectTo: "${t.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`); if (void 0 !== t.pathMatch && "full" !== t.pathMatch && "prefix" !== t.pathMatch) throw new Error(`Invalid configuration of route '${e}': pathMatch can only be set to 'prefix' or 'full'`);
                    t.children && Jm(t.children, e) }

                function ep(t, e) { return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t }

                function ip(t) { const e = t.children && t.children.map(ip),
                        i = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !i.component && (e || i.loadChildren) && i.outlet && "primary" !== i.outlet && (i.component = qm), i }

                function np(t, e) { const i = Object.keys(t),
                        n = Object.keys(e); if (!i || !n || i.length != n.length) return !1; let s; for (let r = 0; r < i.length; r++)
                        if (s = i[r], !sp(t[s], e[s])) return !1; return !0 }

                function sp(t, e) { return Array.isArray(t) && Array.isArray(e) ? t.length == e.length && t.every(t => e.indexOf(t) > -1) : t === e }

                function rp(t) { return Array.prototype.concat.apply([], t) }

                function ap(t) { return t.length > 0 ? t[t.length - 1] : null }

                function op(t, e) { for (const i in t) t.hasOwnProperty(i) && e(t[i], i) }

                function lp(t) { return La(t) ? t : Na(t) ? U(Promise.resolve(t)) : Mu(t) }

                function cp(t, e, i) { return i ? function(t, e) { return np(t, e) }(t.queryParams, e.queryParams) && function t(e, i) { if (!mp(e.segments, i.segments)) return !1; if (e.numberOfChildren !== i.numberOfChildren) return !1; for (const n in i.children) { if (!e.children[n]) return !1; if (!t(e.children[n], i.children[n])) return !1 } return !0 }(t.root, e.root) : function(t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(i => sp(t[i], e[i])) }(t.queryParams, e.queryParams) && function t(e, i) { return function e(i, n, s) { if (i.segments.length > s.length) return !!mp(i.segments.slice(0, s.length), s) && !n.hasChildren(); if (i.segments.length === s.length) { if (!mp(i.segments, s)) return !1; for (const e in n.children) { if (!i.children[e]) return !1; if (!t(i.children[e], n.children[e])) return !1 } return !0 } { const t = s.slice(0, i.segments.length),
                                    r = s.slice(i.segments.length); return !!mp(i.segments, t) && !!i.children.primary && e(i.children.primary, n, r) } }(e, i, i.segments) }(t.root, e.root) } class hp { constructor(t, e, i) { this.root = t, this.queryParams = e, this.fragment = i } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Xm(this.queryParams)), this._queryParamMap } toString() { return _p.serialize(this) } } class dp { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, op(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return bp(this) } } class up { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = Xm(this.parameters)), this._parameterMap } toString() { return Sp(this) } }

                function mp(t, e) { return t.length === e.length && t.every((t, i) => t.path === e[i].path) }

                function pp(t, e) { let i = []; return op(t.children, (t, n) => { "primary" === n && (i = i.concat(e(t, n))) }), op(t.children, (t, n) => { "primary" !== n && (i = i.concat(e(t, n))) }), i } class fp {} class gp { parse(t) { const e = new Ip(t); return new hp(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { var e; return `${`/${function t(e,i){if(!e.hasChildren())return bp(e);if(i){const i=e.children.primary?t(e.children.primary,!1):"",n=[];return op(e.children,(e,i)=>{"primary"!==i&&n.push(`${i}:${t(e,!1)}`)}),n.length>0?`${i}(${n.join("//")})`: i } { const i = pp(e, (i, n) => "primary" === n ? [t(e.children.primary, !1)] : [`${n}:${t(i,!1)}`]); return `${bp(e)}/(${i.join("//")})` } }(t.root, !0) }
            `}${function(t){const e=Object.keys(t).map(e=>{const i=t[e];return Array.isArray(i)?i.map(t=>`${vp(e)}=${vp(t)}`).join("&"):`${vp(e)}=${vp(i)}`});return e.length?` ? $ { e.join("&") } `:""}(t.queryParams)}${"string"==typeof t.fragment?`#${e=t.fragment,encodeURI(e)}`:""}` }
    }
    const _p = new gp;

    function bp(t) { return t.segments.map(t => Sp(t)).join("/") }

    function yp(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") }

    function vp(t) { return yp(t).replace(/%3B/gi, ";") }

    function wp(t) { return yp(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") }

    function Cp(t) { return decodeURIComponent(t) }

    function xp(t) { return Cp(t.replace(/\+/g, "%20")) }

    function Sp(t) { return `${wp(t.path)}${e=t.parameters,Object.keys(e).map(t=>`;${wp(t)}=${wp(e[t])}`).join("")}`; var e }
    const kp = /^[^\/()?;=#]+/;

    function Ep(t) { const e = t.match(kp); return e ? e[0] : "" }
    const Dp = /^[^=?&#]+/, Ap = /^[^?&#]+/; class Ip { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new dp([], {}) : new dp([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?"))
                do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {};
            this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");) this.capture("/"), t.push(this.parseSegment()); let e = {};
            this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let i = {}; return this.peekStartsWith("(") && (i = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (i.primary = new dp(t, e)), i } parseSegment() { const t = Ep(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new up(Cp(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");) this.parseParam(t); return t } parseParam(t) { const e = Ep(this.remaining); if (!e) return;
            this.capture(e); let i = ""; if (this.consumeOptional("=")) { const t = Ep(this.remaining);
                t && (i = t, this.capture(i)) } t[Cp(e)] = Cp(i) } parseQueryParam(t) { const e = function(t) { const e = t.match(Dp); return e ? e[0] : "" }(this.remaining); if (!e) return;
            this.capture(e); let i = ""; if (this.consumeOptional("=")) { const t = function(t) { const e = t.match(Ap); return e ? e[0] : "" }(this.remaining);
                t && (i = t, this.capture(i)) } const n = xp(e),
                s = xp(i); if (t.hasOwnProperty(n)) { let e = t[n];
                Array.isArray(e) || (e = [e], t[n] = e), e.push(s) } else t[n] = s } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const i = Ep(this.remaining),
                    n = this.remaining[i.length]; if ("/" !== n && ")" !== n && ";" !== n) throw new Error(`Cannot parse url '${this.url}'`); let s = void 0;
                i.indexOf(":") > -1 ? (s = i.substr(0, i.indexOf(":")), this.capture(s), this.capture(":")) : t && (s = "primary"); const r = this.parseChildren();
                e[s] = 1 === Object.keys(r).length ? r.primary : new dp([], r), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class Tp { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = Op(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = Op(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = Rp(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return Rp(t, this._root).map(t => t.value) } }

    function Op(t, e) { if (t === e.value) return e; for (const i of e.children) { const e = Op(t, i); if (e) return e } return null }

    function Rp(t, e) { if (t === e.value) return [e]; for (const i of e.children) { const n = Rp(t, i); if (n.length) return n.unshift(e), n } return [] } class Mp { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } }

    function Pp(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class Fp extends Tp { constructor(t, e) { super(t), this.snapshot = e, Up(this, t) } toString() { return this.snapshot.toString() } }

    function Np(t, e) { const i = function(t, e) { const i = new Vp([], {}, {}, "", {}, "primary", e, null, t.root, -1, {}); return new zp("", new Mp(i, [])) }(t, e),
            n = new Pu([new up("", {})]),
            s = new Pu({}),
            r = new Pu({}),
            a = new Pu({}),
            o = new Pu(""),
            l = new Lp(n, s, a, o, r, "primary", e, i.root); return l.snapshot = i.root, new Fp(new Mp(l, []), i) } class Lp { constructor(t, e, i, n, s, r, a, o) { this.url = t, this.params = e, this.queryParams = i, this.fragment = n, this.data = s, this.outlet = r, this.component = a, this._futureSnapshot = o } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(L(t => Xm(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(L(t => Xm(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } }

    function Bp(t, e = "emptyOnly") { const i = t.pathFromRoot; let n = 0; if ("always" !== e)
            for (n = i.length - 1; n >= 1;) { const t = i[n],
                    e = i[n - 1]; if (t.routeConfig && "" === t.routeConfig.path) n--;
                else { if (e.component) break;
                    n-- } }
        return function(t) { return t.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(i.slice(n)) } class Vp { constructor(t, e, i, n, s, r, a, o, l, c, h) { this.url = t, this.params = e, this.queryParams = i, this.fragment = n, this.data = s, this.outlet = r, this.component = a, this.routeConfig = o, this._urlSegment = l, this._lastPathIndex = c, this._resolve = h } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Xm(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Xm(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t=>t.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')` } } class zp extends Tp { constructor(t, e) { super(e), this.url = t, Up(this, e) } toString() { return Hp(this._root) } }

    function Up(t, e) { e.value._routerState = t, e.children.forEach(e => Up(t, e)) }

    function Hp(t) { const e = t.children.length > 0 ? ` { ${t.children.map(Hp).join(", ")} } ` : ""; return `${t.value}${e}` }

    function jp(t) { if (t.snapshot) { const e = t.snapshot,
                i = t._futureSnapshot;
            t.snapshot = i, np(e.queryParams, i.queryParams) || t.queryParams.next(i.queryParams), e.fragment !== i.fragment && t.fragment.next(i.fragment), np(e.params, i.params) || t.params.next(i.params),
                function(t, e) { if (t.length !== e.length) return !1; for (let i = 0; i < t.length; ++i)
                        if (!np(t[i], e[i])) return !1; return !0 }(e.url, i.url) || t.url.next(i.url), np(e.data, i.data) || t.data.next(i.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) }

    function Gp(t, e) { var i, n; return np(t.params, e.params) && mp(i = t.url, n = e.url) && i.every((t, e) => np(t.parameters, n[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || Gp(t.parent, e.parent)) }

    function $p(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath }

    function Wp(t, e, i, n, s) { let r = {}; return n && op(n, (t, e) => { r[e] = Array.isArray(t) ? t.map(t => `${t}`) : `${t}` }), new hp(i.root === t ? e : function t(e, i, n) { const s = {}; return op(e.children, (e, r) => { s[r] = e === i ? n : t(e, i, n) }), new dp(e.segments, s) }(i.root, t, e), r, s) } class qp { constructor(t, e, i) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = i, t && i.length > 0 && $p(i[0])) throw new Error("Root segment cannot have matrix parameters"); const n = i.find(t => "object" == typeof t && null != t && t.outlets); if (n && n !== ap(i)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Yp { constructor(t, e, i) { this.segmentGroup = t, this.processChildren = e, this.index = i } }

    function Xp(t) { return "object" == typeof t && null != t && t.outlets ? t.outlets.primary : `${t}` }

    function Kp(t, e, i) { if (t || (t = new dp([], {})), 0 === t.segments.length && t.hasChildren()) return Zp(t, e, i); const n = function(t, e, i) { let n = 0,
                    s = e; const r = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < t.segments.length;) { if (n >= i.length) return r; const e = t.segments[s],
                        a = Xp(i[n]),
                        o = n < i.length - 1 ? i[n + 1] : null; if (s > 0 && void 0 === a) break; if (a && o && "object" == typeof o && void 0 === o.outlets) { if (!ef(a, o, e)) return r;
                        n += 2 } else { if (!ef(a, {}, e)) return r;
                        n++ } s++ } return { match: !0, pathIndex: s, commandIndex: n } }(t, e, i),
            s = i.slice(n.commandIndex); if (n.match && n.pathIndex < t.segments.length) { const e = new dp(t.segments.slice(0, n.pathIndex), {}); return e.children.primary = new dp(t.segments.slice(n.pathIndex), t.children), Zp(e, 0, s) } return n.match && 0 === s.length ? new dp(t.segments, {}) : n.match && !t.hasChildren() ? Qp(t, e, i) : n.match ? Zp(t, 0, s) : Qp(t, e, i) }

    function Zp(t, e, i) { if (0 === i.length) return new dp(t.segments, {}); { const n = function(t) { return "object" != typeof t[0] || void 0 === t[0].outlets ? { primary: t } : t[0].outlets }(i),
                s = {}; return op(n, (i, n) => { null !== i && (s[n] = Kp(t.children[n], e, i)) }), op(t.children, (t, e) => { void 0 === n[e] && (s[e] = t) }), new dp(t.segments, s) } }

    function Qp(t, e, i) { const n = t.segments.slice(0, e); let s = 0; for (; s < i.length;) { if ("object" == typeof i[s] && void 0 !== i[s].outlets) { const t = Jp(i[s].outlets); return new dp(n, t) } if (0 === s && $p(i[0])) { n.push(new up(t.segments[e].path, i[0])), s++; continue } const r = Xp(i[s]),
                a = s < i.length - 1 ? i[s + 1] : null;
            r && a && $p(a) ? (n.push(new up(r, tf(a))), s += 2) : (n.push(new up(r, {})), s++) } return new dp(n, {}) }

    function Jp(t) { const e = {}; return op(t, (t, i) => { null !== t && (e[i] = Qp(new dp([], {}), 0, t)) }), e }

    function tf(t) { const e = {}; return op(t, (t, i) => e[i] = `${t}`), e }

    function ef(t, e, i) { return t == i.path && np(e, i.parameters) } class nf { constructor(t, e, i, n) { this.routeReuseStrategy = t, this.futureState = e, this.currState = i, this.forwardEvent = n } activate(t) { const e = this.futureState._root,
                i = this.currState ? this.currState._root : null;
            this.deactivateChildRoutes(e, i, t), jp(this.futureState.root), this.activateChildRoutes(e, i, t) } deactivateChildRoutes(t, e, i) { const n = Pp(e);
            t.children.forEach(t => { const e = t.value.outlet;
                this.deactivateRoutes(t, n[e], i), delete n[e] }), op(n, (t, e) => { this.deactivateRouteAndItsChildren(t, i) }) } deactivateRoutes(t, e, i) { const n = t.value,
                s = e ? e.value : null; if (n === s)
                if (n.component) { const s = i.getContext(n.outlet);
                    s && this.deactivateChildRoutes(t, e, s.children) } else this.deactivateChildRoutes(t, e, i);
            else s && this.deactivateRouteAndItsChildren(e, i) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const i = e.getContext(t.value.outlet); if (i && i.outlet) { const e = i.outlet.detach(),
                    n = i.children.onOutletDeactivated();
                this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: n }) } } deactivateRouteAndOutlet(t, e) { const i = e.getContext(t.value.outlet); if (i) { const n = Pp(t),
                    s = t.value.component ? i.children : e;
                op(n, (t, e) => this.deactivateRouteAndItsChildren(t, s)), i.outlet && (i.outlet.deactivate(), i.children.onOutletDeactivated()) } } activateChildRoutes(t, e, i) { const n = Pp(e);
            t.children.forEach(t => { this.activateRoutes(t, n[t.value.outlet], i), this.forwardEvent(new $m(t.value.snapshot)) }), t.children.length && this.forwardEvent(new jm(t.value.snapshot)) } activateRoutes(t, e, i) { const n = t.value,
                s = e ? e.value : null; if (jp(n), n === s)
                if (n.component) { const s = i.getOrCreateContext(n.outlet);
                    this.activateChildRoutes(t, e, s.children) } else this.activateChildRoutes(t, e, i);
            else if (n.component) { const e = i.getOrCreateContext(n.outlet); if (this.routeReuseStrategy.shouldAttach(n.snapshot)) { const t = this.routeReuseStrategy.retrieve(n.snapshot);
                    this.routeReuseStrategy.store(n.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), sf(t.route) } else { const i = function(t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(n.snapshot),
                        s = i ? i.module.componentFactoryResolver : null;
                    e.attachRef = null, e.route = n, e.resolver = s, e.outlet && e.outlet.activateWith(n, s), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, i) } }

    function sf(t) { jp(t.value), t.children.forEach(sf) }

    function rf(t) { return "function" == typeof t }

    function af(t) { return t instanceof hp } class of { constructor(t) { this.segmentGroup = t || null } } class lf { constructor(t) { this.urlTree = t } }

    function cf(t) { return new v(e => e.error(new of (t))) }

    function hf(t) { return new v(e => e.error(new lf(t))) }

    function df(t) { return new v(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class uf { constructor(t, e, i, n, s) { this.configLoader = e, this.urlSerializer = i, this.urlTree = n, this.config = s, this.allowRedirects = !0, this.ngModule = t.get(te) } apply() { return this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, "primary").pipe(L(t => this.createUrlTree(t, this.urlTree.queryParams, this.urlTree.fragment))).pipe(rm(t => { if (t instanceof lf) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof of ) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, "primary").pipe(L(e => this.createUrlTree(e, t.queryParams, t.fragment))).pipe(rm(t => { if (t instanceof of ) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, i) { const n = t.segments.length > 0 ? new dp([], { primary: t }) : t; return new hp(n, e, i) } expandSegmentGroup(t, e, i, n) { return 0 === i.segments.length && i.hasChildren() ? this.expandChildren(t, e, i).pipe(L(t => new dp([], t))) : this.expandSegment(t, i, e, i.segments, n, !0) } expandChildren(t, e, i) { return function(t, e) { if (0 === Object.keys(t).length) return Mu({}); const i = [],
                    n = [],
                    s = {}; return op(t, (t, r) => { const a = e(r, t).pipe(L(t => s[r] = t)); "primary" === r ? i.push(a) : n.push(a) }), Mu.apply(null, i.concat(n)).pipe(ju(), sm(), L(() => s)) }(i.children, (i, n) => this.expandSegmentGroup(t, e, n, i)) } expandSegment(t, e, i, n, s, r) { return Mu(...i).pipe(L(a => this.expandSegmentAgainstRoute(t, e, i, a, n, s, r).pipe(rm(t => { if (t instanceof of ) return Mu(null); throw t }))), ju(), dm(t => !!t), rm((t, i) => { if (t instanceof Fu || "EmptyError" === t.name) { if (this.noLeftoversInUrl(e, n, s)) return Mu(new dp([], {})); throw new of (e) } throw t })) } noLeftoversInUrl(t, e, i) { return 0 === e.length && !t.children[i] } expandSegmentAgainstRoute(t, e, i, n, s, r, a) { return gf(n) !== r ? cf(e) : void 0 === n.redirectTo ? this.matchSegmentAgainstRoute(t, e, n, s) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) : cf(e) } expandSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) { return "**" === n.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, i, n, r) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, i, n) { const s = this.applyRedirectCommands([], i.redirectTo, {}); return i.redirectTo.startsWith("/") ? hf(s) : this.lineralizeSegments(i, s).pipe(H(i => { const s = new dp(i, {}); return this.expandSegment(t, s, e, i, n, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) { const { matched: a, consumedSegments: o, lastChild: l, positionalParamSegments: c } = mf(e, n, s); if (!a) return cf(e); const h = this.applyRedirectCommands(o, n.redirectTo, c); return n.redirectTo.startsWith("/") ? hf(h) : this.lineralizeSegments(n, h).pipe(H(n => this.expandSegment(t, e, i, n.concat(s.slice(l)), r, !1))) } matchSegmentAgainstRoute(t, e, i, n) { if ("**" === i.path) return i.loadChildren ? this.configLoader.load(t.injector, i).pipe(L(t => (i._loadedConfig = t, new dp(n, {})))) : Mu(new dp(n, {})); const { matched: s, consumedSegments: r, lastChild: a } = mf(e, i, n); if (!s) return cf(e); const o = n.slice(a); return this.getChildConfig(t, i, n).pipe(H(t => { const i = t.module,
                    n = t.routes,
                    { segmentGroup: s, slicedSegments: a } = function(t, e, i, n) { return i.length > 0 && function(t, e, i) { return i.some(i => ff(t, e, i) && "primary" !== gf(i)) }(t, i, n) ? { segmentGroup: pf(new dp(e, function(t, e) { const i = {};
                                i.primary = e; for (const n of t) "" === n.path && "primary" !== gf(n) && (i[gf(n)] = new dp([], {})); return i }(n, new dp(i, t.children)))), slicedSegments: [] } : 0 === i.length && function(t, e, i) { return i.some(i => ff(t, e, i)) }(t, i, n) ? { segmentGroup: pf(new dp(t.segments, function(t, e, i, n) { const s = {}; for (const r of i) ff(t, e, r) && !n[gf(r)] && (s[gf(r)] = new dp([], {})); return Object.assign(Object.assign({}, n), s) }(t, i, n, t.children))), slicedSegments: i } : { segmentGroup: t, slicedSegments: i } }(e, r, o, n); return 0 === a.length && s.hasChildren() ? this.expandChildren(i, n, s).pipe(L(t => new dp(r, t))) : 0 === n.length && 0 === a.length ? Mu(new dp(r, {})) : this.expandSegment(i, s, n, a, "primary", !0).pipe(L(t => new dp(r.concat(t.segments), t.children))) })) } getChildConfig(t, e, i) { return e.children ? Mu(new Qm(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? Mu(e._loadedConfig) : function(t, e, i) { const n = e.canLoad; return n && 0 !== n.length ? U(n).pipe(L(n => { const s = t.get(n); let r; if (function(t) { return t && rf(t.canLoad) }(s)) r = s.canLoad(e, i);
                    else { if (!rf(s)) throw new Error("Invalid CanLoad guard");
                        r = s(e, i) } return lp(r) })).pipe(ju(), (s = t => !0 === t, t => t.lift(new um(s, void 0, t)))) : Mu(!0); var s }(t.injector, e, i).pipe(H(i => i ? this.configLoader.load(t.injector, e).pipe(L(t => (e._loadedConfig = t, t))) : function(t) { return new v(e => e.error(Km(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : Mu(new Qm([], t)) } lineralizeSegments(t, e) { let i = [],
                n = e.root; for (;;) { if (i = i.concat(n.segments), 0 === n.numberOfChildren) return Mu(i); if (n.numberOfChildren > 1 || !n.children.primary) return df(t.redirectTo);
                n = n.children.primary } } applyRedirectCommands(t, e, i) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, i) } applyRedirectCreatreUrlTree(t, e, i, n) { const s = this.createSegmentGroup(t, e.root, i, n); return new hp(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const i = {}; return op(t, (t, n) => { if ("string" == typeof t && t.startsWith(":")) { const s = t.substring(1);
                    i[n] = e[s] } else i[n] = t }), i } createSegmentGroup(t, e, i, n) { const s = this.createSegments(t, e.segments, i, n); let r = {}; return op(e.children, (e, s) => { r[s] = this.createSegmentGroup(t, e, i, n) }), new dp(s, r) } createSegments(t, e, i, n) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, n) : this.findOrReturn(e, i)) } findPosParam(t, e, i) { const n = i[e.path.substring(1)]; if (!n) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return n } findOrReturn(t, e) { let i = 0; for (const n of e) { if (n.path === t.path) return e.splice(i), n;
                i++ } return t } }

    function mf(t, e, i) { if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || i.length > 0) ? { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } : { matched: !0, consumedSegments: [], lastChild: 0, positionalParamSegments: {} }; const n = (e.matcher || Zm)(i, t, e); return n ? { matched: !0, consumedSegments: n.consumed, lastChild: n.consumed.length, positionalParamSegments: n.posParams } : { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } }

    function pf(t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new dp(t.segments.concat(e.segments), e.children) } return t }

    function ff(t, e, i) { return (!(t.hasChildren() || e.length > 0) || "full" !== i.pathMatch) && "" === i.path && void 0 !== i.redirectTo }

    function gf(t) { return t.outlet || "primary" } class _f { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class bf { constructor(t, e) { this.component = t, this.route = e } }

    function yf(t, e, i) { const n = t._root; return function t(e, i, n, s, r = { canDeactivateChecks: [], canActivateChecks: [] }) { const a = Pp(i); return e.children.forEach(e => {! function(e, i, n, s, r = { canDeactivateChecks: [], canActivateChecks: [] }) { const a = e.value,
                        o = i ? i.value : null,
                        l = n ? n.getContext(e.value.outlet) : null; if (o && a.routeConfig === o.routeConfig) { const c = function(t, e, i) { if ("function" == typeof i) return i(t, e); switch (i) {
                                case "pathParamsChange":
                                    return !mp(t.url, e.url);
                                case "pathParamsOrQueryParamsChange":
                                    return !mp(t.url, e.url) || !np(t.queryParams, e.queryParams);
                                case "always":
                                    return !0;
                                case "paramsOrQueryParamsChange":
                                    return !Gp(t, e) || !np(t.queryParams, e.queryParams);
                                case "paramsChange":
                                default:
                                    return !Gp(t, e) } }(o, a, a.routeConfig.runGuardsAndResolvers);
                        c ? r.canActivateChecks.push(new _f(s)) : (a.data = o.data, a._resolvedData = o._resolvedData), t(e, i, a.component ? l ? l.children : null : n, s, r), c && r.canDeactivateChecks.push(new bf(l && l.outlet && l.outlet.component || null, o)) } else o && wf(i, l, r), r.canActivateChecks.push(new _f(s)), t(e, null, a.component ? l ? l.children : null : n, s, r) }(e, a[e.value.outlet], n, s.concat([e.value]), r), delete a[e.value.outlet] }), op(a, (t, e) => wf(t, n.getContext(e), r)), r }(n, e ? e._root : null, i, [n.value]) }

    function vf(t, e, i) { const n = function(t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (n ? n.module.injector : i).get(t) }

    function wf(t, e, i) { const n = Pp(t),
            s = t.value;
        op(n, (t, n) => { wf(t, s.component ? e ? e.children.getContext(n) : null : e, i) }), i.canDeactivateChecks.push(new bf(s.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, s)) }
    const Cf = Symbol("INITIAL_VALUE");

    function xf() { return pm(t => Lu(...t.map(t => t.pipe(lm(1), bm(Cf)))).pipe(ym((t, e) => { let i = !1; return e.reduce((t, n, s) => { if (t !== Cf) return t; if (n === Cf && (i = !0), !i) { if (!1 === n) return n; if (s === e.length - 1 || af(n)) return n } return t }, t) }, Cf), Gu(t => t !== Cf), L(t => af(t) ? t : !0 === t), lm(1))) }

    function Sf(t, e) { return null !== t && e && e(new Gm(t)), Mu(!0) }

    function kf(t, e) { return null !== t && e && e(new Hm(t)), Mu(!0) }

    function Ef(t, e, i) { const n = e.routeConfig ? e.routeConfig.canActivate : null; return n && 0 !== n.length ? Mu(n.map(n => Hu(() => { const s = vf(n, e, i); let r; if (function(t) { return t && rf(t.canActivate) }(s)) r = lp(s.canActivate(e, t));
            else { if (!rf(s)) throw new Error("Invalid CanActivate guard");
                r = lp(s(e, t)) } return r.pipe(dm()) }))).pipe(xf()) : Mu(!0) }

    function Df(t, e, i) { const n = e[e.length - 1],
            s = e.slice(0, e.length - 1).reverse().map(t => function(t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => Hu(() => Mu(e.guards.map(s => { const r = vf(s, e.node, i); let a; if (function(t) { return t && rf(t.canActivateChild) }(r)) a = lp(r.canActivateChild(n, t));
                else { if (!rf(r)) throw new Error("Invalid CanActivateChild guard");
                    a = lp(r(n, t)) } return a.pipe(dm()) })).pipe(xf()))); return Mu(s).pipe(xf()) } class Af {} class If { constructor(t, e, i, n, s, r) { this.rootComponentType = t, this.config = e, this.urlTree = i, this.url = n, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = r } recognize() { try { const t = Rf(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup,
                    e = this.processSegmentGroup(this.config, t, "primary"),
                    i = new Vp([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, "primary", this.rootComponentType, null, this.urlTree.root, -1, {}),
                    n = new Mp(i, e),
                    s = new zp(this.url, n); return this.inheritParamsAndData(s._root), Mu(s) } catch (t) { return new v(e => e.error(t)) } } inheritParamsAndData(t) { const e = t.value,
                i = Bp(e, this.paramsInheritanceStrategy);
            e.params = Object.freeze(i.params), e.data = Object.freeze(i.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, i) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, i) } processChildren(t, e) { const i = pp(e, (e, i) => this.processSegmentGroup(t, e, i)); return function(t) { const e = {};
                t.forEach(t => { const i = e[t.value.outlet]; if (i) { const e = i.url.map(t => t.toString()).join("/"),
                            n = t.value.url.map(t => t.toString()).join("/"); throw new Error(`Two segments cannot have the same outlet name: '${e}' and '${n}'.`) } e[t.value.outlet] = t.value }) }(i), i.sort((t, e) => "primary" === t.value.outlet ? -1 : "primary" === e.value.outlet ? 1 : t.value.outlet.localeCompare(e.value.outlet)), i } processSegment(t, e, i, n) { for (const r of t) try { return this.processSegmentAgainstRoute(r, e, i, n) } catch (s) { if (!(s instanceof Af)) throw s }
            if (this.noLeftoversInUrl(e, i, n)) return []; throw new Af } noLeftoversInUrl(t, e, i) { return 0 === e.length && !t.children[i] } processSegmentAgainstRoute(t, e, i, n) { if (t.redirectTo) throw new Af; if ((t.outlet || "primary") !== n) throw new Af; let s, r = [],
                a = []; if ("**" === t.path) { const r = i.length > 0 ? ap(i).parameters : {};
                s = new Vp(i, r, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Ff(t), n, t.component, t, Tf(e), Of(e) + i.length, Nf(t)) } else { const o = function(t, e, i) { if ("" === e.path) { if ("full" === e.pathMatch && (t.hasChildren() || i.length > 0)) throw new Af; return { consumedSegments: [], lastChild: 0, parameters: {} } } const n = (e.matcher || Zm)(i, t, e); if (!n) throw new Af; const s = {};
                    op(n.posParams, (t, e) => { s[e] = t.path }); const r = n.consumed.length > 0 ? Object.assign(Object.assign({}, s), n.consumed[n.consumed.length - 1].parameters) : s; return { consumedSegments: n.consumed, lastChild: n.consumed.length, parameters: r } }(e, t, i);
                r = o.consumedSegments, a = i.slice(o.lastChild), s = new Vp(r, o.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Ff(t), n, t.component, t, Tf(e), Of(e) + r.length, Nf(t)) } const o = function(t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t),
                { segmentGroup: l, slicedSegments: c } = Rf(e, r, a, o, this.relativeLinkResolution); if (0 === c.length && l.hasChildren()) { const t = this.processChildren(o, l); return [new Mp(s, t)] } if (0 === o.length && 0 === c.length) return [new Mp(s, [])]; const h = this.processSegment(o, l, c, "primary"); return [new Mp(s, h)] } }

    function Tf(t) { let e = t; for (; e._sourceSegment;) e = e._sourceSegment; return e }

    function Of(t) { let e = t,
            i = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;) e = e._sourceSegment, i += e._segmentIndexShift ? e._segmentIndexShift : 0; return i - 1 }

    function Rf(t, e, i, n, s) { if (i.length > 0 && function(t, e, i) { return i.some(i => Mf(t, e, i) && "primary" !== Pf(i)) }(t, i, n)) { const s = new dp(e, function(t, e, i, n) { const s = {};
                s.primary = n, n._sourceSegment = t, n._segmentIndexShift = e.length; for (const r of i)
                    if ("" === r.path && "primary" !== Pf(r)) { const i = new dp([], {});
                        i._sourceSegment = t, i._segmentIndexShift = e.length, s[Pf(r)] = i } return s }(t, e, n, new dp(i, t.children))); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: [] } } if (0 === i.length && function(t, e, i) { return i.some(i => Mf(t, e, i)) }(t, i, n)) { const r = new dp(t.segments, function(t, e, i, n, s, r) { const a = {}; for (const o of n)
                    if (Mf(t, i, o) && !s[Pf(o)]) { const i = new dp([], {});
                        i._sourceSegment = t, i._segmentIndexShift = "legacy" === r ? t.segments.length : e.length, a[Pf(o)] = i } return Object.assign(Object.assign({}, s), a) }(t, e, i, n, t.children, s)); return r._sourceSegment = t, r._segmentIndexShift = e.length, { segmentGroup: r, slicedSegments: i } } const r = new dp(t.segments, t.children); return r._sourceSegment = t, r._segmentIndexShift = e.length, { segmentGroup: r, slicedSegments: i } }

    function Mf(t, e, i) { return (!(t.hasChildren() || e.length > 0) || "full" !== i.pathMatch) && "" === i.path && void 0 === i.redirectTo }

    function Pf(t) { return t.outlet || "primary" }

    function Ff(t) { return t.data || {} }

    function Nf(t) { return t.resolve || {} }

    function Lf(t, e, i, n) { const s = vf(t, e, n); return lp(s.resolve ? s.resolve(e, i) : s(e, i)) }

    function Bf(t) { return function(e) { return e.pipe(pm(e => { const i = t(e); return i ? U(i).pipe(L(() => e)) : U([e]) })) } } class Vf { shouldDetach(t) { return !1 } store(t, e) {} shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }
    const zf = new Vt("ROUTES"); class Uf { constructor(t, e, i, n) { this.loader = t, this.compiler = e, this.onLoadStartListener = i, this.onLoadEndListener = n } load(t, e) { return this.onLoadStartListener && this.onLoadStartListener(e), this.loadModuleFactory(e.loadChildren).pipe(L(i => { this.onLoadEndListener && this.onLoadEndListener(e); const n = i.create(t); return new Qm(rp(n.injector.get(zf)).map(ip), n) })) } loadModuleFactory(t) { return "string" == typeof t ? U(this.loader.load(t)) : lp(t()).pipe(H(t => t instanceof ee ? Mu(t) : U(this.compiler.compileModuleAsync(t)))) } } class Hf { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } }

    function jf(t) { throw t }

    function Gf(t, e, i) { return e.parse("/") }

    function $f(t, e) { return Mu(null) }
    let Wf = (() => { class t { constructor(t, e, i, n, s, r, a, o) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = i, this.location = n, this.config = o, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new k, this.errorHandler = jf, this.malformedUriErrorHandler = Gf, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: $f, afterPreactivation: $f }, this.urlHandlingStrategy = new Hf, this.routeReuseStrategy = new Vf, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "legacy", this.ngModule = s.get(te), this.console = s.get(vc); const l = s.get(Pc);
                this.isNgZoneEnabled = l instanceof Pc, this.resetConfig(o), this.currentUrlTree = new hp(new dp([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new Uf(r, a, t => this.triggerEvent(new zm(t)), t => this.triggerEvent(new Um(t))), this.routerState = Np(this.currentUrlTree, this.rootComponentType), this.transitions = new Pu({ id: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(Gu(t => 0 !== t.id), L(t => Object.assign(Object.assign({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), pm(t => { let i = !1,
                        n = !1; return Mu(t).pipe(Sm(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), pm(t => { const i = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || i) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return Mu(t).pipe(pm(t => { const i = this.transitions.getValue(); return e.next(new Om(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), i !== this.transitions.getValue() ? zu : [t] }), pm(t => Promise.resolve(t)), (n = this.ngModule.injector, s = this.configLoader, r = this.urlSerializer, a = this.config, function(t) { return t.pipe(pm(t => function(t, e, i, n, s) { return new uf(t, e, i, n, s).apply() }(n, s, r, t.extractedUrl, a).pipe(L(e => Object.assign(Object.assign({}, t), { urlAfterRedirects: e }))))) }), Sm(t => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: t.urlAfterRedirects }) }), function(t, e, i, n, s) { return function(r) { return r.pipe(H(r => function(t, e, i, n, s = "emptyOnly", r = "legacy") { return new If(t, e, i, n, s, r).recognize() }(t, e, r.urlAfterRedirects, i(r.urlAfterRedirects), n, s).pipe(L(t => Object.assign(Object.assign({}, r), { targetSnapshot: t }))))) } }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), Sm(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), Sm(t => { const i = new Fm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            e.next(i) })); var n, s, r, a; if (i && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: i, extractedUrl: n, source: s, restoredState: r, extras: a } = t, o = new Om(i, this.serializeUrl(n), s, r);
                            e.next(o); const l = Np(n, this.rootComponentType).snapshot; return Mu(Object.assign(Object.assign({}, t), { targetSnapshot: l, urlAfterRedirects: n, extras: Object.assign(Object.assign({}, a), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), zu }), Bf(t => { const { targetSnapshot: e, id: i, extractedUrl: n, rawUrl: s, extras: { skipLocationChange: r, replaceUrl: a } } = t; return this.hooks.beforePreactivation(e, { navigationId: i, appliedUrlTree: n, rawUrlTree: s, skipLocationChange: !!r, replaceUrl: !!a }) }), Sm(t => { const e = new Nm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                        this.triggerEvent(e) }), L(t => Object.assign(Object.assign({}, t), { guards: yf(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function(t, e) { return function(i) { return i.pipe(H(i => { const { targetSnapshot: n, currentSnapshot: s, guards: { canActivateChecks: r, canDeactivateChecks: a } } = i; return 0 === a.length && 0 === r.length ? Mu(Object.assign(Object.assign({}, i), { guardsResult: !0 })) : function(t, e, i, n) { return U(t).pipe(H(t => function(t, e, i, n, s) { const r = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return r && 0 !== r.length ? Mu(r.map(r => { const a = vf(r, e, s); let o; if (function(t) { return t && rf(t.canDeactivate) }(a)) o = lp(a.canDeactivate(t, e, i, n));
                                            else { if (!rf(a)) throw new Error("Invalid CanDeactivate guard");
                                                o = lp(a(t, e, i, n)) } return o.pipe(dm()) })).pipe(xf()) : Mu(!0) }(t.component, t.route, i, e, n)), dm(t => !0 !== t, !0)) }(a, n, s, t).pipe(H(i => i && "boolean" == typeof i ? function(t, e, i, n) { return U(e).pipe(Cm(e => U([kf(e.route.parent, n), Sf(e.route, n), Df(t, e.path, i), Ef(t, e.route, i)]).pipe(ju(), dm(t => !0 !== t, !0))), dm(t => !0 !== t, !0)) }(n, r, t, e) : Mu(i)), L(t => Object.assign(Object.assign({}, i), { guardsResult: t }))) })) } }(this.ngModule.injector, t => this.triggerEvent(t)), Sm(t => { if (af(t.guardsResult)) { const e = Km(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } }), Sm(t => { const e = new Lm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
                        this.triggerEvent(e) }), Gu(t => { if (!t.guardsResult) { this.resetUrlToCurrentUrlTree(); const i = new Mm(t.id, this.serializeUrl(t.extractedUrl), ""); return e.next(i), t.resolve(!1), !1 } return !0 }), Bf(t => { if (t.guards.canActivateChecks.length) return Mu(t).pipe(Sm(t => { const e = new Bm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            this.triggerEvent(e) }), (e = this.paramsInheritanceStrategy, i = this.ngModule.injector, function(t) { return t.pipe(H(t => { const { targetSnapshot: n, guards: { canActivateChecks: s } } = t; return s.length ? U(s).pipe(Cm(t => function(t, e, i, n) { return function(t, e, i, n) { const s = Object.keys(t); if (0 === s.length) return Mu({}); if (1 === s.length) { const r = s[0]; return Lf(t[r], e, i, n).pipe(L(t => ({
                                                [r]: t }))) } const r = {}; return U(s).pipe(H(s => Lf(t[s], e, i, n).pipe(L(t => (r[s] = t, t))))).pipe(sm(), L(() => r)) }(t._resolve, t, e, n).pipe(L(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), Bp(t, i).resolve), null))) }(t.route, n, e, i)), function(t, e) { return arguments.length >= 2 ? function(i) { return b(ym(t, e), Yu(1), em(e))(i) } : function(e) { return b(ym((e, i, n) => t(e, i, n + 1)), Yu(1))(e) } }((t, e) => t), L(e => t)) : Mu(t) })) }), Sm(t => { const e = new Vm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            this.triggerEvent(e) })); var e, i }), Bf(t => { const { targetSnapshot: e, id: i, extractedUrl: n, rawUrl: s, extras: { skipLocationChange: r, replaceUrl: a } } = t; return this.hooks.afterPreactivation(e, { navigationId: i, appliedUrlTree: n, rawUrlTree: s, skipLocationChange: !!r, replaceUrl: !!a }) }), L(t => { const e = function(t, e, i) { const n = function t(e, i, n) { if (n && e.shouldReuseRoute(i.value, n.value.snapshot)) { const s = n.value;
                                    s._futureSnapshot = i.value; const r = function(e, i, n) { return i.children.map(i => { for (const s of n.children)
                                                if (e.shouldReuseRoute(s.value.snapshot, i.value)) return t(e, i, s); return t(e, i) }) }(e, i, n); return new Mp(s, r) } { const n = e.retrieve(i.value); if (n) { const t = n.route; return function t(e, i) { if (e.value.routeConfig !== i.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (e.children.length !== i.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");
                                            i.value._futureSnapshot = e.value; for (let n = 0; n < e.children.length; ++n) t(e.children[n], i.children[n]) }(i, t), t } { const n = new Lp(new Pu((s = i.value).url), new Pu(s.params), new Pu(s.queryParams), new Pu(s.fragment), new Pu(s.data), s.outlet, s.component, s),
                                            r = i.children.map(i => t(e, i)); return new Mp(n, r) } } var s }(t, e._root, i ? i._root : void 0); return new Fp(n, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign(Object.assign({}, t), { targetRouterState: e }) }), Sm(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), (s = this.rootContexts, r = this.routeReuseStrategy, a = t => this.triggerEvent(t), L(t => (new nf(r, t.targetRouterState, t.currentRouterState, a).activate(s), t))), Sm({ next() { i = !0 }, complete() { i = !0 } }), Dm(() => { if (!i && !n) { this.resetUrlToCurrentUrlTree(); const i = new Mm(t.id, this.serializeUrl(t.extractedUrl), `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);
                            e.next(i), t.resolve(!1) } this.currentNavigation = null }), rm(i => { if (n = !0, (s = i) && s.ngNavigationCancelingError) { const n = af(i.url);
                            n || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const s = new Mm(t.id, this.serializeUrl(t.extractedUrl), i.message);
                            e.next(s), n ? setTimeout(() => { const e = this.urlHandlingStrategy.merge(i.url, this.rawUrlTree); return this.scheduleNavigation(e, "imperative", null, { skipLocationChange: t.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: t.resolve, reject: t.reject, promise: t.promise }) }, 0) : t.resolve(!1) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const n = new Pm(t.id, this.serializeUrl(t.extractedUrl), i);
                            e.next(n); try { t.resolve(this.errorHandler(i)) } catch (r) { t.reject(r) } } var s; return zu })); var s, r, a })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { let e = this.parseUrl(t.url); const i = "popstate" === t.type ? "popstate" : "hashchange",
                        n = t.state && t.state.navigationId ? t.state : null;
                    setTimeout(() => { this.scheduleNavigation(e, i, n, { replaceUrl: !0 }) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { Jm(t), this.config = t.map(ip), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = null) } createUrlTree(t, e = {}) { const { relativeTo: i, queryParams: n, fragment: s, preserveQueryParams: r, queryParamsHandling: a, preserveFragment: o } = e;
                Sn() && r && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."); const l = i || this.routerState.root,
                    c = o ? this.currentUrlTree.fragment : s; let h = null; if (a) switch (a) {
                    case "merge":
                        h = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), n); break;
                    case "preserve":
                        h = this.currentUrlTree.queryParams; break;
                    default:
                        h = n || null } else h = r ? this.currentUrlTree.queryParams : n || null; return null !== h && (h = this.removeEmptyProps(h)),
                    function(t, e, i, n, s) { if (0 === i.length) return Wp(e.root, e.root, e, n, s); const r = function(t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new qp(!0, 0, t); let e = 0,
                                i = !1; const n = t.reduce((t, n, s) => { if ("object" == typeof n && null != n) { if (n.outlets) { const e = {}; return op(n.outlets, (t, i) => { e[i] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (n.segmentPath) return [...t, n.segmentPath] } return "string" != typeof n ? [...t, n] : 0 === s ? (n.split("/").forEach((n, s) => { 0 == s && "." === n || (0 == s && "" === n ? i = !0 : ".." === n ? e++ : "" != n && t.push(n)) }), t) : [...t, n] }, []); return new qp(i, e, n) }(i); if (r.toRoot()) return Wp(e.root, new dp([], {}), e, n, s); const a = function(t, e, i) { if (t.isAbsolute) return new Yp(e.root, !0, 0); if (-1 === i.snapshot._lastPathIndex) return new Yp(i.snapshot._urlSegment, !0, 0); const n = $p(t.commands[0]) ? 0 : 1; return function(t, e, i) { let n = t,
                                        s = e,
                                        r = i; for (; r > s;) { if (r -= s, n = n.parent, !n) throw new Error("Invalid number of '../'");
                                        s = n.segments.length } return new Yp(n, !1, s - r) }(i.snapshot._urlSegment, i.snapshot._lastPathIndex + n, t.numberOfDoubleDots) }(r, e, t),
                            o = a.processChildren ? Zp(a.segmentGroup, a.index, r.commands) : Kp(a.segmentGroup, a.index, r.commands); return Wp(a.segmentGroup, o, e, n, s) }(l, this.currentUrlTree, t, h, c) } navigateByUrl(t, e = { skipLocationChange: !1 }) { Sn() && this.isNgZoneEnabled && !Pc.isInAngularZone() && this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?"); const i = af(t) ? t : this.parseUrl(t),
                    n = this.urlHandlingStrategy.merge(i, this.rawUrlTree); return this.scheduleNavigation(n, "imperative", null, e) } navigate(t, e = { skipLocationChange: !1 }) { return function(t) { for (let e = 0; e < t.length; e++) { const i = t[e]; if (null == i) throw new Error(`The requested path contains ${i} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (i) { e = this.malformedUriErrorHandler(i, this.urlSerializer, t) } return e } isActive(t, e) { if (af(t)) return cp(this.currentUrlTree, t, e); const i = this.parseUrl(t); return cp(this.currentUrlTree, i, e) } removeEmptyProps(t) { return Object.keys(t).reduce((e, i) => { const n = t[i]; return null != n && (e[i] = n), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.events.next(new Rm(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.currentNavigation = null, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, i, n, s) { const r = this.getTransition(); if (r && "imperative" !== e && "imperative" === r.source && r.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (r && "hashchange" == e && "popstate" === r.source && r.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (r && "popstate" == e && "hashchange" === r.source && r.rawUrl.toString() === t.toString()) return Promise.resolve(!0); let a, o, l;
                s ? (a = s.resolve, o = s.reject, l = s.promise) : l = new Promise((t, e) => { a = t, o = e }); const c = ++this.navigationId; return this.setTransition({ id: c, source: e, restoredState: i, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: n, resolve: a, reject: o, promise: l, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), l.catch(t => Promise.reject(t)) } setBrowserUrl(t, e, i, n) { const s = this.urlSerializer.serialize(t);
                n = n || {}, this.location.isCurrentPathEqualTo(s) || e ? this.location.replaceState(s, "", Object.assign(Object.assign({}, n), { navigationId: i })) : this.location.go(s, "", Object.assign(Object.assign({}, n), { navigationId: i })) } resetStateAndUrl(t, e, i) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, i), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", { navigationId: this.lastSuccessfulId }) } } return t.\u0275fac = function(t) { Ea() }, t.\u0275dir = we({ type: t }), t })(), qf = (() => { class t { constructor(t, e, i, n, s) { this.router = t, this.route = e, this.commands = [], null == i && n.setAttribute(s.nativeElement, "tabindex", "0") } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } set preserveQueryParams(t) { Sn() && console && console.warn && console.warn("preserveQueryParams is deprecated!, use queryParamsHandling instead."), this.preserve = t } onClick() { const t = { skipLocationChange: Xf(this.skipLocationChange), replaceUrl: Xf(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, t), !0 } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, preserveQueryParams: Xf(this.preserve), queryParamsHandling: this.queryParamsHandling, preserveFragment: Xf(this.preserveFragment) }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wf), Sa(Lp), ka("tabindex"), Sa(Ko), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "routerLink", "", 5, "a", 5, "area"]
            ], hostBindings: function(t, e) { 1 & t && Ba("click", (function() { return e.onClick() })) }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" } }), t })(), Yf = (() => { class t { constructor(t, e, i) { this.router = t, this.route = e, this.locationStrategy = i, this.commands = [], this.subscription = t.events.subscribe(t => { t instanceof Rm && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } set preserveQueryParams(t) { Sn() && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."), this.preserve = t } ngOnChanges(t) { this.updateTargetUrlAndHref() } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, i, n) { if (0 !== t || e || i || n) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const s = { skipLocationChange: Xf(this.skipLocationChange), replaceUrl: Xf(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, s), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, preserveQueryParams: Xf(this.preserve), queryParamsHandling: this.queryParamsHandling, preserveFragment: Xf(this.preserveFragment) }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wf), Sa(Lp), Sa(Ch)) }, t.\u0275dir = we({ type: t, selectors: [
                ["a", "routerLink", ""],
                ["area", "routerLink", ""]
            ], hostVars: 2, hostBindings: function(t, e) { 1 & t && Ba("click", (function(t) { return e.onClick(t.button, t.ctrlKey, t.metaKey, t.shiftKey) })), 2 & t && (xo("href", e.href, Zn), va("target", e.target)) }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" }, features: [Ro] }), t })();

    function Xf(t) { return "" === t || !!t }
    let Kf = (() => { class t { constructor(t, e, i, n, s) { this.router = t, this.element = e, this.renderer = i, this.link = n, this.linkWithHref = s, this.classes = [], this.isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.subscription = t.events.subscribe(t => { t instanceof Rm && this.update() }) } ngAfterContentInit() { this.links.changes.subscribe(t => this.update()), this.linksWithHrefs.changes.subscribe(t => this.update()), this.update() } set routerLinkActive(t) { const e = Array.isArray(t) ? t : t.split(" ");
                this.classes = e.filter(t => !!t) } ngOnChanges(t) { this.update() } ngOnDestroy() { this.subscription.unsubscribe() } update() { this.links && this.linksWithHrefs && this.router.navigated && Promise.resolve().then(() => { const t = this.hasActiveLinks();
                    this.isActive !== t && (this.isActive = t, this.classes.forEach(e => { t ? this.renderer.addClass(this.element.nativeElement, e) : this.renderer.removeClass(this.element.nativeElement, e) })) }) } isLinkActive(t) { return e => t.isActive(e.urlTree, this.routerLinkActiveOptions.exact) } hasActiveLinks() { const t = this.isLinkActive(this.router); return this.link && t(this.link) || this.linkWithHref && t(this.linkWithHref) || this.links.some(t) || this.linksWithHrefs.some(t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wf), Sa(Wo), Sa(Ko), Sa(qf, 8), Sa(Yf, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "routerLinkActive", ""]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, qf, !0), sc(i, Yf, !0)), 2 & t && (tc(n = oc()) && (e.links = n), tc(n = oc()) && (e.linksWithHrefs = n)) }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", routerLinkActive: "routerLinkActive" }, exportAs: ["routerLinkActive"], features: [Ro] }), t })(); class Zf { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Qf, this.attachRef = null } } class Qf { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const i = this.getOrCreateContext(t);
            i.outlet = e, this.contexts.set(t, i) } onChildOutletDestroyed(t) { const e = this.getContext(t);
            e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new Zf, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } }
    let Jf = (() => { class t { constructor(t, e, i, n, s) { this.parentContexts = t, this.location = e, this.resolver = i, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new jl, this.deactivateEvents = new jl, this.name = n || "primary", t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name);
                    t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated");
                this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component;
                    this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet");
                this._activatedRoute = t; const i = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component),
                    n = this.parentContexts.getOrCreateContext(this.name).children,
                    s = new tg(t, n, this.location.injector);
                this.activated = this.location.createComponent(i, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Qf), Sa(bl), Sa($o), ka("name"), Sa(jr)) }, t.\u0275dir = we({ type: t, selectors: [
                ["router-outlet"]
            ], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), t })(); class tg { constructor(t, e, i) { this.route = t, this.childContexts = e, this.parent = i } get(t, e) { return t === Lp ? this.route : t === Qf ? this.childContexts : this.parent.get(t, e) } } class eg {} class ig { preload(t, e) { return Mu(null) } }
    let ng = (() => { class t { constructor(t, e, i, n, s) { this.router = t, this.injector = n, this.preloadingStrategy = s, this.loader = new Uf(e, i, e => t.triggerEvent(new zm(e)), e => t.triggerEvent(new Um(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(Gu(t => t instanceof Rm), Cm(() => this.preload())).subscribe(() => {}) } preload() { const t = this.injector.get(te); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription.unsubscribe() } processRoutes(t, e) { const i = []; for (const n of e)
                    if (n.loadChildren && !n.canLoad && n._loadedConfig) { const t = n._loadedConfig;
                        i.push(this.processRoutes(t.module, t.routes)) } else n.loadChildren && !n.canLoad ? i.push(this.preloadConfig(t, n)) : n.children && i.push(this.processRoutes(t, n.children)); return U(i).pipe($(), L(t => {})) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => this.loader.load(t.injector, e).pipe(H(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Wf), Xt(ih), Xt(Tc), Xt(ra), Xt(eg)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), sg = (() => { class t { constructor(t, e, i = {}) { this.router = t, this.viewportScroller = e, this.options = i, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, i.scrollPositionRestoration = i.scrollPositionRestoration || "disabled", i.anchorScrolling = i.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof Om ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof Rm && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof Wm && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new Wm(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function(t) { Ea() }, t.\u0275dir = we({ type: t }), t })();
    const rg = new Vt("ROUTER_CONFIGURATION"), ag = new Vt("ROUTER_FORROOT_GUARD"), og = [Dh, { provide: fp, useClass: gp }, { provide: Wf, useFactory: function(t, e, i, n, s, r, a, o = {}, l, c) { const h = new Wf(null, t, e, i, n, s, r, rp(a)); if (l && (h.urlHandlingStrategy = l), c && (h.routeReuseStrategy = c), o.errorHandler && (h.errorHandler = o.errorHandler), o.malformedUriErrorHandler && (h.malformedUriErrorHandler = o.malformedUriErrorHandler), o.enableTracing) { const t = dh();
                h.events.subscribe(e => { t.logGroup(`Router Event: ${e.constructor.name}`), t.log(e.toString()), t.log(e), t.logGroupEnd() }) } return o.onSameUrlNavigation && (h.onSameUrlNavigation = o.onSameUrlNavigation), o.paramsInheritanceStrategy && (h.paramsInheritanceStrategy = o.paramsInheritanceStrategy), o.urlUpdateStrategy && (h.urlUpdateStrategy = o.urlUpdateStrategy), o.relativeLinkResolution && (h.relativeLinkResolution = o.relativeLinkResolution), h }, deps: [fp, Qf, Dh, ra, ih, Tc, zf, rg, [class {}, new rt],
            [class {}, new rt]
        ] }, Qf, { provide: Lp, useFactory: function(t) { return t.routerState.root }, deps: [Wf] }, { provide: ih, useClass: rh }, ng, ig, class { preload(t, e) { return e().pipe(rm(() => Mu(null))) } }, { provide: rg, useValue: { enableTracing: !1 } }];

    function lg() { return new Xc("Router", Wf) }
    let cg = (() => { class t { constructor(t, e) {} static forRoot(e, i) { return { ngModule: t, providers: [og, mg(e), { provide: ag, useFactory: ug, deps: [
                                [Wf, new rt, new ot]
                            ] }, { provide: rg, useValue: i || {} }, { provide: Ch, useFactory: dg, deps: [mh, [new st(Sh), new rt], rg] }, { provide: sg, useFactory: hg, deps: [Wf, eu, rg] }, { provide: eg, useExisting: i && i.preloadingStrategy ? i.preloadingStrategy : ig }, { provide: Xc, multi: !0, useFactory: lg },
                        [pg, { provide: uc, multi: !0, useFactory: fg, deps: [pg] }, { provide: _g, useFactory: gg, deps: [pg] }, { provide: yc, multi: !0, useExisting: _g }]
                    ] } } static forChild(e) { return { ngModule: t, providers: [mg(e)] } } } return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t)(Xt(ag, 8), Xt(Wf, 8)) } }), t })();

    function hg(t, e, i) { return i.scrollOffset && e.setOffset(i.scrollOffset), new sg(t, e, i) }

    function dg(t, e, i = {}) { return i.useHash ? new Eh(t, e) : new kh(t, e) }

    function ug(t) { if (t) throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead."); return "guarded" }

    function mg(t) { return [{ provide: aa, multi: !0, useValue: t }, { provide: zf, multi: !0, useValue: t }] }
    let pg = (() => { class t { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new k } appInitializer() { return this.injector.get(fh, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e),
                        i = this.injector.get(Wf),
                        n = this.injector.get(rg); if (this.isLegacyDisabled(n) || this.isLegacyEnabled(n)) t(!0);
                    else if ("disabled" === n.initialNavigation) i.setUpLocationChangeListener(), t(!0);
                    else { if ("enabled" !== n.initialNavigation) throw new Error(`Invalid initialNavigation options: '${n.initialNavigation}'`);
                        i.hooks.afterPreactivation = () => this.initNavigation ? Mu(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), i.initialNavigation() } return e }) } bootstrapListener(t) { const e = this.injector.get(rg),
                    i = this.injector.get(ng),
                    n = this.injector.get(sg),
                    s = this.injector.get(Wf),
                    r = this.injector.get(th);
                t === r.components[0] && (this.isLegacyEnabled(e) ? s.initialNavigation() : this.isLegacyDisabled(e) && s.setUpLocationChangeListener(), i.setUpPreloading(), n.init(), s.resetRootComponentType(r.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } isLegacyEnabled(t) { return "legacy_enabled" === t.initialNavigation || !0 === t.initialNavigation || void 0 === t.initialNavigation } isLegacyDisabled(t) { return "legacy_disabled" === t.initialNavigation || !1 === t.initialNavigation } } return t.\u0275fac = function(e) { return new(e || t)(Xt(ra)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();

    function fg(t) { return t.appInitializer.bind(t) }

    function gg(t) { return t.bootstrapListener.bind(t) }
    const _g = new Vt("Router Initializer");

    function bg(...t) { if (1 === t.length) { const e = t[0]; if (l(e)) return yg(e, null); if (c(e) && Object.getPrototypeOf(e) === Object.prototype) { const t = Object.keys(e); return yg(t.map(t => e[t]), t) } } if ("function" == typeof t[t.length - 1]) { const e = t.pop(); return yg(t = 1 === t.length && l(t[0]) ? t[0] : t, null).pipe(L(t => e(...t))) } return yg(t, null) }

    function yg(t, e) { return new v(i => { const n = t.length; if (0 === n) return void i.complete(); const s = new Array(n); let r = 0,
                a = 0; for (let o = 0; o < n; o++) { const l = U(t[o]); let c = !1;
                i.add(l.subscribe({ next: t => { c || (c = !0, a++), s[o] = t }, error: t => i.error(t), complete: () => { r++, r !== n && c || (a === n && i.next(e ? e.reduce((t, e, i) => (t[e] = s[i], t), {}) : s), i.complete()) } })) } }) }
    const vg = new Vt("NgValueAccessor"), wg = { provide: vg, useExisting: St(() => Cg), multi: !0 };
    let Cg = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => {}, this.onTouched = () => {} } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "checked", t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Ko), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "type", "checkbox", "formControlName", ""],
                ["input", "type", "checkbox", "formControl", ""],
                ["input", "type", "checkbox", "ngModel", ""]
            ], hostBindings: function(t, e) { 1 & t && Ba("change", (function(t) { return e.onChange(t.target.checked) }))("blur", (function() { return e.onTouched() })) }, features: [Ho([wg])] }), t })();
    const xg = { provide: vg, useExisting: St(() => kg), multi: !0 }, Sg = new Vt("CompositionEventMode");
    let kg = (() => { class t { constructor(t, e, i) { this._renderer = t, this._elementRef = e, this._compositionMode = i, this.onChange = t => {}, this.onTouched = () => {}, this._composing = !1, null == this._compositionMode && (this._compositionMode = ! function() { const t = dh() ? dh().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _handleInput(t) {
                (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Ko), Sa(Wo), Sa(Sg, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "formControlName", "", 3, "type", "checkbox"],
                ["textarea", "formControlName", ""],
                ["input", "formControl", "", 3, "type", "checkbox"],
                ["textarea", "formControl", ""],
                ["input", "ngModel", "", 3, "type", "checkbox"],
                ["textarea", "ngModel", ""],
                ["", "ngDefaultControl", ""]
            ], hostBindings: function(t, e) { 1 & t && Ba("input", (function(t) { return e._handleInput(t.target.value) }))("blur", (function() { return e.onTouched() }))("compositionstart", (function() { return e._compositionStart() }))("compositionend", (function(t) { return e._compositionEnd(t.target.value) })) }, features: [Ho([xg])] }), t })(), Eg = (() => { class t { get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t }), t })(), Dg = (() => { class t extends Eg { get formDirective() { return null } get path() { return null } } return t.\u0275fac = function(e) { return Ag(e || t) }, t.\u0275dir = we({ type: t, features: [Eo] }), t })();
    const Ag = ln(Dg);

    function Ig() { throw new Error("unimplemented") } class Tg extends Eg { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null, this._rawValidators = [], this._rawAsyncValidators = [] } get validator() { return Ig() } get asyncValidator() { return Ig() } } class Og { constructor(t) { this._cd = t } get ngClassUntouched() { return !!this._cd.control && this._cd.control.untouched } get ngClassTouched() { return !!this._cd.control && this._cd.control.touched } get ngClassPristine() { return !!this._cd.control && this._cd.control.pristine } get ngClassDirty() { return !!this._cd.control && this._cd.control.dirty } get ngClassValid() { return !!this._cd.control && this._cd.control.valid } get ngClassInvalid() { return !!this._cd.control && this._cd.control.invalid } get ngClassPending() { return !!this._cd.control && this._cd.control.pending } }
    let Rg = (() => { class t extends Og { constructor(t) { super(t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Tg, 2)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "formControlName", ""],
                ["", "ngModel", ""],
                ["", "formControl", ""]
            ], hostVars: 14, hostBindings: function(t, e) { 2 & t && no("ng-untouched", e.ngClassUntouched)("ng-touched", e.ngClassTouched)("ng-pristine", e.ngClassPristine)("ng-dirty", e.ngClassDirty)("ng-valid", e.ngClassValid)("ng-invalid", e.ngClassInvalid)("ng-pending", e.ngClassPending) }, features: [Eo] }), t })(), Mg = (() => { class t extends Og { constructor(t) { super(t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Dg, 2)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "formGroupName", ""],
                ["", "formArrayName", ""],
                ["", "ngModelGroup", ""],
                ["", "formGroup", ""],
                ["form", 3, "ngNoForm", ""],
                ["", "ngForm", ""]
            ], hostVars: 14, hostBindings: function(t, e) { 2 & t && no("ng-untouched", e.ngClassUntouched)("ng-touched", e.ngClassTouched)("ng-pristine", e.ngClassPristine)("ng-dirty", e.ngClassDirty)("ng-valid", e.ngClassValid)("ng-invalid", e.ngClassInvalid)("ng-pending", e.ngClassPending) }, features: [Eo] }), t })();

    function Pg(t) { return null == t || 0 === t.length }
    const Fg = new Vt("NgValidators"), Ng = new Vt("NgAsyncValidators"), Lg = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class Bg { static min(t) { return e => { if (Pg(e.value) || Pg(t)) return null; const i = parseFloat(e.value); return !isNaN(i) && i < t ? { min: { min: t, actual: e.value } } : null } } static max(t) { return e => { if (Pg(e.value) || Pg(t)) return null; const i = parseFloat(e.value); return !isNaN(i) && i > t ? { max: { max: t, actual: e.value } } : null } } static required(t) { return Pg(t.value) ? { required: !0 } : null } static requiredTrue(t) { return !0 === t.value ? null : { required: !0 } } static email(t) { return Pg(t.value) || Lg.test(t.value) ? null : { email: !0 } } static minLength(t) { return e => { if (Pg(e.value)) return null; const i = e.value ? e.value.length : 0; return i < t ? { minlength: { requiredLength: t, actualLength: i } } : null } } static maxLength(t) { return e => { const i = e.value ? e.value.length : 0; return i > t ? { maxlength: { requiredLength: t, actualLength: i } } : null } } static pattern(t) { if (!t) return Bg.nullValidator; let e, i; return "string" == typeof t ? (i = "", "^" !== t.charAt(0) && (i += "^"), i += t, "$" !== t.charAt(t.length - 1) && (i += "$"), e = new RegExp(i)) : (i = t.toString(), e = t), t => { if (Pg(t.value)) return null; const n = t.value; return e.test(n) ? null : { pattern: { requiredPattern: i, actualValue: n } } } } static nullValidator(t) { return null } static compose(t) { if (!t) return null; const e = t.filter(Vg); return 0 == e.length ? null : function(t) { return Ug(function(t, e) { return e.map(e => e(t)) }(t, e)) } } static composeAsync(t) { if (!t) return null; const e = t.filter(Vg); return 0 == e.length ? null : function(t) { return bg(function(t, e) { return e.map(e => e(t)) }(t, e).map(zg)).pipe(L(Ug)) } } }

    function Vg(t) { return null != t }

    function zg(t) { const e = Na(t) ? U(t) : t; if (!La(e)) throw new Error("Expected validator to return Promise or Observable."); return e }

    function Ug(t) { let e = {}; return t.forEach(t => { e = null != t ? Object.assign(Object.assign({}, e), t) : e }), 0 === Object.keys(e).length ? null : e }

    function Hg(t) { return t.validate ? e => t.validate(e) : t }

    function jg(t) { return t.validate ? e => t.validate(e) : t }
    const Gg = { provide: vg, useExisting: St(() => $g), multi: !0 };
    let $g = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => {}, this.onTouched = () => {} } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t) } registerOnChange(t) { this.onChange = e => { t("" == e ? null : parseFloat(e)) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Ko), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "type", "number", "formControlName", ""],
                ["input", "type", "number", "formControl", ""],
                ["input", "type", "number", "ngModel", ""]
            ], hostBindings: function(t, e) { 1 & t && Ba("change", (function(t) { return e.onChange(t.target.value) }))("input", (function(t) { return e.onChange(t.target.value) }))("blur", (function() { return e.onTouched() })) }, features: [Ho([Gg])] }), t })();
    const Wg = { provide: vg, useExisting: St(() => Yg), multi: !0 };
    let qg = (() => { class t { constructor() { this._accessors = [] } add(t, e) { this._accessors.push([t, e]) } remove(t) { for (let e = this._accessors.length - 1; e >= 0; --e)
                    if (this._accessors[e][1] === t) return void this._accessors.splice(e, 1) } select(t) { this._accessors.forEach(e => { this._isSameGroup(e, t) && e[1] !== t && e[1].fireUncheck(t.value) }) } _isSameGroup(t, e) { return !!t[0].control && t[0]._parent === e._control._parent && t[1].name === e.name } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Yg = (() => { class t { constructor(t, e, i, n) { this._renderer = t, this._elementRef = e, this._registry = i, this._injector = n, this.onChange = () => {}, this.onTouched = () => {} } ngOnInit() { this._control = this._injector.get(Tg), this._checkName(), this._registry.add(this._control, this) } ngOnDestroy() { this._registry.remove(this) } writeValue(t) { this._state = t === this.value, this._renderer.setProperty(this._elementRef.nativeElement, "checked", this._state) } registerOnChange(t) { this._fn = t, this.onChange = () => { t(this.value), this._registry.select(this) } } fireUncheck(t) { this.writeValue(t) } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _checkName() { this.name && this.formControlName && this.name !== this.formControlName && this._throwNameError(), !this.name && this.formControlName && (this.name = this.formControlName) } _throwNameError() { throw new Error('\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type="radio" formControlName="food" name="food">\n    ') } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Ko), Sa(Wo), Sa(qg), Sa(ra)) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "type", "radio", "formControlName", ""],
                ["input", "type", "radio", "formControl", ""],
                ["input", "type", "radio", "ngModel", ""]
            ], hostBindings: function(t, e) { 1 & t && Ba("change", (function() { return e.onChange() }))("blur", (function() { return e.onTouched() })) }, inputs: { name: "name", formControlName: "formControlName", value: "value" }, features: [Ho([Wg])] }), t })();
    const Xg = { provide: vg, useExisting: St(() => Kg), multi: !0 };
    let Kg = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => {}, this.onTouched = () => {} } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", parseFloat(t)) } registerOnChange(t) { this.onChange = e => { t("" == e ? null : parseFloat(e)) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Ko), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "type", "range", "formControlName", ""],
                ["input", "type", "range", "formControl", ""],
                ["input", "type", "range", "ngModel", ""]
            ], hostBindings: function(t, e) { 1 & t && Ba("change", (function(t) { return e.onChange(t.target.value) }))("input", (function(t) { return e.onChange(t.target.value) }))("blur", (function() { return e.onTouched() })) }, features: [Ho([Xg])] }), t })();
    const Zg = '\n    <div [formGroup]="myGroup">\n      <input formControlName="firstName">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });', Qg = '\n    <div [formGroup]="myGroup">\n       <div formGroupName="person">\n          <input formControlName="firstName">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });', Jg = '\n    <form>\n       <div ngModelGroup="person">\n          <input [(ngModel)]="person.name" name="firstName">\n       </div>\n    </form>'; class t_ { static controlParentException() { throw new Error(`formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${Zg}`) } static ngModelGroupException() { throw new Error(`formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a "form" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        ${Qg}\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        ${Jg}`) } static missingFormException() { throw new Error(`formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       ${Zg}`) } static groupParentException() { throw new Error(`formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${Qg}`) } static arrayParentException() { throw new Error('formArrayName must be used with a parent formGroup directive.  You\'ll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        \n    <div [formGroup]="myGroup">\n      <div formArrayName="cities">\n        <div *ngFor="let city of cityArray.controls; index as i">\n          <input [formControlName]="i">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl(\'SF\')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });') } static disabledAttrWarning() { console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ") } static ngModelWarning(t) { console.warn(`\n    It looks like you're using ngModel on the same form field as ${t}. \n    Support for using the ngModel input property and ngModelChange event with \n    reactive form directives has been deprecated in Angular v6 and will be removed \n    in Angular v7.\n    \n    For more information on this, see our API docs here:\n    https://angular.io/api/forms/${"formControl"===t?"FormControlDirective":"FormControlName"}#use-with-ngmodel\n    `) } }
    const e_ = { provide: vg, useExisting: St(() => n_), multi: !0 };

    function i_(t, e) { return null == t ? `${e}` : (e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) }
    let n_ = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => {}, this.onTouched = () => {}, this._compareWith = ma } set compareWith(t) { if ("function" != typeof t) throw new Error(`compareWith must be a function, but received ${JSON.stringify(t)}`);
                this._compareWith = t } writeValue(t) { this.value = t; const e = this._getOptionId(t);
                null == e && this._renderer.setProperty(this._elementRef.nativeElement, "selectedIndex", -1); const i = i_(e, t);
                this._renderer.setProperty(this._elementRef.nativeElement, "value", i) } registerOnChange(t) { this.onChange = e => { this.value = this._getOptionValue(e), t(this.value) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys()))
                    if (this._compareWith(this._optionMap.get(e), t)) return e; return null } _getOptionValue(t) { const e = function(t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e) : t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Ko), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["select", "formControlName", "", 3, "multiple", ""],
                ["select", "formControl", "", 3, "multiple", ""],
                ["select", "ngModel", "", 3, "multiple", ""]
            ], hostBindings: function(t, e) { 1 & t && Ba("change", (function(t) { return e.onChange(t.target.value) }))("blur", (function() { return e.onTouched() })) }, inputs: { compareWith: "compareWith" }, features: [Ho([e_])] }), t })(), s_ = (() => { class t { constructor(t, e, i) { this._element = t, this._renderer = e, this._select = i, this._select && (this.id = this._select._registerOption()) } set ngValue(t) { null != this._select && (this._select._optionMap.set(this.id, t), this._setElementValue(i_(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._setElementValue(t), this._select && this._select.writeValue(this._select.value) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Ko), Sa(n_, 9)) }, t.\u0275dir = we({ type: t, selectors: [
                ["option"]
            ], inputs: { ngValue: "ngValue", value: "value" } }), t })();
    const r_ = { provide: vg, useExisting: St(() => o_), multi: !0 };

    function a_(t, e) { return null == t ? `${e}` : ("string" == typeof e && (e = `'${e}'`), e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) }
    let o_ = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => {}, this.onTouched = () => {}, this._compareWith = ma } set compareWith(t) { if ("function" != typeof t) throw new Error(`compareWith must be a function, but received ${JSON.stringify(t)}`);
                this._compareWith = t } writeValue(t) { let e; if (this.value = t, Array.isArray(t)) { const i = t.map(t => this._getOptionId(t));
                    e = (t, e) => { t._setSelected(i.indexOf(e.toString()) > -1) } } else e = (t, e) => { t._setSelected(!1) };
                this._optionMap.forEach(e) } registerOnChange(t) { this.onChange = e => { const i = []; if (e.hasOwnProperty("selectedOptions")) { const t = e.selectedOptions; for (let e = 0; e < t.length; e++) { const n = t.item(e),
                                s = this._getOptionValue(n.value);
                            i.push(s) } } else { const t = e.options; for (let e = 0; e < t.length; e++) { const n = t.item(e); if (n.selected) { const t = this._getOptionValue(n.value);
                                i.push(t) } } } this.value = i, t(i) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption(t) { const e = (this._idCounter++).toString(); return this._optionMap.set(e, t), e } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys()))
                    if (this._compareWith(this._optionMap.get(e)._value, t)) return e; return null } _getOptionValue(t) { const e = function(t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e)._value : t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Ko), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["select", "multiple", "", "formControlName", ""],
                ["select", "multiple", "", "formControl", ""],
                ["select", "multiple", "", "ngModel", ""]
            ], hostBindings: function(t, e) { 1 & t && Ba("change", (function(t) { return e.onChange(t.target) }))("blur", (function() { return e.onTouched() })) }, inputs: { compareWith: "compareWith" }, features: [Ho([r_])] }), t })(), l_ = (() => { class t { constructor(t, e, i) { this._element = t, this._renderer = e, this._select = i, this._select && (this.id = this._select._registerOption(this)) } set ngValue(t) { null != this._select && (this._value = t, this._setElementValue(a_(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._select ? (this._value = t, this._setElementValue(a_(this.id, t)), this._select.writeValue(this._select.value)) : this._setElementValue(t) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } _setSelected(t) { this._renderer.setProperty(this._element.nativeElement, "selected", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Ko), Sa(o_, 9)) }, t.\u0275dir = we({ type: t, selectors: [
                ["option"]
            ], inputs: { ngValue: "ngValue", value: "value" } }), t })();

    function c_(t, e) { return [...e.path, t] }

    function h_(t, e) { t || p_(e, "Cannot find control with"), e.valueAccessor || p_(e, "No value accessor for form control with"), t.validator = Bg.compose([t.validator, e.validator]), t.asyncValidator = Bg.composeAsync([t.asyncValidator, e.asyncValidator]), e.valueAccessor.writeValue(t.value),
            function(t, e) { e.valueAccessor.registerOnChange(i => { t._pendingValue = i, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && d_(t, e) }) }(t, e),
            function(t, e) { t.registerOnChange((t, i) => { e.valueAccessor.writeValue(t), i && e.viewToModelUpdate(t) }) }(t, e),
            function(t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && d_(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), e.valueAccessor.setDisabledState && t.registerOnDisabledChange(t => { e.valueAccessor.setDisabledState(t) }), e._rawValidators.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(() => t.updateValueAndValidity()) }), e._rawAsyncValidators.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(() => t.updateValueAndValidity()) }) }

    function d_(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 }

    function u_(t, e) { null == t && p_(e, "Cannot find control with"), t.validator = Bg.compose([t.validator, e.validator]), t.asyncValidator = Bg.composeAsync([t.asyncValidator, e.asyncValidator]) }

    function m_(t) { return p_(t, "There is no FormControl instance attached to form control element with") }

    function p_(t, e) { let i; throw i = t.path.length > 1 ? `path: '${t.path.join(" -> ")}'` : t.path[0] ? `name: '${t.path}'` : "unspecified name attribute", new Error(`${e} ${i}`) }

    function f_(t) { return null != t ? Bg.compose(t.map(Hg)) : null }

    function g_(t) { return null != t ? Bg.composeAsync(t.map(jg)) : null }

    function __(t, e) { if (!t.hasOwnProperty("model")) return !1; const i = t.model; return !!i.isFirstChange() || !ma(e, i.currentValue) }
    const b_ = [Cg, Kg, $g, n_, o_, Yg];

    function y_(t, e) { t._syncPendingControls(), e.forEach(t => { const e = t.control; "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1) }) }

    function v_(t, e) { if (!e) return null;
        Array.isArray(e) || p_(t, "Value accessor was not provided as an array for form control with"); let i = void 0,
            n = void 0,
            s = void 0; return e.forEach(e => { var r;
            e.constructor === kg ? i = e : (r = e, b_.some(t => r.constructor === t) ? (n && p_(t, "More than one built-in value accessor matches form control with"), n = e) : (s && p_(t, "More than one custom value accessor matches form control with"), s = e)) }), s || n || i || (p_(t, "No valid value accessor for form control with"), null) }

    function w_(t, e) { const i = t.indexOf(e);
        i > -1 && t.splice(i, 1) }

    function C_(t, e, i, n) { Sn() && "never" !== n && ((null !== n && "once" !== n || e._ngModelWarningSentOnce) && ("always" !== n || i._ngModelWarningSent) || (t_.ngModelWarning(t), e._ngModelWarningSentOnce = !0, i._ngModelWarningSent = !0)) }

    function x_(t) { const e = k_(t) ? t.validators : t; return Array.isArray(e) ? f_(e) : e || null }

    function S_(t, e) { const i = k_(e) ? e.asyncValidators : t; return Array.isArray(i) ? g_(i) : i || null }

    function k_(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class E_ { constructor(t, e) { this.validator = t, this.asyncValidator = e, this._onCollectionChange = () => {}, this.pristine = !0, this.touched = !1, this._onDisabledChange = [] } get parent() { return this._parent } get valid() { return "VALID" === this.status } get invalid() { return "INVALID" === this.status } get pending() { return "PENDING" == this.status } get disabled() { return "DISABLED" === this.status } get enabled() { return "DISABLED" !== this.status } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this.validator = x_(t) } setAsyncValidators(t) { this.asyncValidator = S_(t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = "PENDING", !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf);
            this.status = "DISABLED", this.errors = null, this._forEachChild(e => { e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf);
            this.status = "VALID", this._forEachChild(e => { e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), "VALID" !== this.status && "PENDING" !== this.status || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? "DISABLED" : "VALID" } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = "PENDING"; const e = zg(this.asyncValidator(this));
                this._asyncValidationSubscription = e.subscribe(e => this.setErrors(e, { emitEvent: t })) } } _cancelExistingSubscription() { this._asyncValidationSubscription && this._asyncValidationSubscription.unsubscribe() } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function(t, e, i) { if (null == e) return null; if (Array.isArray(e) || (e = e.split(".")), Array.isArray(e) && 0 === e.length) return null; let n = t; return e.forEach(t => { n = n instanceof A_ ? n.controls.hasOwnProperty(t) ? n.controls[t] : null : n instanceof I_ && n.at(t) || null }), n }(this, t) } getError(t, e) { const i = e ? this.get(e) : this; return i && i.errors ? i.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;) t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new jl, this.statusChanges = new jl } _calculateStatus() { return this._allControlsDisabled() ? "DISABLED" : this.errors ? "INVALID" : this._anyControlsHaveStatus("PENDING") ? "PENDING" : this._anyControlsHaveStatus("INVALID") ? "INVALID" : "VALID" } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { k_(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && this._parent && this._parent.dirty && !this._parent._anyControlsDirty() } } class D_ extends E_ { constructor(t = null, e, i) { super(x_(e), S_(i, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }), this._initObservables() } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() {} _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _clearChangeFns() { this._onChange = [], this._onDisabledChange = [], this._onCollectionChange = () => {} } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _forEachChild(t) {} _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class A_ extends E_ { constructor(t, e, i) { super(x_(e), S_(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e) { this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } removeControl(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}), delete this.controls[t], this.updateValueAndValidity(), this._onCollectionChange() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(i => { this._throwIfControlMissing(i), this.controls[i].setValue(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { Object.keys(t).forEach(i => { this.controls[i] && this.controls[i].patchValue(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } reset(t = {}, e = {}) { this._forEachChild((i, n) => { i.reset(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, i) => (t[i] = e instanceof D_ ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => t(this.controls[e], e)) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { let e = !1; return this._forEachChild((i, n) => { e = e || this.contains(n) && t(i) }), e } _reduceValue() { return this._reduceChildren({}, (t, e, i) => ((e.enabled || this.disabled) && (t[i] = e.value), t)) } _reduceChildren(t, e) { let i = t; return this._forEachChild((t, n) => { i = e(i, t, n) }), i } _allControlsDisabled() { for (const t of Object.keys(this.controls))
                if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, i) => { if (void 0 === t[i]) throw new Error(`Must supply a value for form control with name: '${i}'.`) }) } } class I_ extends E_ { constructor(t, e, i) { super(x_(e), S_(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }) } at(t) { return this.controls[t] } push(t) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity(), this._onCollectionChange() } insert(t, e) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity() } removeAt(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}), this.controls.splice(t, 1), this.updateValueAndValidity() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {}), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity(), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((t, i) => { this._throwIfControlMissing(i), this.at(i).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { t.forEach((t, i) => { this.at(i) && this.at(i).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } reset(t = [], e = {}) { this._forEachChild((i, n) => { i.reset(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof D_ ? t.value : t.getRawValue()) } clear() { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => {})), this.controls.splice(0), this.updateValueAndValidity()) } _syncPendingControls() { let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`) } _forEachChild(t) { this.controls.forEach((e, i) => { t(e, i) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, i) => { if (void 0 === t[i]) throw new Error(`Must supply a value for form control at index: ${i}.`) }) } _allControlsDisabled() { for (const t of this.controls)
                if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } }
    const T_ = { provide: Dg, useExisting: St(() => R_) }, O_ = (() => Promise.resolve(null))();
    let R_ = (() => { class t extends Dg { constructor(t, e) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new jl, this.form = new A_({}, f_(t), g_(e)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { O_.then(() => { const e = this._findContainer(t.path);
                    t.control = e.registerControl(t.name, t.control), h_(t.control, t), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { O_.then(() => { const e = this._findContainer(t.path);
                    e && e.removeControl(t.name), w_(this._directives, t) }) } addFormGroup(t) { O_.then(() => { const e = this._findContainer(t.path),
                        i = new A_({});
                    u_(i, t), e.registerControl(t.name, i), i.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { O_.then(() => { const e = this._findContainer(t.path);
                    e && e.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, e) { O_.then(() => { this.form.get(t.path).setValue(e) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, y_(this.form, this._directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Fg, 10), Sa(Ng, 10)) }, t.\u0275dir = we({ type: t, selectors: [
                ["form", 3, "ngNoForm", "", 3, "formGroup", ""],
                ["ng-form"],
                ["", "ngForm", ""]
            ], hostBindings: function(t, e) { 1 & t && Ba("submit", (function(t) { return e.onSubmit(t) }))("reset", (function() { return e.onReset() })) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [Ho([T_]), Eo] }), t })(), M_ = (() => { class t extends Dg { ngOnInit() { this._checkParentType(), this.formDirective.addFormGroup(this) } ngOnDestroy() { this.formDirective && this.formDirective.removeFormGroup(this) } get control() { return this.formDirective.getFormGroup(this) } get path() { return c_(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } get validator() { return f_(this._validators) } get asyncValidator() { return g_(this._asyncValidators) } _checkParentType() {} } return t.\u0275fac = function(e) { return P_(e || t) }, t.\u0275dir = we({ type: t, features: [Eo] }), t })();
    const P_ = ln(M_); class F_ { static modelParentException() { throw new Error(`\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup's partner directive "formControlName" instead.  Example:\n\n      ${Zg}\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      \n    <div [formGroup]="myGroup">\n       <input formControlName="firstName">\n       <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">\n    </div>\n  `) } static formGroupNameException() { throw new Error(`\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      ${Qg}\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      ${Jg}`) } static missingNameException() { throw new Error('If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as \'standalone\' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]="person.firstName" name="first">\n      Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">') } static modelGroupParentException() { throw new Error(`\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      ${Qg}\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      ${Jg}`) } }
    const N_ = { provide: Dg, useExisting: St(() => L_) };
    let L_ = (() => { class t extends M_ { constructor(t, e, i) { super(), this._parent = t, this._validators = e, this._asyncValidators = i } _checkParentType() { this._parent instanceof t || this._parent instanceof R_ || F_.modelGroupParentException() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Dg, 5), Sa(Fg, 10), Sa(Ng, 10)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "ngModelGroup", ""]
            ], inputs: { name: ["ngModelGroup", "name"] }, exportAs: ["ngModelGroup"], features: [Ho([N_]), Eo] }), t })();
    const B_ = { provide: Tg, useExisting: St(() => z_) }, V_ = (() => Promise.resolve(null))();
    let z_ = (() => { class t extends Tg { constructor(t, e, i, n) { super(), this.control = new D_, this._registered = !1, this.update = new jl, this._parent = t, this._rawValidators = e || [], this._rawAsyncValidators = i || [], this.valueAccessor = v_(this, n) } ngOnChanges(t) { this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in t && this._updateDisabled(t), __(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._parent ? c_(this.name, this._parent) : [this.name] } get formDirective() { return this._parent ? this._parent.formDirective : null } get validator() { return f_(this._rawValidators) } get asyncValidator() { return g_(this._rawAsyncValidators) } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { h_(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() {!(this._parent instanceof L_) && this._parent instanceof M_ ? F_.formGroupNameException() : this._parent instanceof L_ || this._parent instanceof R_ || F_.modelParentException() } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() || this.name || F_.missingNameException() } _updateValue(t) { V_.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }) }) } _updateDisabled(t) { const e = t.isDisabled.currentValue,
                    i = "" === e || e && "false" !== e;
                V_.then(() => { i && !this.control.disabled ? this.control.disable() : !i && this.control.disabled && this.control.enable() }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Dg, 9), Sa(Fg, 10), Sa(Ng, 10), Sa(vg, 10)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]
            ], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [Ho([B_]), Eo, Ro] }), t })(), U_ = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]
            ], hostAttrs: ["novalidate", ""] }), t })();
    const H_ = new Vt("NgModelWithFormControlWarning"), j_ = { provide: Tg, useExisting: St(() => G_) };
    let G_ = (() => { class t extends Tg { constructor(t, e, i, n) { super(), this._ngModelWarningConfig = n, this.update = new jl, this._ngModelWarningSent = !1, this._rawValidators = t || [], this._rawAsyncValidators = e || [], this.valueAccessor = v_(this, i) } set isDisabled(t) { t_.disabledAttrWarning() } ngOnChanges(e) { this._isControlChanged(e) && (h_(this.form, this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this.form.updateValueAndValidity({ emitEvent: !1 })), __(e, this.viewModel) && (C_("formControl", t, this, this._ngModelWarningConfig), this.form.setValue(this.model), this.viewModel = this.model) } get path() { return [] } get validator() { return f_(this._rawValidators) } get asyncValidator() { return g_(this._rawAsyncValidators) } get control() { return this.form } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _isControlChanged(t) { return t.hasOwnProperty("form") } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Fg, 10), Sa(Ng, 10), Sa(vg, 10), Sa(H_, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "formControl", ""]
            ], inputs: { isDisabled: ["disabled", "isDisabled"], form: ["formControl", "form"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngForm"], features: [Ho([j_]), Eo, Ro] }), t._ngModelWarningSentOnce = !1, t })();
    const $_ = { provide: Dg, useExisting: St(() => W_) };
    let W_ = (() => { class t extends Dg { constructor(t, e) { super(), this._validators = t, this._asyncValidators = e, this.submitted = !1, this.directives = [], this.form = null, this.ngSubmit = new jl } ngOnChanges(t) { this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations()) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(t) { const e = this.form.get(t.path); return h_(e, t), e.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(t), e } getControl(t) { return this.form.get(t.path) } removeControl(t) { w_(this.directives, t) } addFormGroup(t) { const e = this.form.get(t.path);
                u_(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } removeFormGroup(t) {} getFormGroup(t) { return this.form.get(t.path) } addFormArray(t) { const e = this.form.get(t.path);
                u_(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } removeFormArray(t) {} getFormArray(t) { return this.form.get(t.path) } updateModel(t, e) { this.form.get(t.path).setValue(e) } onSubmit(t) { return this.submitted = !0, y_(this.form, this.directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _updateDomValue() { this.directives.forEach(t => { const e = this.form.get(t.path);
                    t.control !== e && (function(t, e) { e.valueAccessor.registerOnChange(() => m_(e)), e.valueAccessor.registerOnTouched(() => m_(e)), e._rawValidators.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(null) }), e._rawAsyncValidators.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(null) }), t && t._clearChangeFns() }(t.control, t), e && h_(e, t), t.control = e) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _updateRegistrations() { this.form._registerOnCollectionChange(() => this._updateDomValue()), this._oldForm && this._oldForm._registerOnCollectionChange(() => {}), this._oldForm = this.form } _updateValidators() { const t = f_(this._validators);
                this.form.validator = Bg.compose([this.form.validator, t]); const e = g_(this._asyncValidators);
                this.form.asyncValidator = Bg.composeAsync([this.form.asyncValidator, e]) } _checkFormPresent() { this.form || t_.missingFormException() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Fg, 10), Sa(Ng, 10)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "formGroup", ""]
            ], hostBindings: function(t, e) { 1 & t && Ba("submit", (function(t) { return e.onSubmit(t) }))("reset", (function() { return e.onReset() })) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [Ho([$_]), Eo, Ro] }), t })();
    const q_ = { provide: Dg, useExisting: St(() => Y_) };
    let Y_ = (() => { class t extends M_ { constructor(t, e, i) { super(), this._parent = t, this._validators = e, this._asyncValidators = i } _checkParentType() { Z_(this._parent) && t_.groupParentException() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Dg, 13), Sa(Fg, 10), Sa(Ng, 10)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "formGroupName", ""]
            ], inputs: { name: ["formGroupName", "name"] }, features: [Ho([q_]), Eo] }), t })();
    const X_ = { provide: Dg, useExisting: St(() => K_) };
    let K_ = (() => { class t extends Dg { constructor(t, e, i) { super(), this._parent = t, this._validators = e, this._asyncValidators = i } ngOnInit() { this._checkParentType(), this.formDirective.addFormArray(this) } ngOnDestroy() { this.formDirective && this.formDirective.removeFormArray(this) } get control() { return this.formDirective.getFormArray(this) } get formDirective() { return this._parent ? this._parent.formDirective : null } get path() { return c_(null == this.name ? this.name : this.name.toString(), this._parent) } get validator() { return f_(this._validators) } get asyncValidator() { return g_(this._asyncValidators) } _checkParentType() { Z_(this._parent) && t_.arrayParentException() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Dg, 13), Sa(Fg, 10), Sa(Ng, 10)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "formArrayName", ""]
            ], inputs: { name: ["formArrayName", "name"] }, features: [Ho([X_]), Eo] }), t })();

    function Z_(t) { return !(t instanceof Y_ || t instanceof W_ || t instanceof K_) }
    const Q_ = { provide: Tg, useExisting: St(() => J_) };
    let J_ = (() => { class t extends Tg { constructor(t, e, i, n, s) { super(), this._ngModelWarningConfig = s, this._added = !1, this.update = new jl, this._ngModelWarningSent = !1, this._parent = t, this._rawValidators = e || [], this._rawAsyncValidators = i || [], this.valueAccessor = v_(this, n) } set isDisabled(t) { t_.disabledAttrWarning() } ngOnChanges(e) { this._added || this._setUpControl(), __(e, this.viewModel) && (C_("formControlName", t, this, this._ngModelWarningConfig), this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } get path() { return c_(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } get validator() { return f_(this._rawValidators) } get asyncValidator() { return g_(this._rawAsyncValidators) } _checkParentType() {!(this._parent instanceof Y_) && this._parent instanceof M_ ? t_.ngModelGroupException() : this._parent instanceof Y_ || this._parent instanceof W_ || this._parent instanceof K_ || t_.controlParentException() } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this._added = !0 } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Dg, 13), Sa(Fg, 10), Sa(Ng, 10), Sa(vg, 10), Sa(H_, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "formControlName", ""]
            ], inputs: { isDisabled: ["disabled", "isDisabled"], name: ["formControlName", "name"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [Ho([Q_]), Eo, Ro] }), t._ngModelWarningSentOnce = !1, t })();
    const tb = { provide: Fg, useExisting: St(() => ib), multi: !0 }, eb = { provide: Fg, useExisting: St(() => nb), multi: !0 };
    let ib = (() => { class t { get required() { return this._required } set required(t) { this._required = null != t && !1 !== t && "false" !== `${t}`, this._onChange && this._onChange() } validate(t) { return this.required ? Bg.required(t) : null } registerOnValidatorChange(t) { this._onChange = t } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "required", "", "formControlName", "", 3, "type", "checkbox"],
                ["", "required", "", "formControl", "", 3, "type", "checkbox"],
                ["", "required", "", "ngModel", "", 3, "type", "checkbox"]
            ], hostVars: 1, hostBindings: function(t, e) { 2 & t && va("required", e.required ? "" : null) }, inputs: { required: "required" }, features: [Ho([tb])] }), t })(), nb = (() => { class t extends ib { validate(t) { return this.required ? Bg.requiredTrue(t) : null } } return t.\u0275fac = function(e) { return sb(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "type", "checkbox", "required", "", "formControlName", ""],
                ["input", "type", "checkbox", "required", "", "formControl", ""],
                ["input", "type", "checkbox", "required", "", "ngModel", ""]
            ], hostVars: 1, hostBindings: function(t, e) { 2 & t && va("required", e.required ? "" : null) }, features: [Ho([eb]), Eo] }), t })();
    const sb = ln(nb), rb = { provide: Fg, useExisting: St(() => ab), multi: !0 };
    let ab = (() => { class t { set email(t) { this._enabled = "" === t || !0 === t || "true" === t, this._onChange && this._onChange() } validate(t) { return this._enabled ? Bg.email(t) : null } registerOnValidatorChange(t) { this._onChange = t } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "email", "", "formControlName", ""],
                ["", "email", "", "formControl", ""],
                ["", "email", "", "ngModel", ""]
            ], inputs: { email: "email" }, features: [Ho([rb])] }), t })();
    const ob = { provide: Fg, useExisting: St(() => lb), multi: !0 };
    let lb = (() => { class t { ngOnChanges(t) { "minlength" in t && (this._createValidator(), this._onChange && this._onChange()) } validate(t) { return null == this.minlength ? null : this._validator(t) } registerOnValidatorChange(t) { this._onChange = t } _createValidator() { this._validator = Bg.minLength("number" == typeof this.minlength ? this.minlength : parseInt(this.minlength, 10)) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "minlength", "", "formControlName", ""],
                ["", "minlength", "", "formControl", ""],
                ["", "minlength", "", "ngModel", ""]
            ], hostVars: 1, hostBindings: function(t, e) { 2 & t && va("minlength", e.minlength ? e.minlength : null) }, inputs: { minlength: "minlength" }, features: [Ho([ob]), Ro] }), t })();
    const cb = { provide: Fg, useExisting: St(() => hb), multi: !0 };
    let hb = (() => { class t { ngOnChanges(t) { "maxlength" in t && (this._createValidator(), this._onChange && this._onChange()) } validate(t) { return null != this.maxlength ? this._validator(t) : null } registerOnValidatorChange(t) { this._onChange = t } _createValidator() { this._validator = Bg.maxLength("number" == typeof this.maxlength ? this.maxlength : parseInt(this.maxlength, 10)) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "maxlength", "", "formControlName", ""],
                ["", "maxlength", "", "formControl", ""],
                ["", "maxlength", "", "ngModel", ""]
            ], hostVars: 1, hostBindings: function(t, e) { 2 & t && va("maxlength", e.maxlength ? e.maxlength : null) }, inputs: { maxlength: "maxlength" }, features: [Ho([cb]), Ro] }), t })();
    const db = { provide: Fg, useExisting: St(() => ub), multi: !0 };
    let ub = (() => { class t { ngOnChanges(t) { "pattern" in t && (this._createValidator(), this._onChange && this._onChange()) } validate(t) { return this._validator(t) } registerOnValidatorChange(t) { this._onChange = t } _createValidator() { this._validator = Bg.pattern(this.pattern) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "pattern", "", "formControlName", ""],
                ["", "pattern", "", "formControl", ""],
                ["", "pattern", "", "ngModel", ""]
            ], hostVars: 1, hostBindings: function(t, e) { 2 & t && va("pattern", e.pattern ? e.pattern : null) }, inputs: { pattern: "pattern" }, features: [Ho([db]), Ro] }), t })(), mb = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })(), pb = (() => { class t { group(t, e = null) { const i = this._reduceControls(t); let n = null,
                    s = null,
                    r = void 0; return null != e && (function(t) { return void 0 !== t.asyncValidators || void 0 !== t.validators || void 0 !== t.updateOn }(e) ? (n = null != e.validators ? e.validators : null, s = null != e.asyncValidators ? e.asyncValidators : null, r = null != e.updateOn ? e.updateOn : void 0) : (n = null != e.validator ? e.validator : null, s = null != e.asyncValidator ? e.asyncValidator : null)), new A_(i, { asyncValidators: s, updateOn: r, validators: n }) } control(t, e, i) { return new D_(t, e, i) } array(t, e, i) { const n = t.map(t => this._createControl(t)); return new I_(n, e, i) } _reduceControls(t) { const e = {}; return Object.keys(t).forEach(i => { e[i] = this._createControl(t[i]) }), e } _createControl(t) { return t instanceof D_ || t instanceof A_ || t instanceof I_ ? t : Array.isArray(t) ? this.control(t[0], t.length > 1 ? t[1] : null, t.length > 2 ? t[2] : null) : this.control(t) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), fb = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [qg], imports: [mb] }), t })(), gb = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: H_, useValue: e.warnOnNgModelWithFormControl }] } } } return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [pb, qg], imports: [mb] }), t })(); class _b {} class bb {} class yb { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const i = t.slice(0, e),
                            n = i.toLowerCase(),
                            s = t.slice(e + 1).trim();
                        this.maybeSetNormalizedName(i, n), this.headers.has(n) ? this.headers.get(n).push(s) : this.headers.set(n, [s]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let i = t[e]; const n = e.toLowerCase(); "string" == typeof i && (i = [i]), i.length > 0 && (this.headers.set(n, i), this.maybeSetNormalizedName(e, n)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof yb ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new yb; return e.lazyInit = this.lazyInit && this.lazyInit instanceof yb ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) {
                case "a":
                case "s":
                    let i = t.value; if ("string" == typeof i && (i = [i]), 0 === i.length) return;
                    this.maybeSetNormalizedName(t.name, e); const n = ("a" === t.op ? this.headers.get(e) : void 0) || [];
                    n.push(...i), this.headers.set(e, n); break;
                case "d":
                    const s = t.value; if (s) { let t = this.headers.get(e); if (!t) return;
                        t = t.filter(t => -1 === s.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class vb { encodeKey(t) { return wb(t) } encodeValue(t) { return wb(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } }

    function wb(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } class Cb { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new vb, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject.");
                this.map = function(t, e) { const i = new Map; return t.length > 0 && t.split("&").forEach(t => { const n = t.indexOf("="),
                            [s, r] = -1 == n ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, n)), e.decodeValue(t.slice(n + 1))],
                            a = i.get(s) || [];
                        a.push(r), i.set(s, a) }), i }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const i = t.fromObject[e];
                this.map.set(e, Array.isArray(i) ? i : [i]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new Cb({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat([t]), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) {
                    case "a":
                    case "s":
                        const e = ("a" === t.op ? this.map.get(t.param) : void 0) || [];
                        e.push(t.value), this.map.set(t.param, e); break;
                    case "d":
                        if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const i = e.indexOf(t.value); - 1 !== i && e.splice(i, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } }

    function xb(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer }

    function Sb(t) { return "undefined" != typeof Blob && t instanceof Blob }

    function kb(t) { return "undefined" != typeof FormData && t instanceof FormData } class Eb { constructor(t, e, i, n) { let s; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function(t) { switch (t) {
                        case "DELETE":
                        case "GET":
                        case "HEAD":
                        case "OPTIONS":
                        case "JSONP":
                            return !1;
                        default:
                            return !0 } }(this.method) || n ? (this.body = void 0 !== i ? i : null, s = n) : s = i, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.params && (this.params = s.params)), this.headers || (this.headers = new yb), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e;
                else { const i = e.indexOf("?");
                    this.urlWithParams = e + (-1 === i ? "?" : i < e.length - 1 ? "&" : "") + t } } else this.params = new Cb, this.urlWithParams = e } serializeBody() { return null === this.body ? null : xb(this.body) || Sb(this.body) || kb(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Cb ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || kb(this.body) ? null : Sb(this.body) ? this.body.type || null : xb(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Cb ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null } clone(t = {}) { const e = t.method || this.method,
                i = t.url || this.url,
                n = t.responseType || this.responseType,
                s = void 0 !== t.body ? t.body : this.body,
                r = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials,
                a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let o = t.headers || this.headers,
                l = t.params || this.params; return void 0 !== t.setHeaders && (o = Object.keys(t.setHeaders).reduce((e, i) => e.set(i, t.setHeaders[i]), o)), t.setParams && (l = Object.keys(t.setParams).reduce((e, i) => e.set(i, t.setParams[i]), l)), new Eb(e, i, s, { params: l, headers: o, reportProgress: a, responseType: n, withCredentials: r }) } }
    const Db = function() { var t = { Sent: 0, UploadProgress: 1, ResponseHeader: 2, DownloadProgress: 3, Response: 4, User: 5 }; return t[t.Sent] = "Sent", t[t.UploadProgress] = "UploadProgress", t[t.ResponseHeader] = "ResponseHeader", t[t.DownloadProgress] = "DownloadProgress", t[t.Response] = "Response", t[t.User] = "User", t }(); class Ab { constructor(t, e = 200, i = "OK") { this.headers = t.headers || new yb, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || i, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Ib extends Ab { constructor(t = {}) { super(t), this.type = Db.ResponseHeader } clone(t = {}) { return new Ib({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Tb extends Ab { constructor(t = {}) { super(t), this.type = Db.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new Tb({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Ob extends Ab { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url||"(unknown url)"}` : `Http failure response for ${t.url||"(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } }

    function Rb(t, e) { return { body: e, headers: t.headers, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } }
    let Mb = (() => { class t { constructor(t) { this.handler = t } request(t, e, i = {}) { let n; if (t instanceof Eb) n = t;
                else { let s = void 0;
                    s = i.headers instanceof yb ? i.headers : new yb(i.headers); let r = void 0;
                    i.params && (r = i.params instanceof Cb ? i.params : new Cb({ fromObject: i.params })), n = new Eb(t, e, void 0 !== i.body ? i.body : null, { headers: s, params: r, reportProgress: i.reportProgress, responseType: i.responseType || "json", withCredentials: i.withCredentials }) } const s = Mu(n).pipe(Cm(t => this.handler.handle(t))); if (t instanceof Eb || "events" === i.observe) return s; const r = s.pipe(Gu(t => t instanceof Tb)); switch (i.observe || "body") {
                    case "body":
                        switch (n.responseType) {
                            case "arraybuffer":
                                return r.pipe(L(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body }));
                            case "blob":
                                return r.pipe(L(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body }));
                            case "text":
                                return r.pipe(L(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body }));
                            case "json":
                            default:
                                return r.pipe(L(t => t.body)) }
                    case "response":
                        return r;
                    default:
                        throw new Error(`Unreachable: unhandled observe type ${i.observe}}`) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new Cb).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, i = {}) { return this.request("PATCH", t, Rb(i, e)) } post(t, e, i = {}) { return this.request("POST", t, Rb(i, e)) } put(t, e, i = {}) { return this.request("PUT", t, Rb(i, e)) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(_b)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class Pb { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } }
    const Fb = new Vt("HTTP_INTERCEPTORS");
    let Nb = (() => { class t { intercept(t, e) { return e.handle(t) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();
    const Lb = /^\)\]\}',?\n/; class Bb {}
    let Vb = (() => { class t { constructor() {} build() { return new XMLHttpRequest } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), zb = (() => { class t { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed."); return new v(e => { const i = this.xhrFactory.build(); if (i.open(t.method, t.urlWithParams), t.withCredentials && (i.withCredentials = !0), t.headers.forEach((t, e) => i.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || i.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader();
                        null !== e && i.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase();
                        i.responseType = "json" !== e ? e : "text" } const n = t.serializeBody(); let s = null; const r = () => { if (null !== s) return s; const e = 1223 === i.status ? 204 : i.status,
                                n = i.statusText || "OK",
                                r = new yb(i.getAllResponseHeaders()),
                                a = function(t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(i) || t.url; return s = new Ib({ headers: r, status: e, statusText: n, url: a }), s },
                        a = () => { let { headers: n, status: s, statusText: a, url: o } = r(), l = null;
                            204 !== s && (l = void 0 === i.response ? i.responseText : i.response), 0 === s && (s = l ? 200 : 0); let c = s >= 200 && s < 300; if ("json" === t.responseType && "string" == typeof l) { const t = l;
                                l = l.replace(Lb, ""); try { l = "" !== l ? JSON.parse(l) : null } catch (h) { l = t, c && (c = !1, l = { error: h, text: l }) } } c ? (e.next(new Tb({ body: l, headers: n, status: s, statusText: a, url: o || void 0 })), e.complete()) : e.error(new Ob({ error: l, headers: n, status: s, statusText: a, url: o || void 0 })) },
                        o = t => { const { url: n } = r(), s = new Ob({ error: t, status: i.status || 0, statusText: i.statusText || "Unknown Error", url: n || void 0 });
                            e.error(s) }; let l = !1; const c = n => { l || (e.next(r()), l = !0); let s = { type: Db.DownloadProgress, loaded: n.loaded };
                            n.lengthComputable && (s.total = n.total), "text" === t.responseType && i.responseText && (s.partialText = i.responseText), e.next(s) },
                        h = t => { let i = { type: Db.UploadProgress, loaded: t.loaded };
                            t.lengthComputable && (i.total = t.total), e.next(i) }; return i.addEventListener("load", a), i.addEventListener("error", o), t.reportProgress && (i.addEventListener("progress", c), null !== n && i.upload && i.upload.addEventListener("progress", h)), i.send(n), e.next({ type: Db.Sent }), () => { i.removeEventListener("error", o), i.removeEventListener("load", a), t.reportProgress && (i.removeEventListener("progress", c), null !== n && i.upload && i.upload.removeEventListener("progress", h)), i.abort() } }) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Bb)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();
    const Ub = new Vt("XSRF_COOKIE_NAME"), Hb = new Vt("XSRF_HEADER_NAME"); class jb {}
    let Gb = (() => { class t { constructor(t, e, i) { this.doc = t, this.platform = e, this.cookieName = i, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = md(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh), Xt(bc), Xt(Ub)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), $b = (() => { class t { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const i = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || i.startsWith("http://") || i.startsWith("https://")) return e.handle(t); const n = this.tokenService.getToken(); return null === n || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, n) })), e.handle(t) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(jb), Xt(Hb)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Wb = (() => { class t { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(Fb, []);
                    this.chain = t.reduceRight((t, e) => new Pb(t, e), this.backend) } return this.chain.handle(t) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(bb), Xt(ra)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), qb = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: $b, useClass: Nb }] } } static withOptions(e = {}) { return { ngModule: t, providers: [e.cookieName ? { provide: Ub, useValue: e.cookieName } : [], e.headerName ? { provide: Hb, useValue: e.headerName } : []] } } } return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [$b, { provide: Fb, useExisting: $b, multi: !0 }, { provide: jb, useClass: Gb }, { provide: Ub, useValue: "XSRF-TOKEN" }, { provide: Hb, useValue: "X-XSRF-TOKEN" }] }), t })(), Yb = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [Mb, { provide: _b, useClass: Wb }, zb, { provide: bb, useExisting: zb }, Vb, { provide: Bb, useExisting: Vb }], imports: [
                [qb.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]
            ] }), t })();

    function Xb(t) { return (Xb = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) { return typeof t } : function(t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) }

    function Kb(t, e, i) { return e in t ? Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = i, t }

    function Zb(t) { for (var e = 1; e < arguments.length; e++) { var i = null != arguments[e] ? arguments[e] : {},
                n = Object.keys(i); "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter((function(t) { return Object.getOwnPropertyDescriptor(i, t).enumerable })))), n.forEach((function(e) { Kb(t, e, i[e]) })) } return t }

    function Qb(t, e) { return function(t) { if (Array.isArray(t)) return t }(t) || function(t, e) { var i = [],
                n = !0,
                s = !1,
                r = void 0; try { for (var a, o = t[Symbol.iterator](); !(n = (a = o.next()).done) && (i.push(a.value), !e || i.length !== e); n = !0); } catch (l) { s = !0, r = l } finally { try { n || null == o.return || o.return() } finally { if (s) throw r } } return i }(t, e) || function() { throw new TypeError("Invalid attempt to destructure non-iterable instance") }() }

    function Jb(t) { return function(t) { if (Array.isArray(t)) { for (var e = 0, i = new Array(t.length); e < t.length; e++) i[e] = t[e]; return i } }(t) || function(t) { if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t) }(t) || function() { throw new TypeError("Invalid attempt to spread non-iterable instance") }() }
    var ty = {}, ey = {};
    try { "undefined" != typeof window && (ty = window), "undefined" != typeof document && (ey = document), "undefined" != typeof MutationObserver && MutationObserver, "undefined" != typeof performance && performance } catch (L$) {}
    var iy = (ty.navigator || {}).userAgent, ny = void 0 === iy ? "" : iy, sy = ty, ry = ey, ay = !!ry.documentElement && !!ry.head && "function" == typeof ry.addEventListener && "function" == typeof ry.createElement, oy = ~ny.indexOf("MSIE") || ~ny.indexOf("Trident/"), ly = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], cy = ly.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), hy = { GROUP: "group", SWAP_OPACITY: "swap-opacity", PRIMARY: "primary", SECONDARY: "secondary" }, dy = (["xs", "sm", "lg", "fw", "ul", "li", "border", "pull-left", "pull-right", "spin", "pulse", "rotate-90", "rotate-180", "rotate-270", "flip-horizontal", "flip-vertical", "flip-both", "stack", "stack-1x", "stack-2x", "inverse", "layers", "layers-text", "layers-counter", hy.GROUP, hy.SWAP_OPACITY, hy.PRIMARY, hy.SECONDARY].concat(ly.map((function(t) { return "".concat(t, "x") }))).concat(cy.map((function(t) { return "w-".concat(t) }))), sy.FontAwesomeConfig || {}); ry && "function" == typeof ry.querySelector && [
        ["data-family-prefix", "familyPrefix"],
        ["data-replacement-class", "replacementClass"],
        ["data-auto-replace-svg", "autoReplaceSvg"],
        ["data-auto-add-css", "autoAddCss"],
        ["data-auto-a11y", "autoA11y"],
        ["data-search-pseudo-elements", "searchPseudoElements"],
        ["data-observe-mutations", "observeMutations"],
        ["data-mutate-approach", "mutateApproach"],
        ["data-keep-original-source", "keepOriginalSource"],
        ["data-measure-performance", "measurePerformance"],
        ["data-show-missing-icons", "showMissingIcons"]
    ].forEach((function(t) { var e = Qb(t, 2),
            i = e[1],
            n = function(t) { return "" === t || "false" !== t && ("true" === t || t) }(function(t) { var e = ry.querySelector("script[" + t + "]"); if (e) return e.getAttribute(t) }(e[0]));
        null != n && (dy[i] = n) }));
    var uy = Zb({}, { familyPrefix: "fa", replacementClass: "svg-inline--fa", autoReplaceSvg: !0, autoAddCss: !0, autoA11y: !0, searchPseudoElements: !1, observeMutations: !0, mutateApproach: "async", keepOriginalSource: !0, measurePerformance: !1, showMissingIcons: !0 }, dy); uy.autoReplaceSvg || (uy.observeMutations = !1);
    var my = Zb({}, uy); sy.FontAwesomeConfig = my;
    var py = sy || {}; py.___FONT_AWESOME___ || (py.___FONT_AWESOME___ = {}), py.___FONT_AWESOME___.styles || (py.___FONT_AWESOME___.styles = {}), py.___FONT_AWESOME___.hooks || (py.___FONT_AWESOME___.hooks = {}), py.___FONT_AWESOME___.shims || (py.___FONT_AWESOME___.shims = []);
    var fy = py.___FONT_AWESOME___, gy = []; ay && ((ry.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(ry.readyState) || ry.addEventListener("DOMContentLoaded", (function t() { ry.removeEventListener("DOMContentLoaded", t), gy.map((function(t) { return t() })) })));
    var _y, by = function() {}, yy = "undefined" != typeof global && void 0 !== global.process && "function" == typeof global.process.emit, vy = "undefined" == typeof setImmediate ? setTimeout : setImmediate, wy = [];

    function Cy() { for (var t = 0; t < wy.length; t++) wy[t][0](wy[t][1]);
        wy = [], _y = !1 }

    function xy(t, e) { wy.push([t, e]), _y || (_y = !0, vy(Cy, 0)) }

    function Sy(t) { var e = t.owner,
            i = e._state,
            n = e._data,
            s = t[i],
            r = t.then; if ("function" == typeof s) { i = "fulfilled"; try { n = s(n) } catch (L$) { Ay(r, L$) } } ky(r, n) || ("fulfilled" === i && Ey(r, n), "rejected" === i && Ay(r, n)) }

    function ky(t, e) { var i; try { if (t === e) throw new TypeError("A promises callback cannot return that same promise."); if (e && ("function" == typeof e || "object" === Xb(e))) { var n = e.then; if ("function" == typeof n) return n.call(e, (function(n) { i || (i = !0, e === n ? Dy(t, n) : Ey(t, n)) }), (function(e) { i || (i = !0, Ay(t, e)) })), !0 } } catch (L$) { return i || Ay(t, L$), !0 } return !1 }

    function Ey(t, e) { t !== e && ky(t, e) || Dy(t, e) }

    function Dy(t, e) { "pending" === t._state && (t._state = "settled", t._data = e, xy(Ty, t)) }

    function Ay(t, e) { "pending" === t._state && (t._state = "settled", t._data = e, xy(Oy, t)) }

    function Iy(t) { t._then = t._then.forEach(Sy) }

    function Ty(t) { t._state = "fulfilled", Iy(t) }

    function Oy(t) { t._state = "rejected", Iy(t), !t._handled && yy && global.process.emit("unhandledRejection", t._data, t) }

    function Ry(t) { global.process.emit("rejectionHandled", t) }

    function My(t) { if ("function" != typeof t) throw new TypeError("Promise resolver " + t + " is not a function"); if (this instanceof My == 0) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
        this._then = [],
            function(t, e) {
                function i(t) { Ay(e, t) } try { t((function(t) { Ey(e, t) }), i) } catch (L$) { i(L$) } }(t, this) } My.prototype = { constructor: My, _state: "pending", _then: null, _data: void 0, _handled: !1, then: function(t, e) { var i = { owner: this, then: new this.constructor(by), fulfilled: t, rejected: e }; return !e && !t || this._handled || (this._handled = !0, "rejected" === this._state && yy && xy(Ry, this)), "fulfilled" === this._state || "rejected" === this._state ? xy(Sy, i) : this._then.push(i), i.then }, catch: function(t) { return this.then(null, t) } }, My.all = function(t) { if (!Array.isArray(t)) throw new TypeError("You must pass an array to Promise.all()."); return new My((function(e, i) { var n = [],
                s = 0;

            function r(t) { return s++,
                    function(i) { n[t] = i, --s || e(n) } } for (var a, o = 0; o < t.length; o++)(a = t[o]) && "function" == typeof a.then ? a.then(r(o), i) : n[o] = a;
            s || e(n) })) }, My.race = function(t) { if (!Array.isArray(t)) throw new TypeError("You must pass an array to Promise.race()."); return new My((function(e, i) { for (var n, s = 0; s < t.length; s++)(n = t[s]) && "function" == typeof n.then ? n.then(e, i) : e(n) })) }, My.resolve = function(t) { return t && "object" === Xb(t) && t.constructor === My ? t : new My((function(e) { e(t) })) }, My.reject = function(t) { return new My((function(e, i) { i(t) })) };
    var Py = { size: 16, x: 0, y: 0, rotate: 0, flipX: !1, flipY: !1 };

    function Fy() { for (var t = 12, e = ""; t-- > 0;) e += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" [62 * Math.random() | 0]; return e }

    function Ny(t) { return "".concat(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;") }

    function Ly(t) { return Object.keys(t || {}).reduce((function(e, i) { return e + "".concat(i, ": ").concat(t[i], ";") }), "") }

    function By(t) { return t.size !== Py.size || t.x !== Py.x || t.y !== Py.y || t.rotate !== Py.rotate || t.flipX || t.flipY }

    function Vy(t) { var e = t.transform,
            i = t.iconWidth,
            n = { transform: "translate(".concat(t.containerWidth / 2, " 256)") },
            s = "translate(".concat(32 * e.x, ", ").concat(32 * e.y, ") "),
            r = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "),
            a = "rotate(".concat(e.rotate, " 0 0)"); return { outer: n, inner: { transform: "".concat(s, " ").concat(r, " ").concat(a) }, path: { transform: "translate(".concat(i / 2 * -1, " -256)") } } }
    var zy = { x: 0, y: 0, width: "100%", height: "100%" };

    function Uy(t) { var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; return t.attributes && (t.attributes.fill || e) && (t.attributes.fill = "black"), t }

    function Hy(t) { var e = t.icons,
            i = e.main,
            n = e.mask,
            s = t.prefix,
            r = t.iconName,
            a = t.transform,
            o = t.symbol,
            l = t.title,
            c = t.maskId,
            h = t.titleId,
            d = t.extra,
            u = t.watchable,
            m = void 0 !== u && u,
            p = n.found ? n : i,
            f = p.width,
            g = p.height,
            _ = "fa-w-".concat(Math.ceil(f / g * 16)),
            b = [my.replacementClass, r ? "".concat(my.familyPrefix, "-").concat(r) : "", _].filter((function(t) { return -1 === d.classes.indexOf(t) })).concat(d.classes).join(" "),
            y = { children: [], attributes: Zb({}, d.attributes, { "data-prefix": s, "data-icon": r, class: b, role: d.attributes.role || "img", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 ".concat(f, " ").concat(g) }) };
        m && (y.attributes["data-fa-i2svg"] = ""), l && y.children.push({ tag: "title", attributes: { id: y.attributes["aria-labelledby"] || "title-".concat(h || Fy()) }, children: [l] }); var v = Zb({}, y, { prefix: s, iconName: r, main: i, mask: n, maskId: c, transform: a, symbol: o, styles: d.styles }),
            w = n.found && i.found ? function(t) { var e, i = t.children,
                    n = t.attributes,
                    s = t.main,
                    r = t.mask,
                    a = t.maskId,
                    o = s.icon,
                    l = r.icon,
                    c = Vy({ transform: t.transform, containerWidth: r.width, iconWidth: s.width }),
                    h = { tag: "rect", attributes: Zb({}, zy, { fill: "white" }) },
                    d = o.children ? { children: o.children.map(Uy) } : {},
                    u = { tag: "g", attributes: Zb({}, c.inner), children: [Uy(Zb({ tag: o.tag, attributes: Zb({}, o.attributes, c.path) }, d))] },
                    m = { tag: "g", attributes: Zb({}, c.outer), children: [u] },
                    p = "mask-".concat(a || Fy()),
                    f = "clip-".concat(a || Fy()),
                    g = { tag: "mask", attributes: Zb({}, zy, { id: p, maskUnits: "userSpaceOnUse", maskContentUnits: "userSpaceOnUse" }), children: [h, m] },
                    _ = { tag: "defs", children: [{ tag: "clipPath", attributes: { id: f }, children: (e = l, "g" === e.tag ? e.children : [e]) }, g] }; return i.push(_, { tag: "rect", attributes: Zb({ fill: "currentColor", "clip-path": "url(#".concat(f, ")"), mask: "url(#".concat(p, ")") }, zy) }), { children: i, attributes: n } }(v) : function(t) { var e = t.children,
                    i = t.attributes,
                    n = t.main,
                    s = t.transform,
                    r = Ly(t.styles); if (r.length > 0 && (i.style = r), By(s)) { var a = Vy({ transform: s, containerWidth: n.width, iconWidth: n.width });
                    e.push({ tag: "g", attributes: Zb({}, a.outer), children: [{ tag: "g", attributes: Zb({}, a.inner), children: [{ tag: n.icon.tag, children: n.icon.children, attributes: Zb({}, n.icon.attributes, a.path) }] }] }) } else e.push(n.icon); return { children: e, attributes: i } }(v),
            C = w.attributes; return v.children = w.children, v.attributes = C, o ? function(t) { var e = t.iconName,
                i = t.children,
                n = t.symbol; return [{ tag: "svg", attributes: { style: "display: none;" }, children: [{ tag: "symbol", attributes: Zb({}, t.attributes, { id: !0 === n ? "".concat(t.prefix, "-").concat(my.familyPrefix, "-").concat(e) : n }), children: i }] }] }(v) : function(t) { var e = t.children,
                i = t.main,
                n = t.mask,
                s = t.attributes,
                r = t.styles,
                a = t.transform; if (By(a) && i.found && !n.found) { var o = { x: i.width / i.height / 2, y: .5 };
                s.style = Ly(Zb({}, r, { "transform-origin": "".concat(o.x + a.x / 16, "em ").concat(o.y + a.y / 16, "em") })) } return [{ tag: "svg", attributes: s, children: e }] }(v) }

    function jy(t) { var e = t.content,
            i = t.width,
            n = t.height,
            s = t.transform,
            r = t.title,
            a = t.extra,
            o = t.watchable,
            l = void 0 !== o && o,
            c = Zb({}, a.attributes, r ? { title: r } : {}, { class: a.classes.join(" ") });
        l && (c["data-fa-i2svg"] = ""); var h = Zb({}, a.styles);
        By(s) && (h.transform = function(t) { var e = t.transform,
                i = t.width,
                n = t.height,
                s = void 0 === n ? 16 : n,
                r = t.startCentered,
                a = void 0 !== r && r,
                o = ""; return o += a && oy ? "translate(".concat(e.x / 16 - (void 0 === i ? 16 : i) / 2, "em, ").concat(e.y / 16 - s / 2, "em) ") : a ? "translate(calc(-50% + ".concat(e.x / 16, "em), calc(-50% + ").concat(e.y / 16, "em)) ") : "translate(".concat(e.x / 16, "em, ").concat(e.y / 16, "em) "), (o += "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") ")) + "rotate(".concat(e.rotate, "deg) ") }({ transform: s, startCentered: !0, width: i, height: n }), h["-webkit-transform"] = h.transform); var d = Ly(h);
        d.length > 0 && (c.style = d); var u = []; return u.push({ tag: "span", attributes: c, children: [e] }), r && u.push({ tag: "span", attributes: { class: "sr-only" }, children: [r] }), u }

    function Gy(t) { var e = t.content,
            i = t.title,
            n = t.extra,
            s = Zb({}, n.attributes, i ? { title: i } : {}, { class: n.classes.join(" ") }),
            r = Ly(n.styles);
        r.length > 0 && (s.style = r); var a = []; return a.push({ tag: "span", attributes: s, children: [e] }), i && a.push({ tag: "span", attributes: { class: "sr-only" }, children: [i] }), a }
    var $y = function(t, e, i, n) { var s, r, a, o = Object.keys(t),
            l = o.length,
            c = void 0 !== n ? function(t, e) { return function(i, n, s, r) { return t.call(e, i, n, s, r) } }(e, n) : e; for (void 0 === i ? (s = 1, a = t[o[0]]) : (s = 0, a = i); s < l; s++) a = c(a, t[r = o[s]], r, t); return a };

    function Wy(t, e) { var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            n = i.skipHooks,
            s = void 0 !== n && n,
            r = Object.keys(e).reduce((function(t, i) { var n = e[i]; return n.icon ? t[n.iconName] = n.icon : t[i] = n, t }), {}); "function" != typeof fy.hooks.addPack || s ? fy.styles[t] = Zb({}, fy.styles[t] || {}, r) : fy.hooks.addPack(t, r), "fas" === t && Wy("fa", e) }
    var qy = fy.styles, Yy = fy.shims, Xy = function() { var t = function(t) { return $y(qy, (function(e, i, n) { return e[n] = $y(i, t, {}), e }), {}) };
        t((function(t, e, i) { return e[3] && (t[e[3]] = i), t })), t((function(t, e, i) { var n = e[2]; return t[i] = i, n.forEach((function(e) { t[e] = i })), t })); var e = "far" in qy;
        $y(Yy, (function(t, i) { var n = i[1]; return "far" !== n || e || (n = "fas"), t[i[0]] = { prefix: n, iconName: i[2] }, t }), {}) };

    function Ky(t, e, i) { if (t && t[e] && t[e][i]) return { prefix: e, iconName: i, icon: t[e][i] } }

    function Zy(t) { var e = t.tag,
            i = t.attributes,
            n = void 0 === i ? {} : i,
            s = t.children,
            r = void 0 === s ? [] : s; return "string" == typeof t ? Ny(t) : "<".concat(e, " ").concat(function(t) { return Object.keys(t || {}).reduce((function(e, i) { return e + "".concat(i, '="').concat(Ny(t[i]), '" ') }), "").trim() }(n), ">").concat(r.map(Zy).join(""), "</").concat(e, ">") }

    function Qy(t) { this.name = "MissingIcon", this.message = t || "Icon unavailable", this.stack = (new Error).stack } Xy(), (Qy.prototype = Object.create(Error.prototype)).constructor = Qy;
    var Jy = { fill: "currentColor" }, tv = { attributeType: "XML", repeatCount: "indefinite", dur: "2s" }, ev = (Zb({}, Jy, { d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z" }), Zb({}, tv, { attributeName: "opacity" }));

    function iv(t) { var e = t[0],
            i = t[1],
            n = Qb(t.slice(4), 1)[0]; return { found: !0, width: e, height: i, icon: Array.isArray(n) ? { tag: "g", attributes: { class: "".concat(my.familyPrefix, "-").concat(hy.GROUP) }, children: [{ tag: "path", attributes: { class: "".concat(my.familyPrefix, "-").concat(hy.SECONDARY), fill: "currentColor", d: n[0] } }, { tag: "path", attributes: { class: "".concat(my.familyPrefix, "-").concat(hy.PRIMARY), fill: "currentColor", d: n[1] } }] } : { tag: "path", attributes: { fill: "currentColor", d: n } } } }

    function nv() { my.autoAddCss && !lv && (function(t) { if (t && ay) { var e = ry.createElement("style");
                e.setAttribute("type", "text/css"), e.innerHTML = t; for (var i = ry.head.childNodes, n = null, s = i.length - 1; s > -1; s--) { var r = i[s],
                        a = (r.tagName || "").toUpperCase();
                    ["STYLE", "LINK"].indexOf(a) > -1 && (n = r) } ry.head.insertBefore(e, n) } }(function() { var t = "svg-inline--fa",
                e = my.familyPrefix,
                i = my.replacementClass,
                n = 'svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse {\n  color: #fff;\n}'; if ("fa" !== e || i !== t) { var s = new RegExp("\\.".concat("fa", "\\-"), "g"),
                    r = new RegExp("\\--".concat("fa", "\\-"), "g"),
                    a = new RegExp("\\.".concat(t), "g");
                n = n.replace(s, ".".concat(e, "-")).replace(r, "--".concat(e, "-")).replace(a, ".".concat(i)) } return n }()), lv = !0) }

    function sv(t, e) { return Object.defineProperty(t, "abstract", { get: e }), Object.defineProperty(t, "html", { get: function() { return t.abstract.map((function(t) { return Zy(t) })) } }), Object.defineProperty(t, "node", { get: function() { if (ay) { var e = ry.createElement("div"); return e.innerHTML = t.html, e.children } } }), t }

    function rv(t) { var e = t.prefix,
            i = void 0 === e ? "fa" : e,
            n = t.iconName; if (n) return Ky(ov.definitions, i, n) || Ky(fy.styles, i, n) } Zb({}, Jy, { cx: "256", cy: "364", r: "28" }), Zb({}, tv, { attributeName: "r", values: "28;14;28;28;14;28;" }), Zb({}, ev, { values: "1;0;1;1;0;1;" }), Zb({}, Jy, { opacity: "1", d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z" }), Zb({}, ev, { values: "1;0;0;0;0;1;" }), Zb({}, Jy, { opacity: "0", d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z" }), Zb({}, ev, { values: "0;0;1;1;0;0;" });
    var av, ov = new(function() {
        function t() {! function(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.definitions = {} } var e; return (e = [{ key: "add", value: function() { for (var t = this, e = arguments.length, i = new Array(e), n = 0; n < e; n++) i[n] = arguments[n]; var s = i.reduce(this._pullDefinitions, {});
                Object.keys(s).forEach((function(e) { t.definitions[e] = Zb({}, t.definitions[e] || {}, s[e]), Wy(e, s[e]), Xy() })) } }, { key: "reset", value: function() { this.definitions = {} } }, { key: "_pullDefinitions", value: function(t, e) { var i = e.prefix && e.iconName && e.icon ? { 0: e } : e; return Object.keys(i).map((function(e) { var n = i[e],
                        s = n.prefix,
                        r = n.iconName,
                        a = n.icon;
                    t[s] || (t[s] = {}), t[s][r] = a })), t } }]) && function(t, e) { for (var i = 0; i < e.length; i++) { var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } }(t.prototype, e), t }()), lv = !1, cv = function(t) { return function(t) { var e = { size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0 }; return t ? t.toLowerCase().split(" ").reduce((function(t, e) { var i = e.toLowerCase().split("-"),
                    n = i[0],
                    s = i.slice(1).join("-"); if (n && "h" === s) return t.flipX = !0, t; if (n && "v" === s) return t.flipY = !0, t; if (s = parseFloat(s), isNaN(s)) return t; switch (n) {
                    case "grow":
                        t.size = t.size + s; break;
                    case "shrink":
                        t.size = t.size - s; break;
                    case "left":
                        t.x = t.x - s; break;
                    case "right":
                        t.x = t.x + s; break;
                    case "up":
                        t.y = t.y - s; break;
                    case "down":
                        t.y = t.y + s; break;
                    case "rotate":
                        t.rotate = t.rotate + s } return t }), e) : e }(t) }, hv = (av = function(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            i = e.transform,
            n = void 0 === i ? Py : i,
            s = e.symbol,
            r = void 0 !== s && s,
            a = e.mask,
            o = void 0 === a ? null : a,
            l = e.maskId,
            c = void 0 === l ? null : l,
            h = e.title,
            d = void 0 === h ? null : h,
            u = e.titleId,
            m = void 0 === u ? null : u,
            p = e.classes,
            f = void 0 === p ? [] : p,
            g = e.attributes,
            _ = void 0 === g ? {} : g,
            b = e.styles,
            y = void 0 === b ? {} : b; if (t) { var v = t.prefix,
                w = t.iconName,
                C = t.icon; return sv(Zb({ type: "icon" }, t), (function() { return nv(), my.autoA11y && (d ? _["aria-labelledby"] = "".concat(my.replacementClass, "-title-").concat(m || Fy()) : (_["aria-hidden"] = "true", _.focusable = "false")), Hy({ icons: { main: iv(C), mask: o ? iv(o.icon) : { found: !1, width: null, height: null, icon: {} } }, prefix: v, iconName: w, transform: Zb({}, Py, n), symbol: r, title: d, maskId: c, titleId: m, extra: { attributes: _, styles: y, classes: f } }) })) } }, function(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            i = (t || {}).icon ? t : rv(t || {}),
            n = e.mask; return n && (n = (n || {}).icon ? n : rv(n || {})), av(i, Zb({}, e, { mask: n })) });
    const dv = [
        [
            ["fa-icon"],
            ["fa-duotone-icon"],
            ["fa-layers-text"],
            ["fa-layers-counter"]
        ]
    ], uv = ["fa-icon, fa-duotone-icon, fa-layers-text, fa-layers-counter"], mv = [
        [
            ["fa-icon", "stackItemSize", ""],
            ["fa-duotone-icon", "stackItemSize", ""]
        ]
    ], pv = ["fa-icon[stackItemSize],fa-duotone-icon[stackItemSize]"];
    let fv = (() => { let t = class { constructor() { this.defaultPrefix = "fas", this.fallbackIcon = null, this.globalLibrary = !1 } }; return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return new t }, token: t, providedIn: "root" }), t })(), gv = (() => { let t = class { constructor() { this.definitions = {} } addIcons(...t) { for (const e of t) e.prefix in this.definitions || (this.definitions[e.prefix] = {}), this.definitions[e.prefix][e.iconName] = e } addIconPacks(...t) { for (const e of t) { const t = Object.keys(e).map(t => e[t]);
                    this.addIcons(...t) } } getIconDefinition(t, e) { return t in this.definitions && e in this.definitions[t] ? this.definitions[t][e] : null } }; return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return new t }, token: t, providedIn: "root" }), t })();
    const _v = t => { const e = { "fa-spin": t.spin, "fa-pulse": t.pulse, "fa-fw": t.fixedWidth, "fa-border": t.border, "fa-inverse": t.inverse, "fa-layers-counter": t.counter, "fa-flip-horizontal": "horizontal" === t.flip || "both" === t.flip, "fa-flip-vertical": "vertical" === t.flip || "both" === t.flip, [`fa-${t.size}`]: null !== t.size, [`fa-rotate-${t.rotate}`]: null !== t.rotate, [`fa-pull-${t.pull}`]: null !== t.pull, [`fa-stack-${t.stackItemSize}`]: null != t.stackItemSize }; return Object.keys(e).map(t => e[t] ? t : null).filter(t => t) };
    let bv = (() => { let t = class { constructor() { this.stackItemSize = "1x" } ngOnChanges(t) { if ("size" in t) throw new Error('fa-icon is not allowed to customize size when used inside fa-stack. Set size on the enclosing fa-stack instead: <fa-stack size="4x">...</fa-stack>.') } }; return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["fa-icon", "stackItemSize", ""],
                ["fa-duotone-icon", "stackItemSize", ""]
            ], inputs: { stackItemSize: "stackItemSize", size: "size" }, features: [Ro] }), t })(), yv = (() => { let t = class { constructor(t, e, i, n) { this.sanitizer = t, this.config = e, this.iconLibrary = i, this.stackItem = n, this.classes = [] } ngOnChanges(t) { if (null == this.icon && null == this.config.fallbackIcon) return (() => { throw new Error("Property `icon` is required for `fa-icon`/`fa-duotone-icon` components.") })(); let e = null; if (e = null == this.icon ? this.config.fallbackIcon : this.icon, t) { const t = this.findIconDefinition(e); if (null != t) { const e = this.buildParams();
                        this.renderIcon(t, e) } } } render() { this.ngOnChanges({}) } findIconDefinition(t) { const e = ((t, e) => { return void 0 !== (i = t).prefix && void 0 !== i.iconName ? t : Array.isArray(t) && 2 === t.length ? { prefix: t[0], iconName: t[1] } : "string" == typeof t ? { prefix: e, iconName: t } : void 0; var i })(t, this.config.defaultPrefix); if ("icon" in e) return e; const i = this.iconLibrary.getIconDefinition(e.prefix, e.iconName); if (null != i) return i; const n = rv(e); if (null != n) { const t = "Global icon library is deprecated. Consult https://github.com/FortAwesome/angular-fontawesome/blob/master/UPGRADING.md for the migration instructions."; if ("unset" === this.config.globalLibrary) console.error("FontAwesome: " + t);
                    else if (!this.config.globalLibrary) throw new Error(t); return n } return (t => { throw new Error(`Could not find icon with iconName=${t.iconName} and prefix=${t.prefix} in the icon library.`) })(e), null } buildParams() { const t = { flip: this.flip, spin: this.spin, pulse: this.pulse, border: this.border, inverse: this.inverse, size: this.size || null, pull: this.pull || null, rotate: this.rotate || null, fixedWidth: "boolean" == typeof this.fixedWidth ? this.fixedWidth : this.config.fixedWidth, stackItemSize: null != this.stackItem ? this.stackItem.stackItemSize : null },
                    e = "string" == typeof this.transform ? cv(this.transform) : this.transform; return { title: this.title, transform: e, classes: [..._v(t), ...this.classes], mask: null != this.mask ? this.findIconDefinition(this.mask) : null, styles: null != this.styles ? this.styles : {}, symbol: this.symbol, attributes: { role: this.a11yRole } } } renderIcon(t, e) { const i = hv(t, e);
                this.renderedIconHTML = this.sanitizer.bypassSecurityTrustHtml(i.html.join("\n")) } }; return t.\u0275fac = function(e) { return new(e || t)(Sa(Au), Sa(fv), Sa(gv), Sa(bv, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["fa-icon"]
            ], hostAttrs: [1, "ng-fa-icon"], hostVars: 2, hostBindings: function(t, e) { 2 & t && (xo("innerHTML", e.renderedIconHTML, Kn), va("title", e.title)) }, inputs: { classes: "classes", icon: "icon", title: "title", spin: "spin", pulse: "pulse", mask: "mask", styles: "styles", flip: "flip", size: "size", pull: "pull", border: "border", inverse: "inverse", symbol: "symbol", rotate: "rotate", fixedWidth: "fixedWidth", transform: "transform", a11yRole: "a11yRole" }, features: [Ro], decls: 0, vars: 0, template: function(t, e) {}, encapsulation: 2 }), t })(), vv = (() => { let t = class extends yv { findIconDefinition(t) { const e = super.findIconDefinition(t); if (null != e && "fad" !== e.prefix) throw new Error("The specified icon does not appear to be a Duotone icon. Check that you specified the correct style: " + `<fa-duotone-icon [icon]="['fab', '${e.iconName}']"></fa-duotone-icon> ` + `or use: <fa-icon icon="${e.iconName}"></fa-icon> instead.`); return e } buildParams() { const t = super.buildParams(); return !0 !== this.swapOpacity && "true" !== this.swapOpacity || t.classes.push("fa-swap-opacity"), null != this.primaryOpacity && (t.styles["--fa-primary-opacity"] = this.primaryOpacity.toString()), null != this.secondaryOpacity && (t.styles["--fa-secondary-opacity"] = this.secondaryOpacity.toString()), null != this.primaryColor && (t.styles["--fa-primary-color"] = this.primaryColor), null != this.secondaryColor && (t.styles["--fa-secondary-color"] = this.secondaryColor), t } }; return t.\u0275fac = function(e) { return Dv(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["fa-duotone-icon"]
            ], inputs: { swapOpacity: "swapOpacity", primaryOpacity: "primaryOpacity", secondaryOpacity: "secondaryOpacity", primaryColor: "primaryColor", secondaryColor: "secondaryColor" }, features: [Eo], decls: 0, vars: 0, template: function(t, e) {}, encapsulation: 2 }), t })();
    const wv = (t, e, i) => { if (!t) throw new Error(`${i} should be used as child of ${e} only.`) };
    let Cv = (() => { let t = class { constructor(t, e, i) { this.renderer = t, this.elementRef = e, this.config = i } ngOnInit() { this.renderer.addClass(this.elementRef.nativeElement, "fa-layers"), this.fixedWidth = "boolean" == typeof this.fixedWidth ? this.fixedWidth : this.config.fixedWidth } ngOnChanges(t) { "size" in t && (null != t.size.currentValue && this.renderer.addClass(this.elementRef.nativeElement, `fa-${t.size.currentValue}`), null != t.size.previousValue && this.renderer.removeClass(this.elementRef.nativeElement, `fa-${t.size.previousValue}`)) } }; return t.\u0275fac = function(e) { return new(e || t)(Sa(Ko), Sa(Wo), Sa(fv)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["fa-layers"]
            ], hostVars: 2, hostBindings: function(t, e) { 2 & t && no("fa-fw", e.fixedWidth) }, inputs: { fixedWidth: "fixedWidth", size: "size" }, features: [Ro], ngContentSelectors: uv, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(dv), Wa(0)) }, encapsulation: 2 }), t })(), xv = (() => { let t = class { constructor(t, e) { this.parent = t, this.sanitizer = e, this.classes = [], wv(this.parent, "FaLayersComponent", this.constructor.name) } ngOnChanges(t) { if (t) { const t = this.buildParams();
                    this.updateContent(t) } } buildParams() { return { title: this.title, classes: this.classes, styles: this.styles } } updateContent(t) { this.renderedHTML = this.sanitizer.bypassSecurityTrustHtml(function(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        i = e.title,
                        n = void 0 === i ? null : i,
                        s = e.classes,
                        r = void 0 === s ? [] : s,
                        a = e.attributes,
                        o = void 0 === a ? {} : a,
                        l = e.styles,
                        c = void 0 === l ? {} : l; return sv({ type: "counter", content: t }, (function() { return nv(), Gy({ content: t.toString(), title: n, extra: { attributes: o, styles: c, classes: ["".concat(my.familyPrefix, "-layers-counter")].concat(Jb(r)) } }) })) }(this.content || "", t).html.join("")) } }; return t.\u0275fac = function(e) { return new(e || t)(Sa(Cv, 8), Sa(Au)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["fa-layers-counter"]
            ], hostAttrs: [1, "ng-fa-layers-counter"], hostVars: 1, hostBindings: function(t, e) { 2 & t && xo("innerHTML", e.renderedHTML, Kn) }, inputs: { classes: "classes", content: "content", title: "title", styles: "styles" }, features: [Ro], decls: 0, vars: 0, template: function(t, e) {}, encapsulation: 2 }), t })(), Sv = (() => { let t = class { constructor(t, e) { this.parent = t, this.sanitizer = e, this.classes = [], wv(this.parent, "FaLayersComponent", this.constructor.name) } ngOnChanges(t) { if (t) { const t = this.buildParams();
                    this.updateContent(t) } } buildParams() { const t = { flip: this.flip, spin: this.spin, pulse: this.pulse, border: this.border, inverse: this.inverse, size: this.size || null, pull: this.pull || null, rotate: this.rotate || null, fixedWidth: this.fixedWidth }; return { transform: "string" == typeof this.transform ? cv(this.transform) : this.transform, classes: [..._v(t), ...this.classes], title: this.title, styles: this.styles } } updateContent(t) { this.renderedHTML = this.sanitizer.bypassSecurityTrustHtml(function(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        i = e.transform,
                        n = void 0 === i ? Py : i,
                        s = e.title,
                        r = void 0 === s ? null : s,
                        a = e.classes,
                        o = void 0 === a ? [] : a,
                        l = e.attributes,
                        c = void 0 === l ? {} : l,
                        h = e.styles,
                        d = void 0 === h ? {} : h; return sv({ type: "text", content: t }, (function() { return nv(), jy({ content: t, transform: Zb({}, Py, n), title: r, extra: { attributes: c, styles: d, classes: ["".concat(my.familyPrefix, "-layers-text")].concat(Jb(o)) } }) })) }(this.content || "", t).html.join("\n")) } }; return t.\u0275fac = function(e) { return new(e || t)(Sa(Cv, 8), Sa(Au)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["fa-layers-text"]
            ], hostAttrs: [1, "ng-fa-layers-text"], hostVars: 1, hostBindings: function(t, e) { 2 & t && xo("innerHTML", e.renderedHTML, Kn) }, inputs: { classes: "classes", content: "content", title: "title", styles: "styles", spin: "spin", pulse: "pulse", flip: "flip", size: "size", pull: "pull", border: "border", inverse: "inverse", rotate: "rotate", fixedWidth: "fixedWidth", transform: "transform" }, features: [Ro], decls: 0, vars: 0, template: function(t, e) {}, encapsulation: 2 }), t })(), kv = (() => { let t = class { constructor(t, e) { this.renderer = t, this.elementRef = e } ngOnInit() { this.renderer.addClass(this.elementRef.nativeElement, "fa-stack") } ngOnChanges(t) { "size" in t && (null != t.size.currentValue && this.renderer.addClass(this.elementRef.nativeElement, `fa-${t.size.currentValue}`), null != t.size.previousValue && this.renderer.removeClass(this.elementRef.nativeElement, `fa-${t.size.previousValue}`)) } }; return t.\u0275fac = function(e) { return new(e || t)(Sa(Ko), Sa(Wo)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["fa-stack"]
            ], inputs: { size: "size" }, features: [Ro], ngContentSelectors: pv, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(mv), Wa(0)) }, encapsulation: 2 }), t })(), Ev = (() => { let t = class {}; return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })();
    const Dv = ln(vv);
    let Av = (() => { let t = class { constructor(t, e) { this.document = t, this.platformId = e, this.documentIsAccessible = tu(this.platformId) } check(t) { return !!this.documentIsAccessible && (t = encodeURIComponent(t), this.getCookieRegExp(t).test(this.document.cookie)) } get(t) { if (this.documentIsAccessible && this.check(t)) { t = encodeURIComponent(t); const e = this.getCookieRegExp(t).exec(this.document.cookie); return this.safeDecodeURIComponent(e[1]) } return "" } getAll() { if (!this.documentIsAccessible) return {}; const t = {},
                    e = this.document; return e.cookie && "" !== e.cookie && e.cookie.split(";").forEach(e => { const [i, n] = e.split("=");
                    t[this.safeDecodeURIComponent(i.replace(/^ /, ""))] = this.safeDecodeURIComponent(n) }), t } set(t, e, i, n, s, r, a = "Lax") { if (!this.documentIsAccessible) return; let o = encodeURIComponent(t) + "=" + encodeURIComponent(e) + ";";
                i && (o += "number" == typeof i ? "expires=" + new Date((new Date).getTime() + 1e3 * i * 60 * 60 * 24).toUTCString() + ";" : "expires=" + i.toUTCString() + ";"), n && (o += "path=" + n + ";"), s && (o += "domain=" + s + ";"), !1 === r && "None" === a && (r = !0, console.warn(`[ngx-cookie-service] Cookie ${t} was forced with secure flag because sameSite=None.` + "More details : https://github.com/stevermeister/ngx-cookie-service/issues/86#issuecomment-597720130")), r && (o += "secure;"), o += "sameSite=" + a + ";", this.document.cookie = o } delete(t, e, i, n, s = "Lax") { this.documentIsAccessible && this.set(t, "", new Date("Thu, 01 Jan 1970 00:00:01 GMT"), e, i, n, s) } deleteAll(t, e, i, n = "Lax") { if (!this.documentIsAccessible) return; const s = this.getAll(); for (const r in s) s.hasOwnProperty(r) && this.delete(r, t, e, i, n) } getCookieRegExp(t) { const e = t.replace(/([\[\]\{\}\(\)\|\=\;\+\?\,\.\*\^\$])/gi, "\\$1"); return new RegExp("(?:^" + e + "|;\\s*" + e + ")=(.*?)(?:;|$)", "g") } safeDecodeURIComponent(t) { try { return decodeURIComponent(t) } catch (e) { return t } } }; return t.\u0275fac = function(e) { return new(e || t)(Xt(uh), Xt(bc)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(uh), Xt(bc)) }, token: t, providedIn: "root" }), t })();

    function Iv(t, ...e) { return e.length ? e.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey } class Tv extends d { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class Ov extends Tv { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this;
            this.state = t; const i = this.id,
                n = this.scheduler; return null != i && (this.id = this.recycleAsyncId(n, i, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(n, this.id, e), this } requestAsyncId(t, e, i = 0) { return setInterval(t.flush.bind(t, this), i) } recycleAsyncId(t, e, i = 0) { if (null !== i && this.delay === i && !1 === this.pending) return e;
            clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action");
            this.pending = !1; const i = this._execute(t, e); if (i) return i;!1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let i = !1,
                n = void 0; try { this.work(t) } catch (L$) { i = !0, n = !!L$ && L$ || new Error(L$) } if (i) return this.unsubscribe(), n } _unsubscribe() { const t = this.id,
                e = this.scheduler,
                i = e.actions,
                n = i.indexOf(this);
            this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== n && i.splice(n, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } }
    let Rv = (() => { class t { constructor(e, i = t.now) { this.SchedulerAction = e, this.now = i } schedule(t, e = 0, i) { return new this.SchedulerAction(this, t).schedule(i, e) } } return t.now = () => Date.now(), t })(); class Mv extends Rv { constructor(t, e = Rv.now) { super(t, () => Mv.delegate && Mv.delegate !== this ? Mv.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, i) { return Mv.delegate && Mv.delegate !== this ? Mv.delegate.schedule(t, e, i) : super.schedule(t, e, i) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let i;
            this.active = !0;
            do { if (i = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, i) { for (; t = e.shift();) t.unsubscribe(); throw i } } }
    const Pv = new Mv(Ov);

    function Fv(t, e = Pv) { return i => i.lift(new Nv(t, e)) } class Nv { constructor(t, e) { this.dueTime = t, this.scheduler = e } call(t, e) { return e.subscribe(new Lv(t, this.dueTime, this.scheduler)) } } class Lv extends p { constructor(t, e, i) { super(t), this.dueTime = e, this.scheduler = i, this.debouncedSubscription = null, this.lastValue = null, this.hasValue = !1 } _next(t) { this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(Bv, this.dueTime, this)) } _complete() { this.debouncedNext(), this.destination.complete() } debouncedNext() { if (this.clearDebounce(), this.hasValue) { const { lastValue: t } = this;
                this.lastValue = null, this.hasValue = !1, this.destination.next(t) } } clearDebounce() { const t = this.debouncedSubscription;
            null !== t && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null) } }

    function Bv(t) { t.debouncedNext() }

    function Vv(t) { return null != t && "false" !== `${t}` }

    function zv(t, e = 0) { return function(t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) }(t) ? Number(t) : e }

    function Uv(t) { return Array.isArray(t) ? t : [t] }

    function Hv(t) { return null == t ? "" : "string" == typeof t ? t : `${t}px` }

    function jv(t) { return t instanceof Wo ? t.nativeElement : t }
    let Gv;
    try { Gv = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (B$) { Gv = !1 }
    let $v, Wv = (() => { class t { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? tu(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !Gv) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function(e) { return new(e || t)(Xt(bc, 8)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(bc, 8)) }, token: t, providedIn: "root" }), t })(), qv = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })();
    const Yv = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"];

    function Xv() { if ($v) return $v; if ("object" != typeof document || !document) return $v = new Set(Yv), $v; let t = document.createElement("input"); return $v = new Set(Yv.filter(e => (t.setAttribute("type", e), t.type === e))), $v }
    let Kv, Zv, Qv;

    function Jv(t) { return function() { if (null == Kv && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => Kv = !0 })) } finally { Kv = Kv || !1 }
            return Kv }() ? t : !!t.capture }

    function tw() { if ("object" != typeof document || !document) return 0; if (null == Zv) { const t = document.createElement("div"),
                e = t.style;
            t.dir = "rtl", e.height = "1px", e.width = "1px", e.overflow = "auto", e.visibility = "hidden", e.pointerEvents = "none", e.position = "absolute"; const i = document.createElement("div"),
                n = i.style;
            n.width = "2px", n.height = "1px", t.appendChild(i), document.body.appendChild(t), Zv = 0, 0 === t.scrollLeft && (t.scrollLeft = 1, Zv = 0 === t.scrollLeft ? 1 : 2), t.parentNode.removeChild(t) } return Zv }

    function ew(t) { if (function() { if (null == Qv) { const t = "undefined" != typeof document ? document.head : null;
                    Qv = !(!t || !t.createShadowRoot && !t.attachShadow) } return Qv }()) { const e = t.getRootNode ? t.getRootNode() : null; if (e instanceof ShadowRoot) return e } return null }
    let iw = (() => { class t { create(t) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(t) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return new t }, token: t, providedIn: "root" }), t })(), nw = (() => { class t { constructor(t) { this._mutationObserverFactory = t, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((t, e) => this._cleanupObserver(e)) } observe(t) { const e = jv(t); return new v(t => { const i = this._observeElement(e).subscribe(t); return () => { i.unsubscribe(), this._unobserveElement(e) } }) } _observeElement(t) { if (this._observedElements.has(t)) this._observedElements.get(t).count++;
                else { const e = new k,
                        i = this._mutationObserverFactory.create(t => e.next(t));
                    i && i.observe(t, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(t, { observer: i, stream: e, count: 1 }) } return this._observedElements.get(t).stream } _unobserveElement(t) { this._observedElements.has(t) && (this._observedElements.get(t).count--, this._observedElements.get(t).count || this._cleanupObserver(t)) } _cleanupObserver(t) { if (this._observedElements.has(t)) { const { observer: e, stream: i } = this._observedElements.get(t);
                    e && e.disconnect(), i.complete(), this._observedElements.delete(t) } } } return t.\u0275fac = function(e) { return new(e || t)(Xt(iw)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(iw)) }, token: t, providedIn: "root" }), t })(), sw = (() => { class t { constructor(t, e, i) { this._contentObserver = t, this._elementRef = e, this._ngZone = i, this.event = new jl, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(t) { this._disabled = Vv(t), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(t) { this._debounce = zv(t), this._subscribe() } ngAfterContentInit() { this._currentSubscription || this.disabled || this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const t = this._contentObserver.observe(this._elementRef);
                this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? t.pipe(Fv(this.debounce)) : t).subscribe(this.event) }) } _unsubscribe() { this._currentSubscription && this._currentSubscription.unsubscribe() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(nw), Sa(Wo), Sa(Pc)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkObserveContent", ""]
            ], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), t })(), rw = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [iw] }), t })();

    function aw(t, e) { return (t.getAttribute(e) || "").match(/\S+/g) || [] }
    let ow = 0;
    const lw = new Map;
    let cw = null, hw = (() => { class t { constructor(t) { this._document = t } describe(t, e) { this._canBeDescribed(t, e) && ("string" != typeof e ? (this._setMessageId(e), lw.set(e, { messageElement: e, referenceCount: 0 })) : lw.has(e) || this._createMessageElement(e), this._isElementDescribedByMessage(t, e) || this._addMessageReference(t, e)) } removeDescription(t, e) { if (this._isElementNode(t)) { if (this._isElementDescribedByMessage(t, e) && this._removeMessageReference(t, e), "string" == typeof e) { const t = lw.get(e);
                        t && 0 === t.referenceCount && this._deleteMessageElement(e) } cw && 0 === cw.childNodes.length && this._deleteMessagesContainer() } } ngOnDestroy() { const t = this._document.querySelectorAll("[cdk-describedby-host]"); for (let e = 0; e < t.length; e++) this._removeCdkDescribedByReferenceIds(t[e]), t[e].removeAttribute("cdk-describedby-host");
                cw && this._deleteMessagesContainer(), lw.clear() } _createMessageElement(t) { const e = this._document.createElement("div");
                this._setMessageId(e), e.textContent = t, this._createMessagesContainer(), cw.appendChild(e), lw.set(t, { messageElement: e, referenceCount: 0 }) } _setMessageId(t) { t.id || (t.id = `cdk-describedby-message-${ow++}`) } _deleteMessageElement(t) { const e = lw.get(t),
                    i = e && e.messageElement;
                cw && i && cw.removeChild(i), lw.delete(t) } _createMessagesContainer() { if (!cw) { const t = this._document.getElementById("cdk-describedby-message-container");
                    t && t.parentNode.removeChild(t), cw = this._document.createElement("div"), cw.id = "cdk-describedby-message-container", cw.setAttribute("aria-hidden", "true"), cw.style.display = "none", this._document.body.appendChild(cw) } } _deleteMessagesContainer() { cw && cw.parentNode && (cw.parentNode.removeChild(cw), cw = null) } _removeCdkDescribedByReferenceIds(t) { const e = aw(t, "aria-describedby").filter(t => 0 != t.indexOf("cdk-describedby-message"));
                t.setAttribute("aria-describedby", e.join(" ")) } _addMessageReference(t, e) { const i = lw.get(e);! function(t, e, i) { const n = aw(t, e);
                    n.some(t => t.trim() == i.trim()) || (n.push(i.trim()), t.setAttribute(e, n.join(" "))) }(t, "aria-describedby", i.messageElement.id), t.setAttribute("cdk-describedby-host", ""), i.referenceCount++ } _removeMessageReference(t, e) { const i = lw.get(e);
                i.referenceCount--,
                    function(t, e, i) { const n = aw(t, e).filter(t => t != i.trim());
                        n.length ? t.setAttribute(e, n.join(" ")) : t.removeAttribute(e) }(t, "aria-describedby", i.messageElement.id), t.removeAttribute("cdk-describedby-host") } _isElementDescribedByMessage(t, e) { const i = aw(t, "aria-describedby"),
                    n = lw.get(e),
                    s = n && n.messageElement.id; return !!s && -1 != i.indexOf(s) } _canBeDescribed(t, e) { if (!this._isElementNode(t)) return !1; if (e && "object" == typeof e) return !0; const i = null == e ? "" : `${e}`.trim(),
                    n = t.getAttribute("aria-label"); return !(!i || n && n.trim() === i) } _isElementNode(t) { return t.nodeType === this._document.ELEMENT_NODE } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(uh)) }, token: t, providedIn: "root" }), t })(); class dw { constructor(t) { this._items = t, this._activeItemIndex = -1, this._activeItem = null, this._wrap = !1, this._letterKeyStream = new k, this._typeaheadSubscription = d.EMPTY, this._vertical = !0, this._allowedModifierKeys = [], this._skipPredicateFn = t => t.disabled, this._pressedLetters = [], this.tabOut = new k, this.change = new k, t instanceof $l && t.changes.subscribe(t => { if (this._activeItem) { const e = t.toArray().indexOf(this._activeItem);
                    e > -1 && e !== this._activeItemIndex && (this._activeItemIndex = e) } }) } skipPredicate(t) { return this._skipPredicateFn = t, this } withWrap(t = !0) { return this._wrap = t, this } withVerticalOrientation(t = !0) { return this._vertical = t, this } withHorizontalOrientation(t) { return this._horizontal = t, this } withAllowedModifierKeys(t) { return this._allowedModifierKeys = t, this } withTypeAhead(t = 200) { if (this._items.length && this._items.some(t => "function" != typeof t.getLabel)) throw Error("ListKeyManager items in typeahead mode must implement the `getLabel` method."); return this._typeaheadSubscription.unsubscribe(), this._typeaheadSubscription = this._letterKeyStream.pipe(Sm(t => this._pressedLetters.push(t)), Fv(t), Gu(() => this._pressedLetters.length > 0), L(() => this._pressedLetters.join(""))).subscribe(t => { const e = this._getItemsArray(); for (let i = 1; i < e.length + 1; i++) { const n = (this._activeItemIndex + i) % e.length,
                        s = e[n]; if (!this._skipPredicateFn(s) && 0 === s.getLabel().toUpperCase().trim().indexOf(t)) { this.setActiveItem(n); break } } this._pressedLetters = [] }), this } setActiveItem(t) { const e = this._activeItemIndex;
            this.updateActiveItem(t), this._activeItemIndex !== e && this.change.next(this._activeItemIndex) } onKeydown(t) { const e = t.keyCode,
                i = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(e => !t[e] || this._allowedModifierKeys.indexOf(e) > -1); switch (e) {
                case 9:
                    return void this.tabOut.next();
                case 40:
                    if (this._vertical && i) { this.setNextItemActive(); break } return;
                case 38:
                    if (this._vertical && i) { this.setPreviousItemActive(); break } return;
                case 39:
                    if (this._horizontal && i) { "rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive(); break } return;
                case 37:
                    if (this._horizontal && i) { "rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive(); break } return;
                default:
                    return void((i || Iv(t, "shiftKey")) && (t.key && 1 === t.key.length ? this._letterKeyStream.next(t.key.toLocaleUpperCase()) : (e >= 65 && e <= 90 || e >= 48 && e <= 57) && this._letterKeyStream.next(String.fromCharCode(e)))) } this._pressedLetters = [], t.preventDefault() } get activeItemIndex() { return this._activeItemIndex } get activeItem() { return this._activeItem } isTyping() { return this._pressedLetters.length > 0 } setFirstItemActive() { this._setActiveItemByIndex(0, 1) } setLastItemActive() { this._setActiveItemByIndex(this._items.length - 1, -1) } setNextItemActive() { this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1) } setPreviousItemActive() { this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1) } updateActiveItem(t) { const e = this._getItemsArray(),
                i = "number" == typeof t ? t : e.indexOf(t),
                n = e[i];
            this._activeItem = null == n ? null : n, this._activeItemIndex = i } _setActiveItemByDelta(t) { this._wrap ? this._setActiveInWrapMode(t) : this._setActiveInDefaultMode(t) } _setActiveInWrapMode(t) { const e = this._getItemsArray(); for (let i = 1; i <= e.length; i++) { const n = (this._activeItemIndex + t * i + e.length) % e.length; if (!this._skipPredicateFn(e[n])) return void this.setActiveItem(n) } } _setActiveInDefaultMode(t) { this._setActiveItemByIndex(this._activeItemIndex + t, t) } _setActiveItemByIndex(t, e) { const i = this._getItemsArray(); if (i[t]) { for (; this._skipPredicateFn(i[t]);)
                    if (!i[t += e]) return;
                this.setActiveItem(t) } } _getItemsArray() { return this._items instanceof $l ? this._items.toArray() : this._items } } class uw extends dw { setActiveItem(t) { this.activeItem && this.activeItem.setInactiveStyles(), super.setActiveItem(t), this.activeItem && this.activeItem.setActiveStyles() } } class mw extends dw { constructor() { super(...arguments), this._origin = "program" } setFocusOrigin(t) { return this._origin = t, this } setActiveItem(t) { super.setActiveItem(t), this.activeItem && this.activeItem.focus(this._origin) } }
    let pw = (() => { class t { constructor(t) { this._platform = t } isDisabled(t) { return t.hasAttribute("disabled") } isVisible(t) { return function(t) { return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length) }(t) && "visible" === getComputedStyle(t).visibility } isTabbable(t) { if (!this._platform.isBrowser) return !1; const e = function(t) { try { return t.frameElement } catch (B$) { return null } }((i = t).ownerDocument && i.ownerDocument.defaultView || window); var i; if (e) { const t = e && e.nodeName.toLowerCase(); if (-1 === gw(e)) return !1; if ((this._platform.BLINK || this._platform.WEBKIT) && "object" === t) return !1; if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(e)) return !1 } let n = t.nodeName.toLowerCase(),
                    s = gw(t); if (t.hasAttribute("contenteditable")) return -1 !== s; if ("iframe" === n) return !1; if ("audio" === n) { if (!t.hasAttribute("controls")) return !1; if (this._platform.BLINK) return !0 } if ("video" === n) { if (!t.hasAttribute("controls") && this._platform.TRIDENT) return !1; if (this._platform.BLINK || this._platform.FIREFOX) return !0 } return ("object" !== n || !this._platform.BLINK && !this._platform.WEBKIT) && !(this._platform.WEBKIT && this._platform.IOS && ! function(t) { let e = t.nodeName.toLowerCase(),
                        i = "input" === e && t.type; return "text" === i || "password" === i || "select" === e || "textarea" === e }(t)) && t.tabIndex >= 0 } isFocusable(t) { return function(t) { return ! function(t) { return function(t) { return "input" == t.nodeName.toLowerCase() }(t) && "hidden" == t.type }(t) && (function(t) { let e = t.nodeName.toLowerCase(); return "input" === e || "select" === e || "button" === e || "textarea" === e }(t) || function(t) { return function(t) { return "a" == t.nodeName.toLowerCase() }(t) && t.hasAttribute("href") }(t) || t.hasAttribute("contenteditable") || fw(t)) }(t) && !this.isDisabled(t) && this.isVisible(t) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Wv)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(Wv)) }, token: t, providedIn: "root" }), t })();

    function fw(t) { if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1; let e = t.getAttribute("tabindex"); return "-32768" != e && !(!e || isNaN(parseInt(e, 10))) }

    function gw(t) { if (!fw(t)) return null; const e = parseInt(t.getAttribute("tabindex") || "", 10); return isNaN(e) ? -1 : e } class _w { constructor(t, e, i, n, s = !1) { this._element = t, this._checker = e, this._ngZone = i, this._document = n, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, s || this.attachAnchors() } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } destroy() { const t = this._startAnchor,
                e = this._endAnchor;
            t && (t.removeEventListener("focus", this.startAnchorListener), t.parentNode && t.parentNode.removeChild(t)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusInitialElement())) }) } focusFirstTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusFirstTabbableElement())) }) } focusLastTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusLastTabbableElement())) }) } _getRegionBoundary(t) { let e = this._element.querySelectorAll(`[cdk-focus-region-${t}], ` + `[cdkFocusRegion${t}], ` + `[cdk-focus-${t}]`); for (let i = 0; i < e.length; i++) e[i].hasAttribute(`cdk-focus-${t}`) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', ` + `use 'cdkFocusRegion${t}' instead. The deprecated ` + "attribute will be removed in 8.0.0.", e[i]) : e[i].hasAttribute(`cdk-focus-region-${t}`) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', ` + `use 'cdkFocusRegion${t}' instead. The deprecated attribute ` + "will be removed in 8.0.0.", e[i]); return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement() { const t = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); return t ? (t.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", t), Sn() && !this._checker.isFocusable(t) && console.warn("Element matching '[cdkFocusInitial]' is not focusable.", t), t.focus(), !0) : this.focusFirstTabbableElement() } focusFirstTabbableElement() { const t = this._getRegionBoundary("start"); return t && t.focus(), !!t } focusLastTabbableElement() { const t = this._getRegionBoundary("end"); return t && t.focus(), !!t } hasAttached() { return this._hasAttached } _getFirstTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let i = 0; i < e.length; i++) { let t = e[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[i]) : null; if (t) return t } return null } _getLastTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let i = e.length - 1; i >= 0; i--) { let t = e[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[i]) : null; if (t) return t } return null } _createAnchor() { const t = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t } _toggleAnchorTabIndex(t, e) { t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex") } toggleAnchors(t) { this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } _executeOnStable(t) { this._ngZone.isStable ? t() : this._ngZone.onStable.asObservable().pipe(lm(1)).subscribe(t) } }
    let bw = (() => { class t { constructor(t, e, i) { this._checker = t, this._ngZone = e, this._document = i } create(t, e = !1) { return new _w(t, this._checker, this._ngZone, this._document, e) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(pw), Xt(Pc), Xt(uh)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(pw), Xt(Pc), Xt(uh)) }, token: t, providedIn: "root" }), t })(), yw = (() => { class t { constructor(t, e, i) { this._elementRef = t, this._focusTrapFactory = e, this._previouslyFocusedElement = null, this._document = i, this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, !0) } get enabled() { return this.focusTrap.enabled } set enabled(t) { this.focusTrap.enabled = Vv(t) } get autoCapture() { return this._autoCapture } set autoCapture(t) { this._autoCapture = Vv(t) } ngOnDestroy() { this.focusTrap.destroy(), this._previouslyFocusedElement && (this._previouslyFocusedElement.focus(), this._previouslyFocusedElement = null) } ngAfterContentInit() { this.focusTrap.attachAnchors(), this.autoCapture && (this._previouslyFocusedElement = this._document.activeElement, this.focusTrap.focusInitialElementWhenReady()) } ngDoCheck() { this.focusTrap.hasAttached() || this.focusTrap.attachAnchors() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(bw), Sa(uh)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkTrapFocus", ""]
            ], inputs: { enabled: ["cdkTrapFocus", "enabled"], autoCapture: ["cdkTrapFocusAutoCapture", "autoCapture"] }, exportAs: ["cdkTrapFocus"] }), t })();
    "undefined" != typeof Element && Element;
    const vw = new Vt("liveAnnouncerElement", { providedIn: "root", factory: function() { return null } }), ww = new Vt("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
    let Cw = (() => { class t { constructor(t, e, i, n) { this._ngZone = e, this._defaultOptions = n, this._document = i, this._liveElement = t || this._createLiveElement() } announce(t, ...e) { const i = this._defaultOptions; let n, s; return 1 === e.length && "number" == typeof e[0] ? s = e[0] : [n, s] = e, this.clear(), clearTimeout(this._previousTimeout), n || (n = i && i.politeness ? i.politeness : "polite"), null == s && i && (s = i.duration), this._liveElement.setAttribute("aria-live", n), this._ngZone.runOutsideAngular(() => new Promise(e => { clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => { this._liveElement.textContent = t, e(), "number" == typeof s && (this._previousTimeout = setTimeout(() => this.clear(), s)) }, 100) })) } clear() { this._liveElement && (this._liveElement.textContent = "") } ngOnDestroy() { clearTimeout(this._previousTimeout), this._liveElement && this._liveElement.parentNode && (this._liveElement.parentNode.removeChild(this._liveElement), this._liveElement = null) } _createLiveElement() { const t = this._document.getElementsByClassName("cdk-live-announcer-element"),
                    e = this._document.createElement("div"); for (let i = 0; i < t.length; i++) t[i].parentNode.removeChild(t[i]); return e.classList.add("cdk-live-announcer-element"), e.classList.add("cdk-visually-hidden"), e.setAttribute("aria-atomic", "true"), e.setAttribute("aria-live", "polite"), this._document.body.appendChild(e), e } } return t.\u0275fac = function(e) { return new(e || t)(Xt(vw, 8), Xt(Pc), Xt(uh), Xt(ww, 8)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(vw, 8), Xt(Pc), Xt(uh), Xt(ww, 8)) }, token: t, providedIn: "root" }), t })(), xw = (() => { class t { constructor(t, e, i, n) { this._elementRef = t, this._liveAnnouncer = e, this._contentObserver = i, this._ngZone = n, this._politeness = "off" } get politeness() { return this._politeness } set politeness(t) { this._politeness = "polite" === t || "assertive" === t ? t : "off", "off" === this._politeness ? this._subscription && (this._subscription.unsubscribe(), this._subscription = null) : this._subscription || (this._subscription = this._ngZone.runOutsideAngular(() => this._contentObserver.observe(this._elementRef).subscribe(() => { const t = this._elementRef.nativeElement.textContent;
                    t !== this._previousAnnouncedText && (this._liveAnnouncer.announce(t, this._politeness), this._previousAnnouncedText = t) }))) } ngOnDestroy() { this._subscription && this._subscription.unsubscribe() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Cw), Sa(nw), Sa(Pc)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkAriaLive", ""]
            ], inputs: { politeness: ["cdkAriaLive", "politeness"] }, exportAs: ["cdkAriaLive"] }), t })();
    const Sw = new Vt("cdk-focus-monitor-default-options"), kw = Jv({ passive: !0, capture: !0 });
    let Ew = (() => { class t { constructor(t, e, i, n) { this._ngZone = t, this._platform = e, this._origin = null, this._windowFocused = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._documentKeydownListener = () => { this._lastTouchTarget = null, this._setOriginForCurrentEventQueue("keyboard") }, this._documentMousedownListener = () => { this._lastTouchTarget || this._setOriginForCurrentEventQueue("mouse") }, this._documentTouchstartListener = t => { null != this._touchTimeoutId && clearTimeout(this._touchTimeoutId), this._lastTouchTarget = t.composedPath ? t.composedPath()[0] : t.target, this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, 650) }, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1) }, this._document = i, this._detectionMode = (null == n ? void 0 : n.detectionMode) || 0 } monitor(t, e = !1) { if (!this._platform.isBrowser) return Mu(null); const i = jv(t); if (this._elementInfo.has(i)) { let t = this._elementInfo.get(i); return t.checkChildren = e, t.subject.asObservable() } let n = { unlisten: () => {}, checkChildren: e, subject: new k };
                this._elementInfo.set(i, n), this._incrementMonitoredElementCount(); let s = t => this._onFocus(t, i),
                    r = t => this._onBlur(t, i); return this._ngZone.runOutsideAngular(() => { i.addEventListener("focus", s, !0), i.addEventListener("blur", r, !0) }), n.unlisten = () => { i.removeEventListener("focus", s, !0), i.removeEventListener("blur", r, !0) }, n.subject.asObservable() } stopMonitoring(t) { const e = jv(t),
                    i = this._elementInfo.get(e);
                i && (i.unlisten(), i.subject.complete(), this._setClasses(e), this._elementInfo.delete(e), this._decrementMonitoredElementCount()) } focusVia(t, e, i) { const n = jv(t);
                this._setOriginForCurrentEventQueue(e), "function" == typeof n.focus && n.focus(i) } ngOnDestroy() { this._elementInfo.forEach((t, e) => this.stopMonitoring(e)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _toggleClass(t, e, i) { i ? t.classList.add(e) : t.classList.remove(e) } _setClasses(t, e) { this._elementInfo.get(t) && (this._toggleClass(t, "cdk-focused", !!e), this._toggleClass(t, "cdk-touch-focused", "touch" === e), this._toggleClass(t, "cdk-keyboard-focused", "keyboard" === e), this._toggleClass(t, "cdk-mouse-focused", "mouse" === e), this._toggleClass(t, "cdk-program-focused", "program" === e)) } _setOriginForCurrentEventQueue(t) { this._ngZone.runOutsideAngular(() => { this._origin = t, 0 === this._detectionMode && (this._originTimeoutId = setTimeout(() => this._origin = null, 1)) }) } _wasCausedByTouch(t) { let e = t.target; return this._lastTouchTarget instanceof Node && e instanceof Node && (e === this._lastTouchTarget || e.contains(this._lastTouchTarget)) } _onFocus(t, e) { const i = this._elementInfo.get(e); if (!i || !i.checkChildren && e !== t.target) return; let n = this._origin;
                n || (n = this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : this._wasCausedByTouch(t) ? "touch" : "program"), this._setClasses(e, n), this._emitOrigin(i.subject, n), this._lastFocusOrigin = n } _onBlur(t, e) { const i = this._elementInfo.get(e);!i || i.checkChildren && t.relatedTarget instanceof Node && e.contains(t.relatedTarget) || (this._setClasses(e), this._emitOrigin(i.subject, null)) } _emitOrigin(t, e) { this._ngZone.run(() => t.next(e)) } _incrementMonitoredElementCount() { 1 == ++this._monitoredElementCount && this._platform.isBrowser && this._ngZone.runOutsideAngular(() => { const t = this._getDocument(),
                        e = this._getWindow();
                    t.addEventListener("keydown", this._documentKeydownListener, kw), t.addEventListener("mousedown", this._documentMousedownListener, kw), t.addEventListener("touchstart", this._documentTouchstartListener, kw), e.addEventListener("focus", this._windowFocusListener) }) } _decrementMonitoredElementCount() { if (!--this._monitoredElementCount) { const t = this._getDocument(),
                        e = this._getWindow();
                    t.removeEventListener("keydown", this._documentKeydownListener, kw), t.removeEventListener("mousedown", this._documentMousedownListener, kw), t.removeEventListener("touchstart", this._documentTouchstartListener, kw), e.removeEventListener("focus", this._windowFocusListener), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._touchTimeoutId), clearTimeout(this._originTimeoutId) } } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Pc), Xt(Wv), Xt(uh, 8), Xt(Sw, 8)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(Pc), Xt(Wv), Xt(uh, 8), Xt(Sw, 8)) }, token: t, providedIn: "root" }), t })(), Dw = (() => { class t { constructor(t, e) { this._elementRef = t, this._focusMonitor = e, this.cdkFocusChange = new jl, this._monitorSubscription = this._focusMonitor.monitor(this._elementRef, this._elementRef.nativeElement.hasAttribute("cdkMonitorSubtreeFocus")).subscribe(t => this.cdkFocusChange.emit(t)) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef), this._monitorSubscription.unsubscribe() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Ew)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkMonitorElementFocus", ""],
                ["", "cdkMonitorSubtreeFocus", ""]
            ], outputs: { cdkFocusChange: "cdkFocusChange" } }), t })();

    function Aw(t) { return 0 === t.buttons }
    let Iw = (() => { class t { constructor(t, e) { this._platform = t, this._document = e } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const t = this._document.createElement("div");
                t.style.backgroundColor = "rgb(1,2,3)", t.style.position = "absolute", this._document.body.appendChild(t); const e = (this._document.defaultView.getComputedStyle(t).backgroundColor || "").replace(/ /g, ""); switch (this._document.body.removeChild(t), e) {
                    case "rgb(0,0,0)":
                        return 2;
                    case "rgb(255,255,255)":
                        return 1 } return 0 } _applyBodyHighContrastModeCssClasses() { if (this._platform.isBrowser && this._document.body) { const t = this._document.body.classList;
                    t.remove("cdk-high-contrast-active"), t.remove("cdk-high-contrast-black-on-white"), t.remove("cdk-high-contrast-white-on-black"); const e = this.getHighContrastMode();
                    1 === e ? (t.add("cdk-high-contrast-active"), t.add("cdk-high-contrast-black-on-white")) : 2 === e && (t.add("cdk-high-contrast-active"), t.add("cdk-high-contrast-white-on-black")) } } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Wv), Xt(uh)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(Wv), Xt(uh)) }, token: t, providedIn: "root" }), t })(), Tw = (() => { class t { constructor(t) { t._applyBodyHighContrastModeCssClasses() } } return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t)(Xt(Iw)) }, imports: [
                [qv, rw]
            ] }), t })();
    const Ow = new Vt("cdk-dir-doc", { providedIn: "root", factory: function() { return Kt(uh) } });
    let Rw = (() => { class t { constructor(t) { if (this.value = "ltr", this.change = new jl, t) { const e = t.documentElement ? t.documentElement.dir : null,
                        i = (t.body ? t.body.dir : null) || e;
                    this.value = "ltr" === i || "rtl" === i ? i : "ltr" } } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Ow, 8)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(Ow, 8)) }, token: t, providedIn: "root" }), t })(), Mw = (() => { class t { constructor() { this._dir = "ltr", this._isInitialized = !1, this.change = new jl } get dir() { return this._dir } set dir(t) { const e = this._dir,
                    i = t ? t.toLowerCase() : t;
                this._rawDir = t, this._dir = "ltr" === i || "rtl" === i ? i : "ltr", e !== this._dir && this._isInitialized && this.change.emit(this._dir) } get value() { return this.dir } ngAfterContentInit() { this._isInitialized = !0 } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "dir", ""]
            ], hostVars: 1, hostBindings: function(t, e) { 2 & t && va("dir", e._rawDir) }, inputs: { dir: "dir" }, outputs: { change: "dirChange" }, exportAs: ["dir"], features: [Ho([{ provide: Rw, useExisting: t }])] }), t })(), Pw = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })();
    const Fw = new Jo("9.2.0"); class Nw {}

    function Lw(t, e) { return { type: 7, name: t, definitions: e, options: {} } }

    function Bw(t, e = null) { return { type: 4, styles: e, timings: t } }

    function Vw(t, e = null) { return { type: 3, steps: t, options: e } }

    function zw(t, e = null) { return { type: 2, steps: t, options: e } }

    function Uw(t) { return { type: 6, styles: t, offset: null } }

    function Hw(t, e, i) { return { type: 0, name: t, styles: e, options: i } }

    function jw(t) { return { type: 5, steps: t } }

    function Gw(t, e, i = null) { return { type: 1, expr: t, animation: e, options: i } }

    function $w(t, e = null) { return { type: 8, animation: t, options: e } }

    function Ww(t = null) { return { type: 9, options: t } }

    function qw(t, e = null) { return { type: 10, animation: t, options: e } }

    function Yw(t, e, i = null) { return { type: 11, selector: t, animation: e, options: i } }

    function Xw(t) { Promise.resolve(null).then(t) } class Kw { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() {} play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { Xw(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() {} restart() {} finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() {} setPosition(t) {} getPosition() { return 0 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns;
            e.forEach(t => t()), e.length = 0 } } class Zw { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0,
                i = 0,
                n = 0; const s = this.players.length;
            0 == s ? Xw(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => {++e == s && this._onFinish() }), t.onDestroy(() => {++i == s && this._onDestroy() }), t.onStart(() => {++n == s && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime;
            this.players.forEach(t => { const i = t.totalTime ? Math.min(1, e / t.totalTime) : 1;
                t.setPosition(i) }) } getPosition() { let t = 0; return this.players.forEach(e => { const i = e.getPosition();
                t = Math.min(i, t) }), t } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns;
            e.forEach(t => t()), e.length = 0 } }

    function Qw() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) }

    function Jw(t) { switch (t.length) {
            case 0:
                return new Kw;
            case 1:
                return t[0];
            default:
                return new Zw(t) } }

    function tC(t, e, i, n, s = {}, r = {}) { const a = [],
            o = []; let l = -1,
            c = null; if (n.forEach(t => { const i = t.offset,
                    n = i == l,
                    h = n && c || {};
                Object.keys(t).forEach(i => { let n = i,
                        o = t[i]; if ("offset" !== i) switch (n = e.normalizePropertyName(n, a), o) {
                        case "!":
                            o = s[i]; break;
                        case "*":
                            o = r[i]; break;
                        default:
                            o = e.normalizeStyleValue(i, n, o, a) } h[n] = o }), n || o.push(h), c = h, l = i }), a.length) { const t = "\n - "; throw new Error(`Unable to animate due to the following errors:${t}${a.join(t)}`) } return o }

    function eC(t, e, i, n) { switch (e) {
            case "start":
                t.onStart(() => n(i && iC(i, "start", t))); break;
            case "done":
                t.onDone(() => n(i && iC(i, "done", t))); break;
            case "destroy":
                t.onDestroy(() => n(i && iC(i, "destroy", t))) } }

    function iC(t, e, i) { const n = i.totalTime,
            s = nC(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == n ? t.totalTime : n, !!i.disabled),
            r = t._data; return null != r && (s._data = r), s }

    function nC(t, e, i, n, s = "", r = 0, a) { return { element: t, triggerName: e, fromState: i, toState: n, phaseName: s, totalTime: r, disabled: !!a } }

    function sC(t, e, i) { let n; return t instanceof Map ? (n = t.get(e), n || t.set(e, n = i)) : (n = t[e], n || (n = t[e] = i)), n }

    function rC(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] }
    let aC = (t, e) => !1, oC = (t, e) => !1, lC = (t, e, i) => [];
    const cC = Qw();
    (cC || "undefined" != typeof Element) && (aC = (t, e) => t.contains(e), oC = (() => { if (cC || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype,
                e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, i) => e.apply(t, [i]) : oC } })(), lC = (t, e, i) => { let n = []; if (i) n.push(...t.querySelectorAll(e));
        else { const i = t.querySelector(e);
            i && n.push(i) } return n });
    let hC = null, dC = !1;

    function uC(t) { hC || (hC = ("undefined" != typeof document ? document.body : null) || {}, dC = !!hC.style && "WebkitAppearance" in hC.style); let e = !0; return hC.style && ! function(t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in hC.style, !e && dC) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in hC.style), e }
    const mC = oC, pC = aC, fC = lC;

    function gC(t) { const e = {}; return Object.keys(t).forEach(i => { const n = i.replace(/([a-z])([A-Z])/g, "$1-$2");
            e[n] = t[i] }), e }
    let _C = (() => { class t { validateStyleProperty(t) { return uC(t) } matchesElement(t, e) { return mC(t, e) } containsElement(t, e) { return pC(t, e) } query(t, e, i) { return fC(t, e, i) } computeStyle(t, e, i) { return i || "" } animate(t, e, i, n, s, r = [], a) { return new Kw(i, n) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), bC = (() => { class t {} return t.NOOP = new _C, t })();

    function yC(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : vC(parseFloat(e[1]), e[2]) }

    function vC(t, e) { switch (e) {
            case "s":
                return 1e3 * t;
            default:
                return t } }

    function wC(t, e, i) { return t.hasOwnProperty("duration") ? t : function(t, e, i) { let n, s = 0,
                r = ""; if ("string" == typeof t) { const i = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === i) return e.push(`The provided timing value "${t}" is invalid.`), { duration: 0, delay: 0, easing: "" };
                n = vC(parseFloat(i[1]), i[2]); const a = i[3];
                null != a && (s = vC(parseFloat(a), i[4])); const o = i[5];
                o && (r = o) } else n = t; if (!i) { let i = !1,
                    r = e.length;
                n < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), i = !0), s < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), i = !0), i && e.splice(r, 0, `The provided timing value "${t}" is invalid.`) } return { duration: n, delay: s, easing: r } }(t, e, i) }

    function CC(t, e = {}) { return Object.keys(t).forEach(i => { e[i] = t[i] }), e }

    function xC(t, e, i = {}) { if (e)
            for (let n in t) i[n] = t[n];
        else CC(t, i); return i }

    function SC(t, e, i) { return i ? e + ":" + i + ";" : "" }

    function kC(t) { let e = ""; for (let i = 0; i < t.style.length; i++) { const n = t.style.item(i);
            e += SC(0, n, t.style.getPropertyValue(n)) } for (const i in t.style) t.style.hasOwnProperty(i) && !i.startsWith("_") && (e += SC(0, i.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[i]));
        t.setAttribute("style", e) }

    function EC(t, e, i) { t.style && (Object.keys(e).forEach(n => { const s = PC(n);
            i && !i.hasOwnProperty(n) && (i[n] = t.style[s]), t.style[s] = e[n] }), Qw() && kC(t)) }

    function DC(t, e) { t.style && (Object.keys(e).forEach(e => { const i = PC(e);
            t.style[i] = "" }), Qw() && kC(t)) }

    function AC(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : zw(t) : t }
    const IC = new RegExp("{{\\s*(.+?)\\s*}}", "g");

    function TC(t) { let e = []; if ("string" == typeof t) { let i; for (; i = IC.exec(t);) e.push(i[1]);
            IC.lastIndex = 0 } return e }

    function OC(t, e, i) { const n = t.toString(),
            s = n.replace(IC, (t, n) => { let s = e[n]; return e.hasOwnProperty(n) || (i.push(`Please provide a value for the animation param ${n}`), s = ""), s.toString() }); return s == n ? t : s }

    function RC(t) { const e = []; let i = t.next(); for (; !i.done;) e.push(i.value), i = t.next(); return e }
    const MC = /-+([a-z0-9])/g;

    function PC(t) { return t.replace(MC, (...t) => t[1].toUpperCase()) }

    function FC(t, e) { return 0 === t || 0 === e }

    function NC(t, e, i) { const n = Object.keys(i); if (n.length && e.length) { let r = e[0],
                a = []; if (n.forEach(t => { r.hasOwnProperty(t) || a.push(t), r[t] = i[t] }), a.length)
                for (var s = 1; s < e.length; s++) { let i = e[s];
                    a.forEach((function(e) { i[e] = BC(t, e) })) } } return e }

    function LC(t, e, i) { switch (e.type) {
            case 7:
                return t.visitTrigger(e, i);
            case 0:
                return t.visitState(e, i);
            case 1:
                return t.visitTransition(e, i);
            case 2:
                return t.visitSequence(e, i);
            case 3:
                return t.visitGroup(e, i);
            case 4:
                return t.visitAnimate(e, i);
            case 5:
                return t.visitKeyframes(e, i);
            case 6:
                return t.visitStyle(e, i);
            case 8:
                return t.visitReference(e, i);
            case 9:
                return t.visitAnimateChild(e, i);
            case 10:
                return t.visitAnimateRef(e, i);
            case 11:
                return t.visitQuery(e, i);
            case 12:
                return t.visitStagger(e, i);
            default:
                throw new Error(`Unable to resolve animation metadata node #${e.type}`) } }

    function BC(t, e) { return window.getComputedStyle(t)[e] }

    function VC(t, e) { const i = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function(t, e, i) { if (":" == t[0]) { const n = function(t, e) { switch (t) {
                        case ":enter":
                            return "void => *";
                        case ":leave":
                            return "* => void";
                        case ":increment":
                            return (t, e) => parseFloat(e) > parseFloat(t);
                        case ":decrement":
                            return (t, e) => parseFloat(e) < parseFloat(t);
                        default:
                            return e.push(`The transition alias value "${t}" is not supported`), "* => *" } }(t, i); if ("function" == typeof n) return void e.push(n);
                t = n } const n = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == n || n.length < 4) return i.push(`The provided transition expression "${t}" is not supported`), e; const s = n[1],
                r = n[2],
                a = n[3];
            e.push(HC(s, a)), "<" != r[0] || "*" == s && "*" == a || e.push(HC(a, s)) }(t, i, e)) : i.push(t), i }
    const zC = new Set(["true", "1"]), UC = new Set(["false", "0"]);

    function HC(t, e) { const i = zC.has(t) || UC.has(t),
            n = zC.has(e) || UC.has(e); return (s, r) => { let a = "*" == t || t == s,
                o = "*" == e || e == r; return !a && i && "boolean" == typeof s && (a = s ? zC.has(t) : UC.has(t)), !o && n && "boolean" == typeof r && (o = r ? zC.has(e) : UC.has(e)), a && o } }
    const jC = new RegExp("s*:selfs*,?", "g");

    function GC(t, e, i) { return new $C(t).build(e, i) } class $C { constructor(t) { this._driver = t } build(t, e) { const i = new WC(e); return this._resetContextStyleTimingState(i), LC(this, AC(t), i) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let i = e.queryCount = 0,
                n = e.depCount = 0; const s = [],
                r = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const i = t,
                        n = i.name;
                    n.toString().split(/\s*,\s*/).forEach(t => { i.name = t, s.push(this.visitState(i, e)) }), i.name = n } else if (1 == t.type) { const s = this.visitTransition(t, e);
                    i += s.queryCount, n += s.depCount, r.push(s) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: s, transitions: r, queryCount: i, depCount: n, options: null } } visitState(t, e) { const i = this.visitStyle(t.styles, e),
                n = t.options && t.options.params || null; if (i.containsDynamicStyles) { const s = new Set,
                    r = n || {}; if (i.styles.forEach(t => { if (qC(t)) { const e = t;
                            Object.keys(e).forEach(t => { TC(e[t]).forEach(t => { r.hasOwnProperty(t) || s.add(t) }) }) } }), s.size) { const i = RC(s.values());
                    e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${i.join(", ")}`) } } return { type: 0, name: t.name, style: i, options: n ? { params: n } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const i = LC(this, AC(t.animation), e); return { type: 1, matchers: VC(t.expr, e.errors), animation: i, queryCount: e.queryCount, depCount: e.depCount, options: YC(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => LC(this, t, e)), options: YC(t.options) } } visitGroup(t, e) { const i = e.currentTime; let n = 0; const s = t.steps.map(t => { e.currentTime = i; const s = LC(this, t, e); return n = Math.max(n, e.currentTime), s }); return e.currentTime = n, { type: 3, steps: s, options: YC(t.options) } } visitAnimate(t, e) { const i = function(t, e) { let i = null; if (t.hasOwnProperty("duration")) i = t;
                else if ("number" == typeof t) return XC(wC(t, e).duration, 0, ""); const n = t; if (n.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = XC(0, 0, ""); return t.dynamic = !0, t.strValue = n, t } return i = i || wC(n, e), XC(i.duration, i.delay, i.easing) }(t.timings, e.errors); let n;
            e.currentAnimateTimings = i; let s = t.styles ? t.styles : Uw({}); if (5 == s.type) n = this.visitKeyframes(s, e);
            else { let s = t.styles,
                    r = !1; if (!s) { r = !0; const t = {};
                    i.easing && (t.easing = i.easing), s = Uw(t) } e.currentTime += i.duration + i.delay; const a = this.visitStyle(s, e);
                a.isEmptyStep = r, n = a } return e.currentAnimateTimings = null, { type: 4, timings: i, style: n, options: null } } visitStyle(t, e) { const i = this._makeStyleAst(t, e); return this._validateStyleAst(i, e), i } _makeStyleAst(t, e) { const i = [];
            Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? "*" == t ? i.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : i.push(t) }) : i.push(t.styles); let n = !1,
                s = null; return i.forEach(t => { if (qC(t)) { const e = t,
                        i = e.easing; if (i && (s = i, delete e.easing), !n)
                        for (let t in e)
                            if (e[t].toString().indexOf("{{") >= 0) { n = !0; break } } }), { type: 6, styles: i, easing: s, offset: t.offset, containsDynamicStyles: n, options: null } } _validateStyleAst(t, e) { const i = e.currentAnimateTimings; let n = e.currentTime,
                s = e.currentTime;
            i && s > 0 && (s -= i.duration + i.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(i => { if (!this._driver.validateStyleProperty(i)) return void e.errors.push(`The provided animation property "${i}" is not a supported CSS property for animations`); const r = e.collectedStyles[e.currentQuerySelector],
                        a = r[i]; let o = !0;
                    a && (s != n && s >= a.startTime && n <= a.endTime && (e.errors.push(`The CSS property "${i}" that exists between the times of "${a.startTime}ms" and "${a.endTime}ms" is also being animated in a parallel animation between the times of "${s}ms" and "${n}ms"`), o = !1), s = a.startTime), o && (r[i] = { startTime: s, endTime: n }), e.options && function(t, e, i) { const n = e.params || {},
                            s = TC(t);
                        s.length && s.forEach(t => { n.hasOwnProperty(t) || i.push(`Unable to resolve the local animation param ${t} in the given list of values`) }) }(t[i], e.options, e.errors) }) }) } visitKeyframes(t, e) { const i = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), i; let n = 0; const s = []; let r = !1,
                a = !1,
                o = 0; const l = t.steps.map(t => { const i = this._makeStyleAst(t, e); let l = null != i.offset ? i.offset : function(t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (qC(t) && t.hasOwnProperty("offset")) { const i = t;
                                e = parseFloat(i.offset), delete i.offset } });
                        else if (qC(t) && t.hasOwnProperty("offset")) { const i = t;
                            e = parseFloat(i.offset), delete i.offset } return e }(i.styles),
                    c = 0; return null != l && (n++, c = i.offset = l), a = a || c < 0 || c > 1, r = r || c < o, o = c, s.push(c), i });
            a && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), r && e.errors.push("Please ensure that all keyframe offsets are in order"); const c = t.steps.length; let h = 0;
            n > 0 && n < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == n && (h = 1 / (c - 1)); const d = c - 1,
                u = e.currentTime,
                m = e.currentAnimateTimings,
                p = m.duration; return l.forEach((t, n) => { const r = h > 0 ? n == d ? 1 : h * n : s[n],
                    a = r * p;
                e.currentTime = u + m.delay + a, m.duration = a, this._validateStyleAst(t, e), t.offset = r, i.styles.push(t) }), i } visitReference(t, e) { return { type: 8, animation: LC(this, AC(t.animation), e), options: YC(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: YC(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: YC(t.options) } } visitQuery(t, e) { const i = e.currentQuerySelector,
                n = t.options || {};
            e.queryCount++, e.currentQuery = t; const [s, r] = function(t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(jC, "")), [t = t.replace(/@\*/g, ".ng-trigger").replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, ".ng-animating"), e] }(t.selector);
            e.currentQuerySelector = i.length ? i + " " + s : s, sC(e.collectedStyles, e.currentQuerySelector, {}); const a = LC(this, AC(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = i, { type: 11, selector: s, limit: n.limit || 0, optional: !!n.optional, includeSelf: r, animation: a, originalSelector: t.selector, options: YC(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const i = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : wC(t.timings, e.errors, !0); return { type: 12, animation: LC(this, AC(t.animation), e), timings: i, options: null } } } class WC { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } }

    function qC(t) { return !Array.isArray(t) && "object" == typeof t }

    function YC(t) { var e; return t ? (t = CC(t)).params && (t.params = (e = t.params) ? CC(e) : null) : t = {}, t }

    function XC(t, e, i) { return { duration: t, delay: e, easing: i } }

    function KC(t, e, i, n, s, r, a = null, o = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: i, postStyleProps: n, duration: s, delay: r, totalTime: s + r, easing: a, subTimeline: o } } class ZC { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let i = this._map.get(t);
            i || this._map.set(t, i = []), i.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } }
    const QC = new RegExp(":enter", "g"), JC = new RegExp(":leave", "g");

    function tx(t, e, i, n, s, r = {}, a = {}, o, l, c = []) { return (new ex).buildKeyframes(t, e, i, n, s, r, a, o, l, c) } class ex { buildKeyframes(t, e, i, n, s, r, a, o, l, c = []) { l = l || new ZC; const h = new nx(t, e, l, n, s, c, []);
            h.options = o, h.currentTimeline.setStyles([r], null, h.errors, o), LC(this, i, h); const d = h.timelines.filter(t => t.containsAnimation()); if (d.length && Object.keys(a).length) { const t = d[d.length - 1];
                t.allowOnlyTimelineStyles() || t.setStyles([a], null, h.errors, o) } return d.length ? d.map(t => t.buildKeyframes()) : [KC(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) {} visitState(t, e) {} visitTransition(t, e) {} visitAnimateChild(t, e) { const i = e.subInstructions.consume(e.element); if (i) { const n = e.createSubContext(t.options),
                    s = e.currentTimeline.currentTime,
                    r = this._visitSubInstructions(i, n, n.options);
                s != r && e.transformIntoNewTimeline(r) } e.previousNode = t } visitAnimateRef(t, e) { const i = e.createSubContext(t.options);
            i.transformIntoNewTimeline(), this.visitReference(t.animation, i), e.transformIntoNewTimeline(i.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, i) { let n = e.currentTimeline.currentTime; const s = null != i.duration ? yC(i.duration) : null,
                r = null != i.delay ? yC(i.delay) : null; return 0 !== s && t.forEach(t => { const i = e.appendInstructionToTimeline(t, s, r);
                n = Math.max(n, i.duration + i.delay) }), n } visitReference(t, e) { e.updateOptions(t.options, !0), LC(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const i = e.subContextCount; let n = e; const s = t.options; if (s && (s.params || s.delay) && (n = e.createSubContext(s), n.transformIntoNewTimeline(), null != s.delay)) { 6 == n.previousNode.type && (n.currentTimeline.snapshotCurrentStyles(), n.previousNode = ix); const t = yC(s.delay);
                n.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => LC(this, t, n)), n.currentTimeline.applyStylesToKeyframe(), n.subContextCount > i && n.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const i = []; let n = e.currentTimeline.currentTime; const s = t.options && t.options.delay ? yC(t.options.delay) : 0;
            t.steps.forEach(r => { const a = e.createSubContext(t.options);
                s && a.delayNextStep(s), LC(this, r, a), n = Math.max(n, a.currentTimeline.currentTime), i.push(a.currentTimeline) }), i.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(n), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const i = t.strValue; return wC(e.params ? OC(i, e.params, e.errors) : i, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const i = e.currentAnimateTimings = this._visitTiming(t.timings, e),
                n = e.currentTimeline;
            i.delay && (e.incrementTime(i.delay), n.snapshotCurrentStyles()); const s = t.style;
            5 == s.type ? this.visitKeyframes(s, e) : (e.incrementTime(i.duration), this.visitStyle(s, e), n.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const i = e.currentTimeline,
                n = e.currentAnimateTimings;!n && i.getCurrentStyleProperties().length && i.forwardFrame(); const s = n && n.easing || t.easing;
            t.isEmptyStep ? i.applyEmptyStep(s) : i.setStyles(t.styles, s, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const i = e.currentAnimateTimings,
                n = e.currentTimeline.duration,
                s = i.duration,
                r = e.createSubContext().currentTimeline;
            r.easing = i.easing, t.styles.forEach(t => { r.forwardTime((t.offset || 0) * s), r.setStyles(t.styles, t.easing, e.errors, e.options), r.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(r), e.transformIntoNewTimeline(n + s), e.previousNode = t } visitQuery(t, e) { const i = e.currentTimeline.currentTime,
                n = t.options || {},
                s = n.delay ? yC(n.delay) : 0;
            s && (6 === e.previousNode.type || 0 == i && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = ix); let r = i; const a = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!n.optional, e.errors);
            e.currentQueryTotal = a.length; let o = null;
            a.forEach((i, n) => { e.currentQueryIndex = n; const a = e.createSubContext(t.options, i);
                s && a.delayNextStep(s), i === e.element && (o = a.currentTimeline), LC(this, t.animation, a), a.currentTimeline.applyStylesToKeyframe(), r = Math.max(r, a.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(r), o && (e.currentTimeline.mergeTimelineCollectedStyles(o), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const i = e.parentContext,
                n = e.currentTimeline,
                s = t.timings,
                r = Math.abs(s.duration),
                a = r * (e.currentQueryTotal - 1); let o = r * e.currentQueryIndex; switch (s.duration < 0 ? "reverse" : s.easing) {
                case "reverse":
                    o = a - o; break;
                case "full":
                    o = i.currentStaggerTime } const l = e.currentTimeline;
            o && l.delayNextStep(o); const c = l.currentTime;
            LC(this, t.animation, e), e.previousNode = t, i.currentStaggerTime = n.currentTime - c + (n.startTime - i.currentTimeline.startTime) } }
    const ix = {}; class nx { constructor(t, e, i, n, s, r, a, o) { this._driver = t, this.element = e, this.subInstructions = i, this._enterClassName = n, this._leaveClassName = s, this.errors = r, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = ix, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = o || new sx(this._driver, e, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const i = t; let n = this.options;
            null != i.duration && (n.duration = yC(i.duration)), null != i.delay && (n.delay = yC(i.delay)); const s = i.params; if (s) { let t = n.params;
                t || (t = this.options.params = {}), Object.keys(s).forEach(i => { e && t.hasOwnProperty(i) || (t[i] = OC(s[i], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const i = t.params = {};
                    Object.keys(e).forEach(t => { i[t] = e[t] }) } } return t } createSubContext(t = null, e, i) { const n = e || this.element,
                s = new nx(this._driver, n, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(n, i || 0)); return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(t), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s } transformIntoNewTimeline(t) { return this.previousNode = ix, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, i) { const n = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != i ? i : 0) + t.delay, easing: "" },
                s = new rx(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, n, t.stretchStartingKeyframe); return this.timelines.push(s), n } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, i, n, s, r) { let a = []; if (n && a.push(this.element), t.length > 0) { t = (t = t.replace(QC, "." + this._enterClassName)).replace(JC, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != i);
                0 !== i && (e = i < 0 ? e.slice(e.length + i, e.length) : e.slice(0, i)), a.push(...e) } return s || 0 != a.length || r.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), a } } class sx { constructor(t, e, i, n) { this._driver = t, this.element = e, this.startTime = i, this._elementTimelineStylesLookup = n, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) {
                case 0:
                    return !1;
                case 1:
                    return this.getCurrentStyleProperties().length > 0;
                default:
                    return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length;
            this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new sx(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || "*", this._currentKeyframe[t] = "*" }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, i, n) { e && (this._previousKeyframe.easing = e); const s = n && n.params || {},
                r = function(t, e) { const i = {}; let n; return t.forEach(t => { "*" === t ? (n = n || Object.keys(e), n.forEach(t => { i[t] = "*" })) : xC(t, !1, i) }), i }(t, this._globalTimelineStyles);
            Object.keys(r).forEach(t => { const e = OC(r[t], s, i);
                this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : "*"), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles,
                e = Object.keys(t);
            0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t];
                this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const i = this._styleSummary[e],
                    n = t._styleSummary[e];
                (!i || n.time > i.time) && this._updateStyle(e, n.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set,
                e = new Set,
                i = 1 === this._keyframes.size && 0 === this.duration; let n = [];
            this._keyframes.forEach((s, r) => { const a = xC(s, !0);
                Object.keys(a).forEach(i => { const n = a[i]; "!" == n ? t.add(i) : "*" == n && e.add(i) }), i || (a.offset = r / this.duration), n.push(a) }); const s = t.size ? RC(t.values()) : [],
                r = e.size ? RC(e.values()) : []; if (i) { const t = n[0],
                    e = CC(t);
                t.offset = 0, e.offset = 1, n = [t, e] } return KC(this.element, n, s, r, this.duration, this.startTime, this.easing, !1) } } class rx extends sx { constructor(t, e, i, n, s, r, a = !1) { super(t, e, r.delay), this.element = e, this.keyframes = i, this.preStyleProps = n, this.postStyleProps = s, this._stretchStartingKeyframe = a, this.timings = { duration: r.duration, delay: r.delay, easing: r.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes,
                { delay: e, duration: i, easing: n } = this.timings; if (this._stretchStartingKeyframe && e) { const s = [],
                    r = i + e,
                    a = e / r,
                    o = xC(t[0], !1);
                o.offset = 0, s.push(o); const l = xC(t[0], !1);
                l.offset = ax(a), s.push(l); const c = t.length - 1; for (let n = 1; n <= c; n++) { let a = xC(t[n], !1);
                    a.offset = ax((e + a.offset * i) / r), s.push(a) } i = r, e = 0, n = "", t = s } return KC(this.element, t, this.preStyleProps, this.postStyleProps, i, e, n, !0) } }

    function ax(t, e = 3) { const i = Math.pow(10, e - 1); return Math.round(t * i) / i } class ox {} class lx extends ox { normalizePropertyName(t, e) { return PC(t) } normalizeStyleValue(t, e, i, n) { let s = ""; const r = i.toString().trim(); if (cx[e] && 0 !== i && "0" !== i)
                if ("number" == typeof i) s = "px";
                else { const e = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
                    e && 0 == e[1].length && n.push(`Please provide a CSS unit value for ${t}:${i}`) } return r + s } }
    const cx = (() => function(t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();

    function hx(t, e, i, n, s, r, a, o, l, c, h, d, u) { return { type: 0, element: t, triggerName: e, isRemovalTransition: s, fromState: i, fromStyles: r, toState: n, toStyles: a, timelines: o, queriedElements: l, preStyleProps: c, postStyleProps: h, totalTime: d, errors: u } }
    const dx = {}; class ux { constructor(t, e, i) { this._triggerName = t, this.ast = e, this._stateStyles = i } match(t, e, i, n) { return function(t, e, i, n, s) { return t.some(t => t(e, i, n, s)) }(this.ast.matchers, t, e, i, n) } buildStyles(t, e, i) { const n = this._stateStyles["*"],
                s = this._stateStyles[t],
                r = n ? n.buildStyles(e, i) : {}; return s ? s.buildStyles(e, i) : r } build(t, e, i, n, s, r, a, o, l, c) { const h = [],
                d = this.ast.options && this.ast.options.params || dx,
                u = this.buildStyles(i, a && a.params || dx, h),
                m = o && o.params || dx,
                p = this.buildStyles(n, m, h),
                f = new Set,
                g = new Map,
                _ = new Map,
                b = "void" === n,
                y = { params: Object.assign(Object.assign({}, d), m) },
                v = c ? [] : tx(t, e, this.ast.animation, s, r, u, p, y, l, h); let w = 0; if (v.forEach(t => { w = Math.max(t.duration + t.delay, w) }), h.length) return hx(e, this._triggerName, i, n, b, u, p, [], [], g, _, w, h);
            v.forEach(t => { const i = t.element,
                    n = sC(g, i, {});
                t.preStyleProps.forEach(t => n[t] = !0); const s = sC(_, i, {});
                t.postStyleProps.forEach(t => s[t] = !0), i !== e && f.add(i) }); const C = RC(f.values()); return hx(e, this._triggerName, i, n, b, u, p, v, C, g, _, w) } } class mx { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const i = {},
                n = CC(this.defaultParams); return Object.keys(t).forEach(e => { const i = t[e];
                null != i && (n[e] = i) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const s = t;
                    Object.keys(s).forEach(t => { let r = s[t];
                        r.length > 1 && (r = OC(r, n, e)), i[t] = r }) } }), i } } class px { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new mx(t.style, t.options && t.options.params || {}) }), fx(this.states, "true", "1"), fx(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new ux(t, e, this.states)) }), this.fallbackTransition = new ux(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, i, n) { return this.transitionFactories.find(s => s.match(t, e, i, n)) || null } matchStyles(t, e, i) { return this.fallbackTransition.buildStyles(t, e, i) } }

    function fx(t, e, i) { t.hasOwnProperty(e) ? t.hasOwnProperty(i) || (t[i] = t[e]) : t.hasOwnProperty(i) && (t[e] = t[i]) }
    const gx = new ZC; class _x { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const i = [],
                n = GC(this._driver, e, i); if (i.length) throw new Error(`Unable to build the animation due to the following errors: ${i.join("\n")}`);
            this._animations[t] = n } _buildPlayer(t, e, i) { const n = t.element,
                s = tC(0, this._normalizer, 0, t.keyframes, e, i); return this._driver.animate(n, s, t.duration, t.delay, t.easing, [], !0) } create(t, e, i = {}) { const n = [],
                s = this._animations[t]; let r; const a = new Map; if (s ? (r = tx(this._driver, e, s, "ng-enter", "ng-leave", {}, {}, i, gx, n), r.forEach(t => { const e = sC(a, t.element, {});
                    t.postStyleProps.forEach(t => e[t] = null) })) : (n.push("The requested animation doesn't exist or has already been destroyed"), r = []), n.length) throw new Error(`Unable to create the animation due to the following errors: ${n.join("\n")}`);
            a.forEach((t, e) => { Object.keys(t).forEach(i => { t[i] = this._driver.computeStyle(e, i, "*") }) }); const o = Jw(r.map(t => { const e = a.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = o, o.onDestroy(() => this.destroy(t)), this.players.push(o), o } destroy(t) { const e = this._getPlayer(t);
            e.destroy(), delete this._playersById[t]; const i = this.players.indexOf(e);
            i >= 0 && this.players.splice(i, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, i, n) { const s = nC(e, "", "", ""); return eC(this._getPlayer(t), i, s, n), () => {} } command(t, e, i, n) { if ("register" == i) return void this.register(t, n[0]); if ("create" == i) return void this.create(t, e, n[0] || {}); const s = this._getPlayer(t); switch (i) {
                case "play":
                    s.play(); break;
                case "pause":
                    s.pause(); break;
                case "reset":
                    s.reset(); break;
                case "restart":
                    s.restart(); break;
                case "finish":
                    s.finish(); break;
                case "init":
                    s.init(); break;
                case "setPosition":
                    s.setPosition(parseFloat(n[0])); break;
                case "destroy":
                    this.destroy(t) } } }
    const bx = [], yx = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, vx = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class wx { constructor(t, e = "") { this.namespaceId = e; const i = t && t.hasOwnProperty("value"); if (this.value = null != (n = i ? t.value : t) ? n : null, i) { const e = CC(t);
                delete e.value, this.options = e } else this.options = {}; var n;
            this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params;
                Object.keys(e).forEach(i => { null == t[i] && (t[i] = e[i]) }) } } }
    const Cx = new wx("void"); class xx { constructor(t, e, i) { this.id = t, this.hostElement = e, this._engine = i, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, Tx(e, this._hostClassName) } listen(t, e, i, n) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${i}" because the animation trigger "${e}" doesn't exist!`); if (null == i || 0 == i.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (s = i) && "done" != s) throw new Error(`The provided animation trigger event "${i}" for the animation trigger "${e}" is not supported!`); var s; const r = sC(this._elementListeners, t, []),
                a = { name: e, phase: i, callback: n };
            r.push(a); const o = sC(this._engine.statesByElement, t, {}); return o.hasOwnProperty(e) || (Tx(t, "ng-trigger"), Tx(t, "ng-trigger-" + e), o[e] = Cx), () => { this._engine.afterFlush(() => { const t = r.indexOf(a);
                    t >= 0 && r.splice(t, 1), this._triggers[e] || delete o[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, i, n = !0) { const s = this._getTrigger(e),
                r = new kx(this.id, e, t); let a = this._engine.statesByElement.get(t);
            a || (Tx(t, "ng-trigger"), Tx(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, a = {})); let o = a[e]; const l = new wx(i, this.id); if (!(i && i.hasOwnProperty("value")) && o && l.absorbOptions(o.options), a[e] = l, o || (o = Cx), "void" !== l.value && o.value === l.value) { if (! function(t, e) { const i = Object.keys(t),
                            n = Object.keys(e); if (i.length != n.length) return !1; for (let s = 0; s < i.length; s++) { const n = i[s]; if (!e.hasOwnProperty(n) || t[n] !== e[n]) return !1 } return !0 }(o.params, l.params)) { const e = [],
                        i = s.matchStyles(o.value, o.params, e),
                        n = s.matchStyles(l.value, l.params, e);
                    e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { DC(t, i), EC(t, n) }) } return } const c = sC(this._engine.playersByElement, t, []);
            c.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let h = s.matchTransition(o.value, l.value, t, l.params),
                d = !1; if (!h) { if (!n) return;
                h = s.fallbackTransition, d = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: h, fromState: o, toState: l, player: r, isFallbackTransition: d }), d || (Tx(t, "ng-animate-queued"), r.onStart(() => { Ox(t, "ng-animate-queued") })), r.onDone(() => { let e = this.players.indexOf(r);
                e >= 0 && this.players.splice(e, 1); const i = this._engine.playersByElement.get(t); if (i) { let t = i.indexOf(r);
                    t >= 0 && i.splice(t, 1) } }), this.players.push(r), c.push(r), r } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, i) => { delete e[t] }), this._elementListeners.forEach((e, i) => { this._elementListeners.set(i, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t);
            e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const i = this._engine.driver.query(t, ".ng-trigger", !0);
            i.forEach(t => { if (t.__ng_removed) return; const i = this._engine.fetchNamespacesByElement(t);
                i.size ? i.forEach(i => i.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }), this._engine.afterFlushAnimationsDone(() => i.forEach(t => this.clearElementCache(t))) } triggerLeaveAnimation(t, e, i, n) { const s = this._engine.statesByElement.get(t); if (s) { const r = []; if (Object.keys(s).forEach(e => { if (this._triggers[e]) { const i = this.trigger(t, e, "void", n);
                            i && r.push(i) } }), r.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), i && Jw(r).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t); if (e) { const i = new Set;
                e.forEach(e => { const n = e.name; if (i.has(n)) return;
                    i.add(n); const s = this._triggers[n].fallbackTransition,
                        r = this._engine.statesByElement.get(t)[n] || Cx,
                        a = new wx("void"),
                        o = new kx(this.id, n, t);
                    this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: n, transition: s, fromState: r, toState: a, player: o, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const i = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let n = !1; if (i.totalAnimations) { const e = i.players.length ? i.playersByQueriedElement.get(t) : []; if (e && e.length) n = !0;
                else { let e = t; for (; e = e.parentNode;)
                        if (i.statesByElement.get(e)) { n = !0; break } } } if (this.prepareLeaveAnimationListeners(t), n) i.markElementAsRemoved(this.id, t, !1, e);
            else { const n = t.__ng_removed;
                n && n !== yx || (i.afterFlush(() => this.clearElementCache(t)), i.destroyInnerAnimations(t), i._onRemovalComplete(t, e)) } } insertNode(t, e) { Tx(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(i => { const n = i.player; if (n.destroyed) return; const s = i.element,
                    r = this._elementListeners.get(s);
                r && r.forEach(e => { if (e.name == i.triggerName) { const n = nC(s, i.triggerName, i.fromState.value, i.toState.value);
                        n._data = t, eC(i.player, e.phase, n, e.callback) } }), n.markedForDestroy ? this._engine.afterFlush(() => { n.destroy() }) : e.push(i) }), this._queue = [], e.sort((t, e) => { const i = t.transition.ast.depCount,
                    n = e.transition.ast.depCount; return 0 == i || 0 == n ? i - n : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class Sx { constructor(t, e, i) { this.bodyNode = t, this.driver = e, this._normalizer = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => {} } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const i = new xx(t, e, this); return e.parentNode ? this._balanceNamespaceList(i, e) : (this.newHostElements.set(e, i), this.collectEnterElement(e)), this._namespaceLookup[t] = i } _balanceNamespaceList(t, e) { const i = this._namespaceList.length - 1; if (i >= 0) { let n = !1; for (let s = i; s >= 0; s--)
                    if (this.driver.containsElement(this._namespaceList[s].hostElement, e)) { this._namespaceList.splice(s + 1, 0, t), n = !0; break } n || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let i = this._namespaceLookup[t]; return i || (i = this.createNamespace(t, e)), i } registerTrigger(t, e, i) { let n = this._namespaceLookup[t];
            n && n.register(e, i) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const i = this._fetchNamespace(t);
            this.afterFlush(() => { this.namespacesByHostElement.delete(i.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(i);
                e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => i.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set,
                i = this.statesByElement.get(t); if (i) { const t = Object.keys(i); for (let n = 0; n < t.length; n++) { const s = i[t[n]].namespaceId; if (s) { const t = this._fetchNamespace(s);
                        t && e.add(t) } } } return e } trigger(t, e, i, n) { if (Ex(e)) { const s = this._fetchNamespace(t); if (s) return s.trigger(e, i, n), !0 } return !1 } insertNode(t, e, i, n) { if (!Ex(e)) return; const s = e.__ng_removed; if (s && s.setForRemoval) { s.setForRemoval = !1, s.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e);
                t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const n = this._fetchNamespace(t);
                n && n.insertNode(e, i) } n && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), Tx(t, "ng-animate-disabled")) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Ox(t, "ng-animate-disabled")) } removeNode(t, e, i, n) { if (Ex(e)) { const s = t ? this._fetchNamespace(t) : null; if (s ? s.removeNode(e, n) : this.markElementAsRemoved(t, e, !1, n), i) { const i = this.namespacesByHostElement.get(e);
                    i && i.id !== t && i.removeNode(e, n) } } else this._onRemovalComplete(e, n) } markElementAsRemoved(t, e, i, n) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: n, hasAnimation: i, removedBeforeQueried: !1 } } listen(t, e, i, n, s) { return Ex(e) ? this._fetchNamespace(t).listen(e, i, n, s) : () => {} } _buildInstruction(t, e, i, n, s) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, i, n, t.fromState.options, t.toState.options, e, s) } destroyInnerAnimations(t) { let e = this.driver.query(t, ".ng-trigger", !0);
            e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, ".ng-animating", !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t);
            e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t);
            e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return Jw(this.players).onDone(() => t());
                t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = yx, e.namespaceId) { this.destroyInnerAnimations(t); const i = this._fetchNamespace(e.namespaceId);
                    i && i.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, ".ng-animate-disabled") && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length)
                for (let i = 0; i < this.collectedEnterElements.length; i++) Tx(this.collectedEnterElements[i], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const i = []; try { e = this._flushAnimations(i, t) } finally { for (let t = 0; t < i.length; t++) i[t]() } } else
                for (let i = 0; i < this.collectedLeaveElements.length; i++) this.processLeaveNode(this.collectedLeaveElements[i]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns;
                this._whenQuietFns = [], e.length ? Jw(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const i = new ZC,
                n = [],
                s = new Map,
                r = [],
                a = new Map,
                o = new Map,
                l = new Map,
                c = new Set;
            this.disabledNodes.forEach(t => { c.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let i = 0; i < e.length; i++) c.add(e[i]) }); const h = this.bodyNode,
                d = Array.from(this.statesByElement.keys()),
                u = Ix(d, this.collectedEnterElements),
                m = new Map; let p = 0;
            u.forEach((t, e) => { const i = "ng-enter" + p++;
                m.set(e, i), t.forEach(t => Tx(t, i)) }); const f = [],
                g = new Set,
                _ = new Set; for (let T = 0; T < this.collectedLeaveElements.length; T++) { const t = this.collectedLeaveElements[T],
                    e = t.__ng_removed;
                e && e.setForRemoval && (f.push(t), g.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => g.add(t)) : _.add(t)) } const b = new Map,
                y = Ix(d, Array.from(g));
            y.forEach((t, e) => { const i = "ng-leave" + p++;
                b.set(e, i), t.forEach(t => Tx(t, i)) }), t.push(() => { u.forEach((t, e) => { const i = m.get(e);
                    t.forEach(t => Ox(t, i)) }), y.forEach((t, e) => { const i = b.get(e);
                    t.forEach(t => Ox(t, i)) }), f.forEach(t => { this.processLeaveNode(t) }) }); const v = [],
                w = []; for (let T = this._namespaceList.length - 1; T >= 0; T--) this._namespaceList[T].drainQueuedTransitions(e).forEach(t => { const e = t.player,
                    s = t.element; if (v.push(e), this.collectedEnterElements.length) { const t = s.__ng_removed; if (t && t.setForMove) return void e.destroy() } const c = !h || !this.driver.containsElement(h, s),
                    d = b.get(s),
                    u = m.get(s),
                    p = this._buildInstruction(t, i, u, d, c); if (!p.errors || !p.errors.length) return c || t.isFallbackTransition ? (e.onStart(() => DC(s, p.fromStyles)), e.onDestroy(() => EC(s, p.toStyles)), void n.push(e)) : (p.timelines.forEach(t => t.stretchStartingKeyframe = !0), i.append(s, p.timelines), r.push({ instruction: p, player: e, element: s }), p.queriedElements.forEach(t => sC(a, t, []).push(e)), p.preStyleProps.forEach((t, e) => { const i = Object.keys(t); if (i.length) { let t = o.get(e);
                        t || o.set(e, t = new Set), i.forEach(e => t.add(e)) } }), void p.postStyleProps.forEach((t, e) => { const i = Object.keys(t); let n = l.get(e);
                    n || l.set(e, n = new Set), i.forEach(t => n.add(t)) }));
                w.push(p) }); if (w.length) { const t = [];
                w.forEach(e => { t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`)) }), v.forEach(t => t.destroy()), this.reportError(t) } const C = new Map,
                x = new Map;
            r.forEach(t => { const e = t.element;
                i.has(e) && (x.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, C)) }), n.forEach(t => { const e = t.element;
                this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { sC(C, e, []).push(t), t.destroy() }) }); const S = f.filter(t => Mx(t, o, l)),
                k = new Map;
            Ax(k, this.driver, _, l, "*").forEach(t => { Mx(t, o, l) && S.push(t) }); const E = new Map;
            u.forEach((t, e) => { Ax(E, this.driver, new Set(t), o, "!") }), S.forEach(t => { const e = k.get(t),
                    i = E.get(t);
                k.set(t, Object.assign(Object.assign({}, e), i)) }); const D = [],
                A = [],
                I = {};
            r.forEach(t => { const { element: e, player: r, instruction: a } = t; if (i.has(e)) { if (c.has(e)) return r.onDestroy(() => EC(e, a.toStyles)), r.disabled = !0, r.overrideTotalTime(a.totalTime), void n.push(r); let t = I; if (x.size > 1) { let i = e; const n = []; for (; i = i.parentNode;) { const e = x.get(i); if (e) { t = e; break } n.push(i) } n.forEach(e => x.set(e, t)) } const i = this._buildAnimation(r.namespaceId, a, C, s, E, k); if (r.setRealPlayer(i), t === I) D.push(r);
                    else { const e = this.playersByElement.get(t);
                        e && e.length && (r.parentPlayer = Jw(e)), n.push(r) } } else DC(e, a.fromStyles), r.onDestroy(() => EC(e, a.toStyles)), A.push(r), c.has(e) && n.push(r) }), A.forEach(t => { const e = s.get(t.element); if (e && e.length) { const i = Jw(e);
                    t.setRealPlayer(i) } }), n.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let T = 0; T < f.length; T++) { const t = f[T],
                    e = t.__ng_removed; if (Ox(t, "ng-leave"), e && e.hasAnimation) continue; let i = []; if (a.size) { let e = a.get(t);
                    e && e.length && i.push(...e); let n = this.driver.query(t, ".ng-animating", !0); for (let t = 0; t < n.length; t++) { let e = a.get(n[t]);
                        e && e.length && i.push(...e) } } const n = i.filter(t => !t.destroyed);
                n.length ? Rx(this, t, n) : this.processLeaveNode(t) } return f.length = 0, D.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t);
                    this.players.splice(e, 1) }), t.play() }), D } elementContainsData(t, e) { let i = !1; const n = e.__ng_removed; return n && n.setForRemoval && (i = !0), this.playersByElement.has(e) && (i = !0), this.playersByQueriedElement.has(e) && (i = !0), this.statesByElement.has(e) && (i = !0), this._fetchNamespace(t).elementContainsData(e) || i } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, i, n, s) { let r = []; if (e) { const e = this.playersByQueriedElement.get(t);
                e && (r = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !s || "void" == s;
                    e.forEach(e => { e.queued || (t || e.triggerName == n) && r.push(e) }) } } return (i || n) && (r = r.filter(t => !(i && i != t.namespaceId || n && n != t.triggerName))), r } _beforeAnimationBuild(t, e, i) { const n = e.element,
                s = e.isRemovalTransition ? void 0 : t,
                r = e.isRemovalTransition ? void 0 : e.triggerName; for (const a of e.timelines) { const t = a.element,
                    o = t !== n,
                    l = sC(i, t, []);
                this._getPreviousPlayers(t, o, s, r, e.toState).forEach(t => { const e = t.getRealPlayer();
                    e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t) }) } DC(n, e.fromStyles) } _buildAnimation(t, e, i, n, s, r) { const a = e.triggerName,
                o = e.element,
                l = [],
                c = new Set,
                h = new Set,
                d = e.timelines.map(e => { const d = e.element;
                    c.add(d); const u = d.__ng_removed; if (u && u.removedBeforeQueried) return new Kw(e.duration, e.delay); const m = d !== o,
                        p = function(t) { const e = []; return function t(e, i) { for (let n = 0; n < e.length; n++) { const s = e[n];
                                    s instanceof Zw ? t(s.players, i) : i.push(s) } }(t, e), e }((i.get(d) || bx).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === d),
                        f = s.get(d),
                        g = r.get(d),
                        _ = tC(0, this._normalizer, 0, e.keyframes, f, g),
                        b = this._buildPlayer(e, _, p); if (e.subTimeline && n && h.add(d), m) { const e = new kx(t, a, d);
                        e.setRealPlayer(b), l.push(e) } return b });
            l.forEach(t => { sC(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function(t, e, i) { let n; if (t instanceof Map) { if (n = t.get(e), n) { if (n.length) { const t = n.indexOf(i);
                                n.splice(t, 1) } 0 == n.length && t.delete(e) } } else if (n = t[e], n) { if (n.length) { const t = n.indexOf(i);
                            n.splice(t, 1) } 0 == n.length && delete t[e] } return n }(this.playersByQueriedElement, t.element, t)) }), c.forEach(t => Tx(t, "ng-animating")); const u = Jw(d); return u.onDestroy(() => { c.forEach(t => Ox(t, "ng-animating")), EC(o, e.toStyles) }), h.forEach(t => { sC(n, t, []).push(u) }), u } _buildPlayer(t, e, i) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, i) : new Kw(t.duration, t.delay) } } class kx { constructor(t, e, i) { this.namespaceId = t, this.triggerName = e, this.element = i, this._player = new Kw, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(i => eC(t, e, void 0, i)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player;
            e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { sC(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() {!this.queued && this._player.play() } pause() {!this.queued && this._player.pause() } restart() {!this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() {!this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player;
            e.triggerCallback && e.triggerCallback(t) } }

    function Ex(t) { return t && 1 === t.nodeType }

    function Dx(t, e) { const i = t.style.display; return t.style.display = null != e ? e : "none", i }

    function Ax(t, e, i, n, s) { const r = [];
        i.forEach(t => r.push(Dx(t))); const a = [];
        n.forEach((i, n) => { const r = {};
            i.forEach(t => { const i = r[t] = e.computeStyle(n, t, s);
                i && 0 != i.length || (n.__ng_removed = vx, a.push(n)) }), t.set(n, r) }); let o = 0; return i.forEach(t => Dx(t, r[o++])), a }

    function Ix(t, e) { const i = new Map; if (t.forEach(t => i.set(t, [])), 0 == e.length) return i; const n = new Set(e),
            s = new Map; return e.forEach(t => { const e = function t(e) { if (!e) return 1; let r = s.get(e); if (r) return r; const a = e.parentNode; return r = i.has(a) ? a : n.has(a) ? 1 : t(a), s.set(e, r), r }(t);
            1 !== e && i.get(e).push(t) }), i }

    function Tx(t, e) { if (t.classList) t.classList.add(e);
        else { let i = t.$$classes;
            i || (i = t.$$classes = {}), i[e] = !0 } }

    function Ox(t, e) { if (t.classList) t.classList.remove(e);
        else { let i = t.$$classes;
            i && delete i[e] } }

    function Rx(t, e, i) { Jw(i).onDone(() => t.processLeaveNode(e)) }

    function Mx(t, e, i) { const n = i.get(t); if (!n) return !1; let s = e.get(t); return s ? n.forEach(t => s.add(t)) : e.set(t, n), i.delete(t), !0 } class Px { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => {}, this._transitionEngine = new Sx(t, e, i), this._timelineEngine = new _x(t, e, i), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, i, n, s) { const r = t + "-" + n; let a = this._triggerCache[r]; if (!a) { const t = [],
                    e = GC(this._driver, s, t); if (t.length) throw new Error(`The animation trigger "${n}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`);
                a = function(t, e) { return new px(t, e) }(n, e), this._triggerCache[r] = a } this._transitionEngine.registerTrigger(e, n, a) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, i, n) { this._transitionEngine.insertNode(t, e, i, n) } onRemove(t, e, i, n) { this._transitionEngine.removeNode(t, e, n || !1, i) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, i, n) { if ("@" == i.charAt(0)) { const [t, s] = rC(i);
                this._timelineEngine.command(t, e, s, n) } else this._transitionEngine.trigger(t, e, i, n) } listen(t, e, i, n, s) { if ("@" == i.charAt(0)) { const [t, n] = rC(i); return this._timelineEngine.listen(t, e, n, s) } return this._transitionEngine.listen(t, e, i, n, s) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } }

    function Fx(t, e) { let i = null,
            n = null; return Array.isArray(e) && e.length ? (i = Lx(e[0]), e.length > 1 && (n = Lx(e[e.length - 1]))) : e && (i = Lx(e)), i || n ? new Nx(t, i, n) : null }
    let Nx = (() => { class t { constructor(e, i, n) { this._element = e, this._startStyles = i, this._endStyles = n, this._state = 0; let s = t.initialStylesByElement.get(e);
                s || t.initialStylesByElement.set(e, s = {}), this._initialStyles = s } start() { this._state < 1 && (this._startStyles && EC(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (EC(this._element, this._initialStyles), this._endStyles && (EC(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (DC(this._element, this._startStyles), this._endStyles = null), this._endStyles && (DC(this._element, this._endStyles), this._endStyles = null), EC(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })();

    function Lx(t) { let e = null; const i = Object.keys(t); for (let n = 0; n < i.length; n++) { const s = i[n];
            Bx(s) && (e = e || {}, e[s] = t[s]) } return e }

    function Bx(t) { return "display" === t || "position" === t } class Vx { constructor(t, e, i, n, s, r, a) { this._element = t, this._name = e, this._duration = i, this._delay = n, this._easing = s, this._fillMode = r, this._onDoneFn = a, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() {! function(t, e) { const i = $x(t, "").trim();
                i.length && (function(t, e) { let i = 0; for (let n = 0; n < t.length; n++) "," === t.charAt(n) && i++ }(i), e = `${i}, ${e}`), Gx(t, "", e) }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), jx(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { zx(this._element, this._name, "paused") } resume() { zx(this._element, this._name, "running") } setPosition(t) { const e = Ux(this._element, this._name);
            this._position = t * this._duration, Gx(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(),
                i = 1e3 * parseFloat(t.elapsedTime.toFixed(3));
            t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && i >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), jx(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function(t, e) { const i = $x(t, "").split(","),
                    n = Hx(i, e);
                n >= 0 && (i.splice(n, 1), Gx(t, "", i.join(","))) }(this._element, this._name)) } }

    function zx(t, e, i) { Gx(t, "PlayState", i, Ux(t, e)) }

    function Ux(t, e) { const i = $x(t, ""); return i.indexOf(",") > 0 ? Hx(i.split(","), e) : Hx([i], e) }

    function Hx(t, e) { for (let i = 0; i < t.length; i++)
            if (t[i].indexOf(e) >= 0) return i; return -1 }

    function jx(t, e, i) { i ? t.removeEventListener("animationend", e) : t.addEventListener("animationend", e) }

    function Gx(t, e, i, n) { const s = "animation" + e; if (null != n) { const e = t.style[s]; if (e.length) { const t = e.split(",");
                t[n] = i, i = t.join(",") } } t.style[s] = i }

    function $x(t, e) { return t.style["animation" + e] } class Wx { constructor(t, e, i, n, s, r, a, o) { this.element = t, this.keyframes = e, this.animationName = i, this._duration = n, this._delay = s, this._finalStyles = a, this._specialStyles = o, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, this.easing = r || "linear", this.totalTime = n + s, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new Vx(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns;
            e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3;
                Object.keys(this._finalStyles).forEach(i => { "offset" != i && (t[i] = e ? this._finalStyles[i] : BC(this.element, i)) }) } this.currentSnapshot = t } } class qx extends Kw { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = gC(e) } init() {!this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t];
                e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class Yx { constructor() { this._count = 0, this._head = document.querySelector("head"), this._warningIssued = !1 } validateStyleProperty(t) { return uC(t) } matchesElement(t, e) { return mC(t, e) } containsElement(t, e) { return pC(t, e) } query(t, e, i) { return fC(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, i) { i = i.map(t => gC(t)); let n = `@keyframes ${e} {\n`,
                s = "";
            i.forEach(t => { s = " "; const e = parseFloat(t.offset);
                n += `${s}${100*e}% {\n`, s += " ", Object.keys(t).forEach(e => { const i = t[e]; switch (e) {
                        case "offset":
                            return;
                        case "easing":
                            return void(i && (n += `${s}animation-timing-function: ${i};\n`));
                        default:
                            return void(n += `${s}${e}: ${i};\n`) } }), n += `${s}}\n` }), n += "}\n"; const r = document.createElement("style"); return r.innerHTML = n, r } animate(t, e, i, n, s, r = [], a) { a && this._notifyFaultyScrubber(); const o = r.filter(t => t instanceof Wx),
                l = {};
            FC(i, n) && o.forEach(t => { let e = t.currentSnapshot;
                Object.keys(e).forEach(t => l[t] = e[t]) }); const c = function(t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(i => { "offset" != i && "easing" != i && (e[i] = t[i]) }) }), e }(e = NC(t, e, l)); if (0 == i) return new qx(t, c); const h = `gen_css_kf_${this._count++}`,
                d = this.buildKeyframeElement(t, h, e);
            document.querySelector("head").appendChild(d); const u = Fx(t, e),
                m = new Wx(t, e, h, i, n, s, c, u); return m.onDestroy(() => { var t;
                (t = d).parentNode.removeChild(t) }), m } _notifyFaultyScrubber() { this._warningIssued || (console.warn("@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n", "  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill."), this._warningIssued = !0) } } class Xx { constructor(t, e, i, n) { this.element = t, this.keyframes = e, this.options = i, this._specialStyles = n, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = i.duration, this._delay = i.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return;
            this._initialized = !0; const t = this.keyframes;
            this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, i) { return t.animate(e, i) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {};
            this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : BC(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns;
            e.forEach(t => t()), e.length = 0 } } class Kx { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(Zx().toString()), this._cssKeyframesDriver = new Yx } validateStyleProperty(t) { return uC(t) } matchesElement(t, e) { return mC(t, e) } containsElement(t, e) { return pC(t, e) } query(t, e, i) { return fC(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, i, n, s, r = [], a) { if (!a && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, i, n, s, r); const o = { duration: i, delay: n, fill: 0 == n ? "both" : "forwards" };
            s && (o.easing = s); const l = {},
                c = r.filter(t => t instanceof Xx);
            FC(i, n) && c.forEach(t => { let e = t.currentSnapshot;
                Object.keys(e).forEach(t => l[t] = e[t]) }); const h = Fx(t, e = NC(t, e = e.map(t => xC(t, !1)), l)); return new Xx(t, e, o, h) } }

    function Zx() { return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {} }
    let Qx = (() => { class t extends Nw { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: he.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString();
                this._nextAnimationId++; const i = Array.isArray(t) ? zw(t) : t; return eS(this._renderer, null, e, "register", [i]), new Jx(e, this._renderer) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Yo), Xt(uh)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class Jx extends class {} { constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new tS(this._id, t, e || {}, this._renderer) } } class tS { constructor(t, e, i, n) { this.id = t, this.element = e, this._renderer = n, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", i) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return eS(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset") } setPosition(t) { this._command("setPosition", t) } getPosition() { return 0 } }

    function eS(t, e, i, n, s) { return t.setProperty(e, `@@${i}:${n}`, s) }
    let iS = (() => { class t { constructor(t, e, i) { this.delegate = t, this.engine = e, this._zone = i, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const i = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(i); return t || (t = new nS("", i, this.engine), this._rendererCache.set(i, t)), t } const n = e.id,
                    s = e.id + "-" + this._currentId;
                this._currentId++, this.engine.register(s, t); const r = e => { Array.isArray(e) ? e.forEach(r) : this.engine.registerTrigger(n, s, t, e.name, e) }; return e.data.animation.forEach(r), new sS(this, s, i, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, i) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(i)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, i] = t;
                            e(i) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, i])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Yo), Xt(Px), Xt(Pc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class nS { constructor(t, e, i) { this.namespaceId = t, this.delegate = e, this.engine = i, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, i) { this.delegate.insertBefore(t, e, i), this.engine.onInsert(this.namespaceId, e, t, !0) } removeChild(t, e, i) { this.engine.onRemove(this.namespaceId, e, this.delegate, i) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, i, n) { this.delegate.setAttribute(t, e, i, n) } removeAttribute(t, e, i) { this.delegate.removeAttribute(t, e, i) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, i, n) { this.delegate.setStyle(t, e, i, n) } removeStyle(t, e, i) { this.delegate.removeStyle(t, e, i) } setProperty(t, e, i) { "@" == e.charAt(0) && "@.disabled" == e ? this.disableAnimations(t, !!i) : this.delegate.setProperty(t, e, i) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, i) { return this.delegate.listen(t, e, i) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class sS extends nS { constructor(t, e, i, n) { super(e, i, n), this.factory = t, this.namespaceId = e } setProperty(t, e, i) { "@" == e.charAt(0) ? "." == e.charAt(1) && "@.disabled" == e ? this.disableAnimations(t, i = void 0 === i || !!i) : this.engine.process(this.namespaceId, t, e.substr(1), i) : this.delegate.setProperty(t, e, i) } listen(t, e, i) { if ("@" == e.charAt(0)) { const n = function(t) { switch (t) {
                        case "body":
                            return document.body;
                        case "document":
                            return document;
                        case "window":
                            return window;
                        default:
                            return t } }(t); let s = e.substr(1),
                    r = ""; return "@" != s.charAt(0) && ([s, r] = function(t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(s)), this.engine.listen(this.namespaceId, n, s, r, t => { this.factory.scheduleListenerCallback(t._data || -1, i, t) }) } return this.delegate.listen(t, e, i) } }
    let rS = (() => { class t extends Px { constructor(t, e, i) { super(t.body, e, i) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh), Xt(bC), Xt(ox)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();
    const aS = new Vt("AnimationModuleType"), oS = [{ provide: bC, useFactory: function() { return "function" == typeof Zx() ? new Kx : new Yx } }, { provide: aS, useValue: "BrowserAnimations" }, { provide: Nw, useClass: Qx }, { provide: ox, useFactory: function() { return new lx } }, { provide: Px, useClass: rS }, { provide: Yo, useFactory: function(t, e, i) { return new iS(t, e, i) }, deps: [bu, Px, Pc] }];
    let lS = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: oS, imports: [Ru] }), t })();
    const cS = ["*", [
        ["mat-option"],
        ["ng-container"]
    ]], hS = ["*", "mat-option, ng-container"];

    function dS(t, e) { if (1 & t && Oa(0, "mat-pseudo-checkbox", 3), 2 & t) { const t = ja();
            Da("state", t.selected ? "checked" : "unchecked")("disabled", t.disabled) } }
    const uS = ["*"];
    let mS = (() => { class t {} return t.STANDARD_CURVE = "cubic-bezier(0.4,0.0,0.2,1)", t.DECELERATION_CURVE = "cubic-bezier(0.0,0.0,0.2,1)", t.ACCELERATION_CURVE = "cubic-bezier(0.4,0.0,1,1)", t.SHARP_CURVE = "cubic-bezier(0.4,0.0,0.6,1)", t })(), pS = (() => { class t {} return t.COMPLEX = "375ms", t.ENTERING = "225ms", t.EXITING = "195ms", t })();
    const fS = new Jo("9.2.0"), gS = new Vt("mat-sanity-checks", { providedIn: "root", factory: function() { return !0 } });
    let _S = (() => { class t { constructor(t, e, i) { this._hasDoneGlobalChecks = !1, this._document = i, t._applyBodyHighContrastModeCssClasses(), this._sanityChecks = e, this._hasDoneGlobalChecks || (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0) } _getDocument() { const t = this._document || document; return "object" == typeof t && t ? t : null } _getWindow() { const t = this._getDocument(),
                    e = (null == t ? void 0 : t.defaultView) || window; return "object" == typeof e && e ? e : null } _checksAreEnabled() { return Sn() && !this._isTestEnv() } _isTestEnv() { const t = this._getWindow(); return t && (t.__karma__ || t.jasmine) } _checkDoctypeIsDefined() { const t = this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.doctype),
                    e = this._getDocument();
                t && e && !e.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.") } _checkThemeIsPresent() { const t = !this._checksAreEnabled() || !1 === this._sanityChecks || !this._sanityChecks.theme,
                    e = this._getDocument(); if (t || !e || !e.body || "function" != typeof getComputedStyle) return; const i = e.createElement("div");
                i.classList.add("mat-theme-loaded-marker"), e.body.appendChild(i); const n = getComputedStyle(i);
                n && "none" !== n.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), e.body.removeChild(i) } _checkCdkVersionMatch() { this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.version) && fS.full !== Fw.full && console.warn("The Angular Material version (" + fS.full + ") does not match the Angular CDK version (" + Fw.full + ").\nPlease ensure the versions of these two packages exactly match.") } } return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t)(Xt(Iw), Xt(gS, 8), Xt(uh, 8)) }, imports: [
                [Pw], Pw
            ] }), t })();

    function bS(t) { return class extends t { constructor(...t) { super(...t), this._disabled = !1 } get disabled() { return this._disabled } set disabled(t) { this._disabled = Vv(t) } } }

    function yS(t, e) { return class extends t { constructor(...t) { super(...t), this.color = e } get color() { return this._color } set color(t) { const i = t || e;
                i !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), i && this._elementRef.nativeElement.classList.add(`mat-${i}`), this._color = i) } } }

    function vS(t) { return class extends t { constructor(...t) { super(...t), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = Vv(t) } } }

    function wS(t, e = 0) { return class extends t { constructor(...t) { super(...t), this._tabIndex = e } get tabIndex() { return this.disabled ? -1 : this._tabIndex } set tabIndex(t) { this._tabIndex = null != t ? t : e } } }

    function CS(t) { return class extends t { constructor(...t) { super(...t), this.errorState = !1, this.stateChanges = new k } updateErrorState() { const t = this.errorState,
                    e = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm);
                e !== t && (this.errorState = e, this.stateChanges.next()) } } }

    function xS(t) { return class extends t { constructor(...t) { super(...t), this._isInitialized = !1, this._pendingSubscribers = [], this.initialized = new v(t => { this._isInitialized ? this._notifySubscriber(t) : this._pendingSubscribers.push(t) }) } _markInitialized() { if (this._isInitialized) throw Error("This directive has already been marked as initialized and should not be called twice.");
                this._isInitialized = !0, this._pendingSubscribers.forEach(this._notifySubscriber), this._pendingSubscribers = null } _notifySubscriber(t) { t.next(), t.complete() } } }
    const SS = new Vt("MAT_DATE_LOCALE", { providedIn: "root", factory: function() { return Kt(wc) } }); class kS { constructor() { this._localeChanges = new k } get localeChanges() { return this._localeChanges } deserialize(t) { return null == t || this.isDateInstance(t) && this.isValid(t) ? t : this.invalid() } setLocale(t) { this.locale = t, this._localeChanges.next() } compareDate(t, e) { return this.getYear(t) - this.getYear(e) || this.getMonth(t) - this.getMonth(e) || this.getDate(t) - this.getDate(e) } sameDate(t, e) { if (t && e) { let i = this.isValid(t),
                    n = this.isValid(e); return i && n ? !this.compareDate(t, e) : i == n } return t == e } clampDate(t, e, i) { return e && this.compareDate(t, e) < 0 ? e : i && this.compareDate(t, i) > 0 ? i : t } }
    const ES = new Vt("mat-date-formats");
    let DS;
    try { DS = "undefined" != typeof Intl } catch (B$) { DS = !1 }
    const AS = { long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"] }, IS = RS(31, t => String(t + 1)), TS = { long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], narrow: ["S", "M", "T", "W", "T", "F", "S"] }, OS = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/;

    function RS(t, e) { const i = Array(t); for (let n = 0; n < t; n++) i[n] = e(n); return i }
    let MS = (() => { class t extends kS { constructor(t, e) { super(), this.useUtcForDisplay = !0, super.setLocale(t), this.useUtcForDisplay = !e.TRIDENT, this._clampDate = e.TRIDENT || e.EDGE } getYear(t) { return t.getFullYear() } getMonth(t) { return t.getMonth() } getDate(t) { return t.getDate() } getDayOfWeek(t) { return t.getDay() } getMonthNames(t) { if (DS) { const e = new Intl.DateTimeFormat(this.locale, { month: t, timeZone: "utc" }); return RS(12, t => this._stripDirectionalityCharacters(this._format(e, new Date(2017, t, 1)))) } return AS[t] } getDateNames() { if (DS) { const t = new Intl.DateTimeFormat(this.locale, { day: "numeric", timeZone: "utc" }); return RS(31, e => this._stripDirectionalityCharacters(this._format(t, new Date(2017, 0, e + 1)))) } return IS } getDayOfWeekNames(t) { if (DS) { const e = new Intl.DateTimeFormat(this.locale, { weekday: t, timeZone: "utc" }); return RS(7, t => this._stripDirectionalityCharacters(this._format(e, new Date(2017, 0, t + 1)))) } return TS[t] } getYearName(t) { if (DS) { const e = new Intl.DateTimeFormat(this.locale, { year: "numeric", timeZone: "utc" }); return this._stripDirectionalityCharacters(this._format(e, t)) } return String(this.getYear(t)) } getFirstDayOfWeek() { return 0 } getNumDaysInMonth(t) { return this.getDate(this._createDateWithOverflow(this.getYear(t), this.getMonth(t) + 1, 0)) } clone(t) { return new Date(t.getTime()) } createDate(t, e, i) { if (e < 0 || e > 11) throw Error(`Invalid month index "${e}". Month index has to be between 0 and 11.`); if (i < 1) throw Error(`Invalid date "${i}". Date has to be greater than 0.`); let n = this._createDateWithOverflow(t, e, i); if (n.getMonth() != e) throw Error(`Invalid date "${i}" for month with index "${e}".`); return n } today() { return new Date } parse(t) { return "number" == typeof t ? new Date(t) : t ? new Date(Date.parse(t)) : null } format(t, e) { if (!this.isValid(t)) throw Error("NativeDateAdapter: Cannot format invalid date."); if (DS) { this._clampDate && (t.getFullYear() < 1 || t.getFullYear() > 9999) && (t = this.clone(t)).setFullYear(Math.max(1, Math.min(9999, t.getFullYear()))), e = Object.assign(Object.assign({}, e), { timeZone: "utc" }); const i = new Intl.DateTimeFormat(this.locale, e); return this._stripDirectionalityCharacters(this._format(i, t)) } return this._stripDirectionalityCharacters(t.toDateString()) } addCalendarYears(t, e) { return this.addCalendarMonths(t, 12 * e) } addCalendarMonths(t, e) { let i = this._createDateWithOverflow(this.getYear(t), this.getMonth(t) + e, this.getDate(t)); return this.getMonth(i) != ((this.getMonth(t) + e) % 12 + 12) % 12 && (i = this._createDateWithOverflow(this.getYear(i), this.getMonth(i), 0)), i } addCalendarDays(t, e) { return this._createDateWithOverflow(this.getYear(t), this.getMonth(t), this.getDate(t) + e) } toIso8601(t) { return [t.getUTCFullYear(), this._2digit(t.getUTCMonth() + 1), this._2digit(t.getUTCDate())].join("-") } deserialize(t) { if ("string" == typeof t) { if (!t) return null; if (OS.test(t)) { let e = new Date(t); if (this.isValid(e)) return e } } return super.deserialize(t) } isDateInstance(t) { return t instanceof Date } isValid(t) { return !isNaN(t.getTime()) } invalid() { return new Date(NaN) } _createDateWithOverflow(t, e, i) { const n = new Date(t, e, i); return t >= 0 && t < 100 && n.setFullYear(this.getYear(n) - 1900), n } _2digit(t) { return ("00" + t).slice(-2) } _stripDirectionalityCharacters(t) { return t.replace(/[\u200e\u200f]/g, "") } _format(t, e) { const i = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds())); return t.format(i) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(SS, 8), Xt(Wv)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), PS = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [{ provide: kS, useClass: MS }], imports: [
                [qv]
            ] }), t })();
    const FS = { parse: { dateInput: null }, display: { dateInput: { year: "numeric", month: "numeric", day: "numeric" }, monthYearLabel: { year: "numeric", month: "short" }, dateA11yLabel: { year: "numeric", month: "long", day: "numeric" }, monthYearA11yLabel: { year: "numeric", month: "long" } } };
    let NS = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [{ provide: ES, useValue: FS }], imports: [
                [PS]
            ] }), t })(), LS = (() => { class t { isErrorState(t, e) { return !!(t && t.invalid && (t.touched || e && e.submitted)) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return new t }, token: t, providedIn: "root" }), t })(), BS = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-line", ""],
                ["", "matLine", ""]
            ], hostAttrs: [1, "mat-line"] }), t })();

    function VS(t, e, i = "mat") { t.changes.pipe(bm(t)).subscribe(({ length: t }) => { zS(e, `${i}-2-line`, !1), zS(e, `${i}-3-line`, !1), zS(e, `${i}-multi-line`, !1), 2 === t || 3 === t ? zS(e, `${i}-${t}-line`, !0) : t > 3 && zS(e, `${i}-multi-line`, !0) }) }

    function zS(t, e, i) { const n = t.nativeElement.classList;
        i ? n.add(e) : n.remove(e) }
    let US = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [_S], _S
            ] }), t })(); class HS { constructor(t, e, i) { this._renderer = t, this.element = e, this.config = i, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } }
    const jS = { enterDuration: 450, exitDuration: 400 }, GS = Jv({ passive: !0 }); class $S { constructor(t, e, i, n) { this._target = t, this._ngZone = e, this._isPointerDown = !1, this._triggerEvents = new Map, this._activeRipples = new Set, this._onMousedown = t => { const e = Aw(t),
                    i = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800;
                this._target.rippleDisabled || e || i || (this._isPointerDown = !0, this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig)) }, this._onTouchStart = t => { if (!this._target.rippleDisabled) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const e = t.changedTouches; for (let t = 0; t < e.length; t++) this.fadeInRipple(e[t].clientX, e[t].clientY, this._target.rippleConfig) } }, this._onPointerUp = () => { this._isPointerDown && (this._isPointerDown = !1, this._activeRipples.forEach(t => {!t.config.persistent && (1 === t.state || t.config.terminateOnPointerUp && 0 === t.state) && t.fadeOut() })) }, n.isBrowser && (this._containerElement = jv(i), this._triggerEvents.set("mousedown", this._onMousedown).set("mouseup", this._onPointerUp).set("mouseleave", this._onPointerUp).set("touchstart", this._onTouchStart).set("touchend", this._onPointerUp).set("touchcancel", this._onPointerUp)) } fadeInRipple(t, e, i = {}) { const n = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(),
                s = Object.assign(Object.assign({}, jS), i.animation);
            i.centered && (t = n.left + n.width / 2, e = n.top + n.height / 2); const r = i.radius || function(t, e, i) { const n = Math.max(Math.abs(t - i.left), Math.abs(t - i.right)),
                        s = Math.max(Math.abs(e - i.top), Math.abs(e - i.bottom)); return Math.sqrt(n * n + s * s) }(t, e, n),
                a = t - n.left,
                o = e - n.top,
                l = s.enterDuration,
                c = document.createElement("div");
            c.classList.add("mat-ripple-element"), c.style.left = `${a-r}px`, c.style.top = `${o-r}px`, c.style.height = `${2*r}px`, c.style.width = `${2*r}px`, null != i.color && (c.style.backgroundColor = i.color), c.style.transitionDuration = `${l}ms`, this._containerElement.appendChild(c), window.getComputedStyle(c).getPropertyValue("opacity"), c.style.transform = "scale(1)"; const h = new HS(this, c, i); return h.state = 0, this._activeRipples.add(h), i.persistent || (this._mostRecentTransientRipple = h), this._runTimeoutOutsideZone(() => { const t = h === this._mostRecentTransientRipple;
                h.state = 1, i.persistent || t && this._isPointerDown || h.fadeOut() }, l), h } fadeOutRipple(t) { const e = this._activeRipples.delete(t); if (t === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), this._activeRipples.size || (this._containerRect = null), !e) return; const i = t.element,
                n = Object.assign(Object.assign({}, jS), t.config.animation);
            i.style.transitionDuration = `${n.exitDuration}ms`, i.style.opacity = "0", t.state = 2, this._runTimeoutOutsideZone(() => { t.state = 3, i.parentNode.removeChild(i) }, n.exitDuration) } fadeOutAll() { this._activeRipples.forEach(t => t.fadeOut()) } setupTriggerEvents(t) { const e = jv(t);
            e && e !== this._triggerElement && (this._removeTriggerEvents(), this._ngZone.runOutsideAngular(() => { this._triggerEvents.forEach((t, i) => { e.addEventListener(i, t, GS) }) }), this._triggerElement = e) } _runTimeoutOutsideZone(t, e = 0) { this._ngZone.runOutsideAngular(() => setTimeout(t, e)) } _removeTriggerEvents() { this._triggerElement && this._triggerEvents.forEach((t, e) => { this._triggerElement.removeEventListener(e, t, GS) }) } }
    const WS = new Vt("mat-ripple-global-options");
    let qS = (() => { class t { constructor(t, e, i, n, s) { this._elementRef = t, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = n || {}, this._rippleRenderer = new $S(this, e, t, i), "NoopAnimations" === s && (this._globalOptions.animation = { enterDuration: 0, exitDuration: 0 }) } get disabled() { return this._disabled } set disabled(t) { this._disabled = t, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(t) { this._trigger = t, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: Object.assign(Object.assign({}, this._globalOptions.animation), this.animation), terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() {!this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(t, e = 0, i) { return "number" == typeof t ? this._rippleRenderer.fadeInRipple(t, e, Object.assign(Object.assign({}, this.rippleConfig), i)) : this._rippleRenderer.fadeInRipple(0, 0, Object.assign(Object.assign({}, this.rippleConfig), t)) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Pc), Sa(Wv), Sa(WS, 8), Sa(aS, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-ripple", ""],
                ["", "matRipple", ""]
            ], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function(t, e) { 2 & t && no("mat-ripple-unbounded", e.unbounded) }, inputs: { radius: ["matRippleRadius", "radius"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"], color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], animation: ["matRippleAnimation", "animation"] }, exportAs: ["matRipple"] }), t })(), YS = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [_S, qv], _S
            ] }), t })(), XS = (() => { class t { constructor(t) { this._animationMode = t, this.state = "unchecked", this.disabled = !1 } } return t.\u0275fac = function(e) { return new(e || t)(Sa(aS, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-pseudo-checkbox"]
            ], hostAttrs: [1, "mat-pseudo-checkbox"], hostVars: 8, hostBindings: function(t, e) { 2 & t && no("mat-pseudo-checkbox-indeterminate", "indeterminate" === e.state)("mat-pseudo-checkbox-checked", "checked" === e.state)("mat-pseudo-checkbox-disabled", e.disabled)("_mat-animation-noopable", "NoopAnimations" === e._animationMode) }, inputs: { state: "state", disabled: "disabled" }, decls: 0, vars: 0, template: function(t, e) {}, styles: ['.mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\n'], encapsulation: 2, changeDetection: 0 }), t })(), KS = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })(); class ZS {}
    const QS = bS(ZS);
    let JS = 0, tk = (() => { class t extends QS { constructor() { super(...arguments), this._labelId = `mat-optgroup-label-${JS++}` } } return t.\u0275fac = function(e) { return ek(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-optgroup"]
            ], hostAttrs: ["role", "group", 1, "mat-optgroup"], hostVars: 4, hostBindings: function(t, e) { 2 & t && (va("aria-disabled", e.disabled.toString())("aria-labelledby", e._labelId), no("mat-optgroup-disabled", e.disabled)) }, inputs: { disabled: "disabled", label: "label" }, exportAs: ["matOptgroup"], features: [Eo], ngContentSelectors: hS, decls: 4, vars: 2, consts: [
                [1, "mat-optgroup-label", 3, "id"]
            ], template: function(t, e) { 1 & t && ($a(cS), Ia(0, "label", 0), _o(1), Wa(2), Ta(), Wa(3, 1)), 2 & t && (Da("id", e._labelId), ps(1), yo("", e.label, " ")) }, styles: [".mat-optgroup-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup-label[disabled]{cursor:default}[dir=rtl] .mat-optgroup-label{text-align:right}.mat-optgroup-label .mat-icon{margin-right:16px;vertical-align:middle}.mat-optgroup-label .mat-icon svg{vertical-align:top}[dir=rtl] .mat-optgroup-label .mat-icon{margin-left:16px;margin-right:0}\n"], encapsulation: 2, changeDetection: 0 }), t })();
    const ek = ln(tk);
    let ik = 0; class nk { constructor(t, e = !1) { this.source = t, this.isUserInput = e } }
    const sk = new Vt("MAT_OPTION_PARENT_COMPONENT");
    let rk = (() => { class t { constructor(t, e, i, n) { this._element = t, this._changeDetectorRef = e, this._parent = i, this.group = n, this._selected = !1, this._active = !1, this._disabled = !1, this._mostRecentViewValue = "", this.id = `mat-option-${ik++}`, this.onSelectionChange = new jl, this._stateChanges = new k } get multiple() { return this._parent && this._parent.multiple } get selected() { return this._selected } get disabled() { return this.group && this.group.disabled || this._disabled } set disabled(t) { this._disabled = Vv(t) } get disableRipple() { return this._parent && this._parent.disableRipple } get active() { return this._active } get viewValue() { return (this._getHostElement().textContent || "").trim() } select() { this._selected || (this._selected = !0, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent()) } deselect() { this._selected && (this._selected = !1, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent()) } focus(t, e) { const i = this._getHostElement(); "function" == typeof i.focus && i.focus(e) } setActiveStyles() { this._active || (this._active = !0, this._changeDetectorRef.markForCheck()) } setInactiveStyles() { this._active && (this._active = !1, this._changeDetectorRef.markForCheck()) } getLabel() { return this.viewValue } _handleKeydown(t) { 13 !== t.keyCode && 32 !== t.keyCode || Iv(t) || (this._selectViaInteraction(), t.preventDefault()) } _selectViaInteraction() { this.disabled || (this._selected = !this.multiple || !this._selected, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent(!0)) } _getAriaSelected() { return this.selected || !this.multiple && null } _getTabIndex() { return this.disabled ? "-1" : "0" } _getHostElement() { return this._element.nativeElement } ngAfterViewChecked() { if (this._selected) { const t = this.viewValue;
                    t !== this._mostRecentViewValue && (this._mostRecentViewValue = t, this._stateChanges.next()) } } ngOnDestroy() { this._stateChanges.complete() } _emitSelectionChangeEvent(t = !1) { this.onSelectionChange.emit(new nk(this, t)) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(sk, 8), Sa(tk, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-option"]
            ], hostAttrs: ["role", "option", 1, "mat-option", "mat-focus-indicator"], hostVars: 12, hostBindings: function(t, e) { 1 & t && Ba("click", (function() { return e._selectViaInteraction() }))("keydown", (function(t) { return e._handleKeydown(t) })), 2 & t && (xo("id", e.id), va("tabindex", e._getTabIndex())("aria-selected", e._getAriaSelected())("aria-disabled", e.disabled.toString()), no("mat-selected", e.selected)("mat-option-multiple", e.multiple)("mat-active", e.active)("mat-option-disabled", e.disabled)) }, inputs: { id: "id", disabled: "disabled", value: "value" }, outputs: { onSelectionChange: "onSelectionChange" }, exportAs: ["matOption"], ngContentSelectors: uS, decls: 4, vars: 3, consts: [
                ["class", "mat-option-pseudo-checkbox", 3, "state", "disabled", 4, "ngIf"],
                [1, "mat-option-text"],
                ["mat-ripple", "", 1, "mat-option-ripple", 3, "matRippleTrigger", "matRippleDisabled"],
                [1, "mat-option-pseudo-checkbox", 3, "state", "disabled"]
            ], template: function(t, e) { 1 & t && ($a(), Ca(0, dS, 1, 2, "mat-pseudo-checkbox", 0), Ia(1, "span", 1), Wa(2), Ta(), Oa(3, "div", 2)), 2 & t && (Da("ngIf", e.multiple), ps(3), Da("matRippleTrigger", e._getHostElement())("matRippleDisabled", e.disabled || e.disableRipple)) }, directives: [yd, qS, XS], styles: [".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:none;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}.cdk-high-contrast-active .mat-option{margin:0 1px}.cdk-high-contrast-active .mat-option.mat-active{border:solid 1px currentColor;margin:0}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.cdk-high-contrast-active .mat-option .mat-option-ripple{opacity:.5}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}\n"], encapsulation: 2, changeDetection: 0 }), t })();

    function ak(t, e, i) { if (i.length) { let n = e.toArray(),
                s = i.toArray(),
                r = 0; for (let e = 0; e < t + 1; e++) n[e].group && n[e].group === s[r] && r++; return r } return 0 }

    function ok(t, e, i, n) { const s = t * e; return s < i ? s : s + e > i + n ? Math.max(0, s - n + e) : i }
    let lk = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [YS, Jd, KS]
            ] }), t })();
    const ck = new Vt("mat-label-global-options"), hk = ["mat-button", ""], dk = ["*"], uk = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"]; class mk { constructor(t) { this._elementRef = t } }
    const pk = yS(bS(vS(mk)));
    let fk = (() => { class t extends pk { constructor(t, e, i) { super(t), this._focusMonitor = e, this._animationMode = i, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button"); for (const n of uk) this._hasHostAttributes(n) && this._getHostElement().classList.add(n);
                t.nativeElement.classList.add("mat-button-base"), this._focusMonitor.monitor(this._elementRef, !0), this.isRoundButton && (this.color = "accent") } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(t = "program", e) { this._focusMonitor.focusVia(this._getHostElement(), t, e) } _getHostElement() { return this._elementRef.nativeElement } _isRippleDisabled() { return this.disableRipple || this.disabled } _hasHostAttributes(...t) { return t.some(t => this._getHostElement().hasAttribute(t)) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Ew), Sa(aS, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["button", "mat-button", ""],
                ["button", "mat-raised-button", ""],
                ["button", "mat-icon-button", ""],
                ["button", "mat-fab", ""],
                ["button", "mat-mini-fab", ""],
                ["button", "mat-stroked-button", ""],
                ["button", "mat-flat-button", ""]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(qS, !0), 2 & t && tc(i = oc()) && (e.ripple = i.first) }, hostAttrs: [1, "mat-focus-indicator"], hostVars: 3, hostBindings: function(t, e) { 2 & t && (va("disabled", e.disabled || null), no("_mat-animation-noopable", "NoopAnimations" === e._animationMode)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [Eo], attrs: hk, ngContentSelectors: dk, decls: 4, vars: 5, consts: [
                [1, "mat-button-wrapper"],
                ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"],
                [1, "mat-button-focus-overlay"]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "span", 0), Wa(1), Ta(), Oa(2, "div", 1), Oa(3, "div", 2)), 2 & t && (ps(2), no("mat-button-ripple-round", e.isRoundButton || e.isIconButton), Da("matRippleDisabled", e._isRippleDisabled())("matRippleCentered", e.isIconButton)("matRippleTrigger", e._getHostElement())) }, directives: [qS], styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled],.mat-flat-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.cdk-high-contrast-active .mat-button-focus-overlay{background-color:#fff}.cdk-high-contrast-black-on-white .mat-button-focus-overlay{background-color:#000}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), gk = (() => { class t extends fk { constructor(t, e, i) { super(e, t, i) } _haltDisabledEvents(t) { this.disabled && (t.preventDefault(), t.stopImmediatePropagation()) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Ew), Sa(Wo), Sa(aS, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["a", "mat-button", ""],
                ["a", "mat-raised-button", ""],
                ["a", "mat-icon-button", ""],
                ["a", "mat-fab", ""],
                ["a", "mat-mini-fab", ""],
                ["a", "mat-stroked-button", ""],
                ["a", "mat-flat-button", ""]
            ], hostAttrs: [1, "mat-focus-indicator"], hostVars: 5, hostBindings: function(t, e) { 1 & t && Ba("click", (function(t) { return e._haltDisabledEvents(t) })), 2 & t && (va("tabindex", e.disabled ? -1 : e.tabIndex || 0)("disabled", e.disabled || null)("aria-disabled", e.disabled.toString()), no("_mat-animation-noopable", "NoopAnimations" === e._animationMode)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color", tabIndex: "tabIndex" }, exportAs: ["matButton", "matAnchor"], features: [Eo], attrs: hk, ngContentSelectors: dk, decls: 4, vars: 5, consts: [
                [1, "mat-button-wrapper"],
                ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"],
                [1, "mat-button-focus-overlay"]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "span", 0), Wa(1), Ta(), Oa(2, "div", 1), Oa(3, "div", 2)), 2 & t && (ps(2), no("mat-button-ripple-round", e.isRoundButton || e.isIconButton), Da("matRippleDisabled", e._isRippleDisabled())("matRippleCentered", e.isIconButton)("matRippleTrigger", e._getHostElement())) }, directives: [qS], styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled],.mat-flat-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.cdk-high-contrast-active .mat-button-focus-overlay{background-color:#fff}.cdk-high-contrast-black-on-white .mat-button-focus-overlay{background-color:#000}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), _k = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [YS, _S], _S
            ] }), t })();
    const bk = ["input"], yk = function() { return { enterDuration: 150 } }, vk = ["*"], wk = new Vt("mat-checkbox-default-options", { providedIn: "root", factory: function() { return { color: "accent", clickAction: "check-indeterminate" } } }), Ck = new Vt("mat-checkbox-click-action");
    let xk = 0;
    const Sk = { provide: vg, useExisting: St(() => Ak), multi: !0 }; class kk {} class Ek { constructor(t) { this._elementRef = t } }
    const Dk = wS(yS(vS(bS(Ek))));
    let Ak = (() => { class t extends Dk { constructor(t, e, i, n, s, r, a, o) { super(t), this._changeDetectorRef = e, this._focusMonitor = i, this._ngZone = n, this._clickAction = r, this._animationMode = a, this._options = o, this.ariaLabel = "", this.ariaLabelledby = null, this._uniqueId = `mat-checkbox-${++xk}`, this.id = this._uniqueId, this.labelPosition = "after", this.name = null, this.change = new jl, this.indeterminateChange = new jl, this._onTouched = () => {}, this._currentAnimationClass = "", this._currentCheckState = 0, this._controlValueAccessorChangeFn = () => {}, this._checked = !1, this._disabled = !1, this._indeterminate = !1, this._options = this._options || {}, this._options.color && (this.color = this._options.color), this.tabIndex = parseInt(s) || 0, this._focusMonitor.monitor(t, !0).subscribe(t => { t || Promise.resolve().then(() => { this._onTouched(), e.markForCheck() }) }), this._clickAction = this._clickAction || this._options.clickAction } get inputId() { return `${this.id||this._uniqueId}-input` } get required() { return this._required } set required(t) { this._required = Vv(t) } ngAfterViewInit() { this._syncIndeterminate(this._indeterminate) } ngAfterViewChecked() {} ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } get checked() { return this._checked } set checked(t) { t != this.checked && (this._checked = t, this._changeDetectorRef.markForCheck()) } get disabled() { return this._disabled } set disabled(t) { const e = Vv(t);
                e !== this.disabled && (this._disabled = e, this._changeDetectorRef.markForCheck()) } get indeterminate() { return this._indeterminate } set indeterminate(t) { const e = t != this._indeterminate;
                this._indeterminate = Vv(t), e && (this._transitionCheckState(this._indeterminate ? 3 : this.checked ? 1 : 2), this.indeterminateChange.emit(this._indeterminate)), this._syncIndeterminate(this._indeterminate) } _isRippleDisabled() { return this.disableRipple || this.disabled } _onLabelTextChange() { this._changeDetectorRef.detectChanges() } writeValue(t) { this.checked = !!t } registerOnChange(t) { this._controlValueAccessorChangeFn = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t } _getAriaChecked() { return this.checked ? "true" : this.indeterminate ? "mixed" : "false" } _transitionCheckState(t) { let e = this._currentCheckState,
                    i = this._elementRef.nativeElement; if (e !== t && (this._currentAnimationClass.length > 0 && i.classList.remove(this._currentAnimationClass), this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(e, t), this._currentCheckState = t, this._currentAnimationClass.length > 0)) { i.classList.add(this._currentAnimationClass); const t = this._currentAnimationClass;
                    this._ngZone.runOutsideAngular(() => { setTimeout(() => { i.classList.remove(t) }, 1e3) }) } } _emitChangeEvent() { const t = new kk;
                t.source = this, t.checked = this.checked, this._controlValueAccessorChangeFn(this.checked), this.change.emit(t) } toggle() { this.checked = !this.checked } _onInputClick(t) { t.stopPropagation(), this.disabled || "noop" === this._clickAction ? this.disabled || "noop" !== this._clickAction || (this._inputElement.nativeElement.checked = this.checked, this._inputElement.nativeElement.indeterminate = this.indeterminate) : (this.indeterminate && "check" !== this._clickAction && Promise.resolve().then(() => { this._indeterminate = !1, this.indeterminateChange.emit(this._indeterminate) }), this.toggle(), this._transitionCheckState(this._checked ? 1 : 2), this._emitChangeEvent()) } focus(t = "keyboard", e) { this._focusMonitor.focusVia(this._inputElement, t, e) } _onInteractionEvent(t) { t.stopPropagation() } _getAnimationClassForCheckStateTransition(t, e) { if ("NoopAnimations" === this._animationMode) return ""; let i = ""; switch (t) {
                    case 0:
                        if (1 === e) i = "unchecked-checked";
                        else { if (3 != e) return "";
                            i = "unchecked-indeterminate" } break;
                    case 2:
                        i = 1 === e ? "unchecked-checked" : "unchecked-indeterminate"; break;
                    case 1:
                        i = 2 === e ? "checked-unchecked" : "checked-indeterminate"; break;
                    case 3:
                        i = 1 === e ? "indeterminate-checked" : "indeterminate-unchecked" } return `mat-checkbox-anim-${i}` } _syncIndeterminate(t) { const e = this._inputElement;
                e && (e.nativeElement.indeterminate = t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(Ew), Sa(Pc), ka("tabindex"), Sa(Ck, 8), Sa(aS, 8), Sa(wk, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-checkbox"]
            ], viewQuery: function(t, e) { var i;
                1 & t && (ic(bk, !0), ic(qS, !0)), 2 & t && (tc(i = oc()) && (e._inputElement = i.first), tc(i = oc()) && (e.ripple = i.first)) }, hostAttrs: [1, "mat-checkbox"], hostVars: 12, hostBindings: function(t, e) { 2 & t && (xo("id", e.id), va("tabindex", null), no("mat-checkbox-indeterminate", e.indeterminate)("mat-checkbox-checked", e.checked)("mat-checkbox-disabled", e.disabled)("mat-checkbox-label-before", "before" == e.labelPosition)("_mat-animation-noopable", "NoopAnimations" === e._animationMode)) }, inputs: { disableRipple: "disableRipple", color: "color", tabIndex: "tabIndex", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], id: "id", labelPosition: "labelPosition", name: "name", required: "required", checked: "checked", disabled: "disabled", indeterminate: "indeterminate", value: "value" }, outputs: { change: "change", indeterminateChange: "indeterminateChange" }, exportAs: ["matCheckbox"], features: [Ho([Sk]), Eo], ngContentSelectors: vk, decls: 17, vars: 19, consts: [
                [1, "mat-checkbox-layout"],
                ["label", ""],
                [1, "mat-checkbox-inner-container"],
                ["type", "checkbox", 1, "mat-checkbox-input", "cdk-visually-hidden", 3, "id", "required", "checked", "disabled", "tabIndex", "change", "click"],
                ["input", ""],
                ["matRipple", "", 1, "mat-checkbox-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleRadius", "matRippleCentered", "matRippleAnimation"],
                [1, "mat-ripple-element", "mat-checkbox-persistent-ripple"],
                [1, "mat-checkbox-frame"],
                [1, "mat-checkbox-background"],
                ["version", "1.1", "focusable", "false", "viewBox", "0 0 24 24", 0, "xml", "space", "preserve", 1, "mat-checkbox-checkmark"],
                ["fill", "none", "stroke", "white", "d", "M4.1,12.7 9,17.6 20.3,6.3", 1, "mat-checkbox-checkmark-path"],
                [1, "mat-checkbox-mixedmark"],
                [1, "mat-checkbox-label", 3, "cdkObserveContent"],
                ["checkboxLabel", ""],
                [2, "display", "none"]
            ], template: function(t, e) { if (1 & t && ($a(), Ia(0, "label", 0, 1), Ia(2, "div", 2), Ia(3, "input", 3, 4), Ba("change", (function(t) { return e._onInteractionEvent(t) }))("click", (function(t) { return e._onInputClick(t) })), Ta(), Ia(5, "div", 5), Oa(6, "div", 6), Ta(), Oa(7, "div", 7), Ia(8, "div", 8), Ci(), Ia(9, "svg", 9), Oa(10, "path", 10), Ta(), xi(), Oa(11, "div", 11), Ta(), Ta(), Ia(12, "span", 12, 13), Ba("cdkObserveContent", (function() { return e._onLabelTextChange() })), Ia(14, "span", 14), _o(15, "\xa0"), Ta(), Wa(16), Ta(), Ta()), 2 & t) { const t = xa(1),
                        i = xa(13);
                    va("for", e.inputId), ps(2), no("mat-checkbox-inner-container-no-side-margin", !i.textContent || !i.textContent.trim()), ps(1), Da("id", e.inputId)("required", e.required)("checked", e.checked)("disabled", e.disabled)("tabIndex", e.tabIndex), va("value", e.value)("name", e.name)("aria-label", e.ariaLabel || null)("aria-labelledby", e.ariaLabelledby)("aria-checked", e._getAriaChecked()), ps(2), Da("matRippleTrigger", t)("matRippleDisabled", e._isRippleDisabled())("matRippleRadius", 20)("matRippleCentered", !0)("matRippleAnimation", Ll(18, yk)) } }, directives: [qS, sw], styles: ["@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.910259}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);stroke-dashoffset:0}to{stroke-dashoffset:-22.910259}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0deg)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}32.8%,100%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox-layout{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-label{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}.mat-checkbox.cdk-keyboard-focused .cdk-high-contrast-active .mat-checkbox-frame{border-style:dotted}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0, 0, 0.2, 0.1),opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}._mat-animation-noopable .mat-checkbox-background{transition:none}.cdk-high-contrast-active .mat-checkbox .mat-checkbox-background{background:none}.mat-checkbox-persistent-ripple{width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-checkbox-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}@media(hover: none){.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{display:none}}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.910259;stroke-dasharray:22.910259;stroke-width:2.1333333333px}.cdk-high-contrast-black-on-white .mat-checkbox-checkmark-path{stroke:#000 !important}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0deg);border-radius:2px}.cdk-high-contrast-active .mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0deg)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.cdk-high-contrast-active .mat-checkbox-disabled{opacity:.5}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0ms mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0ms mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:300ms linear 0ms mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}\n"], encapsulation: 2, changeDetection: 0 }), t })();
    const Ik = { provide: Fg, useExisting: St(() => Tk), multi: !0 };
    let Tk = (() => { class t extends nb {} return t.\u0275fac = function(e) { return Ok(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-checkbox", "required", "", "formControlName", ""],
                ["mat-checkbox", "required", "", "formControl", ""],
                ["mat-checkbox", "required", "", "ngModel", ""]
            ], features: [Ho([Ik]), Eo] }), t })();
    const Ok = ln(Tk);
    let Rk = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })(), Mk = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [YS, _S, rw, Rk], _S, Rk
            ] }), t })(), Pk = (() => { class t { constructor() { this._vertical = !1, this._inset = !1 } get vertical() { return this._vertical } set vertical(t) { this._vertical = Vv(t) } get inset() { return this._inset } set inset(t) { this._inset = Vv(t) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-divider"]
            ], hostAttrs: ["role", "separator", 1, "mat-divider"], hostVars: 7, hostBindings: function(t, e) { 2 & t && (va("aria-orientation", e.vertical ? "vertical" : "horizontal"), no("mat-divider-vertical", e.vertical)("mat-divider-horizontal", !e.vertical)("mat-divider-inset", e.inset)) }, inputs: { vertical: "vertical", inset: "inset" }, decls: 0, vars: 0, template: function(t, e) {}, styles: [".mat-divider{display:block;margin:0;border-top-width:1px;border-top-style:solid}.mat-divider.mat-divider-vertical{border-top:0;border-right-width:1px;border-right-style:solid}.mat-divider.mat-divider-inset{margin-left:80px}[dir=rtl] .mat-divider.mat-divider-inset{margin-left:auto;margin-right:80px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), Fk = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [_S], _S
            ] }), t })();

    function Nk(t, e, i, s) { return n(i) && (s = i, i = void 0), s ? Nk(t, e, i).pipe(L(t => l(t) ? s(...t) : s(t))) : new v(n => {! function t(e, i, n, s, r) { let a; if (function(t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(e)) { const t = e;
                    e.addEventListener(i, n, r), a = () => t.removeEventListener(i, n, r) } else if (function(t) { return t && "function" == typeof t.on && "function" == typeof t.off }(e)) { const t = e;
                    e.on(i, n), a = () => t.off(i, n) } else if (function(t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(e)) { const t = e;
                    e.addListener(i, n), a = () => t.removeListener(i, n) } else { if (!e || !e.length) throw new TypeError("Invalid event target"); for (let a = 0, o = e.length; a < o; a++) t(e[a], i, n, s, r) } s.add(a) }(t, e, (function(t) { n.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }), n, i) }) } class Lk { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new Bk(t, this.durationSelector)) } } class Bk extends N { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { if (this.value = t, this.hasValue = !0, !this.throttled) { let i; try { const { durationSelector: e } = this;
                    i = e(t) } catch (e) { return this.destination.error(e) } const n = F(this, i);!n || n.closed ? this.clearThrottle() : this.add(this.throttled = n) } } clearThrottle() { const { value: t, hasValue: e, throttled: i } = this;
            i && (this.remove(i), this.throttled = null, i.unsubscribe()), e && (this.value = null, this.hasValue = !1, this.destination.next(t)) } notifyNext(t, e, i, n) { this.clearThrottle() } notifyComplete() { this.clearThrottle() } }

    function Vk(t) { return !l(t) && t - parseFloat(t) + 1 >= 0 }

    function zk(t = 0, e, i) { let n = -1; return Vk(e) ? n = Number(e) < 1 ? 1 : Number(e) : D(e) && (i = e), D(i) || (i = Pv), new v(e => { const s = Vk(t) ? t : +t - i.now(); return i.schedule(Uk, s, { index: 0, period: n, subscriber: e }) }) }

    function Uk(t) { const { index: e, period: i, subscriber: n } = t; if (n.next(e), !n.closed) { if (-1 === i) return n.complete();
            t.index = e + 1, this.schedule(t, i) } }

    function Hk(t, e = Pv) { return i = () => zk(t, e),
            function(t) { return t.lift(new Lk(i)) }; var i }

    function jk(t) { return e => e.lift(new Gk(t)) } class Gk { constructor(t) { this.notifier = t } call(t, e) { const i = new $k(t),
                n = F(i, this.notifier); return n && !i.seenValue ? (i.add(n), e.subscribe(i)) : i } } class $k extends N { constructor(t) { super(t), this.seenValue = !1 } notifyNext(t, e, i, n, s) { this.seenValue = !0, this.complete() } notifyComplete() {} }
    const Wk = Jv({ passive: !0 });
    let qk = (() => { class t { constructor(t, e) { this._platform = t, this._ngZone = e, this._monitoredElements = new Map } monitor(t) { if (!this._platform.isBrowser) return zu; const e = jv(t),
                    i = this._monitoredElements.get(e); if (i) return i.subject.asObservable(); const n = new k,
                    s = "cdk-text-field-autofilled",
                    r = t => { "cdk-text-field-autofill-start" !== t.animationName || e.classList.contains(s) ? "cdk-text-field-autofill-end" === t.animationName && e.classList.contains(s) && (e.classList.remove(s), this._ngZone.run(() => n.next({ target: t.target, isAutofilled: !1 }))) : (e.classList.add(s), this._ngZone.run(() => n.next({ target: t.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { e.addEventListener("animationstart", r, Wk), e.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(e, { subject: n, unlisten: () => { e.removeEventListener("animationstart", r, Wk) } }), n.asObservable() } stopMonitoring(t) { const e = jv(t),
                    i = this._monitoredElements.get(e);
                i && (i.unlisten(), i.subject.complete(), e.classList.remove("cdk-text-field-autofill-monitored"), e.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(e)) } ngOnDestroy() { this._monitoredElements.forEach((t, e) => this.stopMonitoring(e)) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Wv), Xt(Pc)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(Wv), Xt(Pc)) }, token: t, providedIn: "root" }), t })(), Yk = (() => { class t { constructor(t, e) { this._elementRef = t, this._autofillMonitor = e, this.cdkAutofill = new jl } ngOnInit() { this._autofillMonitor.monitor(this._elementRef).subscribe(t => this.cdkAutofill.emit(t)) } ngOnDestroy() { this._autofillMonitor.stopMonitoring(this._elementRef) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(qk)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkAutofill", ""]
            ], outputs: { cdkAutofill: "cdkAutofill" } }), t })(), Xk = (() => { class t { constructor(t, e, i, n) { this._elementRef = t, this._platform = e, this._ngZone = i, this._destroyed = new k, this._enabled = !0, this._previousMinRows = -1, this._document = n, this._textareaElement = this._elementRef.nativeElement } get minRows() { return this._minRows } set minRows(t) { this._minRows = zv(t), this._setMinHeight() } get maxRows() { return this._maxRows } set maxRows(t) { this._maxRows = zv(t), this._setMaxHeight() } get enabled() { return this._enabled } set enabled(t) { t = Vv(t), this._enabled !== t && ((this._enabled = t) ? this.resizeToFitContent(!0) : this.reset()) } _setMinHeight() { const t = this.minRows && this._cachedLineHeight ? `${this.minRows*this._cachedLineHeight}px` : null;
                t && (this._textareaElement.style.minHeight = t) } _setMaxHeight() { const t = this.maxRows && this._cachedLineHeight ? `${this.maxRows*this._cachedLineHeight}px` : null;
                t && (this._textareaElement.style.maxHeight = t) } ngAfterViewInit() { this._platform.isBrowser && (this._initialHeight = this._textareaElement.style.height, this.resizeToFitContent(), this._ngZone.runOutsideAngular(() => { Nk(this._getWindow(), "resize").pipe(Hk(16), jk(this._destroyed)).subscribe(() => this.resizeToFitContent(!0)) })) } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _cacheTextareaLineHeight() { if (this._cachedLineHeight) return; let t = this._textareaElement.cloneNode(!1);
                t.rows = 1, t.style.position = "absolute", t.style.visibility = "hidden", t.style.border = "none", t.style.padding = "0", t.style.height = "", t.style.minHeight = "", t.style.maxHeight = "", t.style.overflow = "hidden", this._textareaElement.parentNode.appendChild(t), this._cachedLineHeight = t.clientHeight, this._textareaElement.parentNode.removeChild(t), this._setMinHeight(), this._setMaxHeight() } ngDoCheck() { this._platform.isBrowser && this.resizeToFitContent() } resizeToFitContent(t = !1) { if (!this._enabled) return; if (this._cacheTextareaLineHeight(), !this._cachedLineHeight) return; const e = this._elementRef.nativeElement,
                    i = e.value; if (!t && this._minRows === this._previousMinRows && i === this._previousValue) return; const n = e.placeholder;
                e.classList.add("cdk-textarea-autosize-measuring"), e.placeholder = "", e.style.height = `${e.scrollHeight-4}px`, e.classList.remove("cdk-textarea-autosize-measuring"), e.placeholder = n, this._ngZone.runOutsideAngular(() => { "undefined" != typeof requestAnimationFrame ? requestAnimationFrame(() => this._scrollToCaretPosition(e)) : setTimeout(() => this._scrollToCaretPosition(e)) }), this._previousValue = i, this._previousMinRows = this._minRows } reset() { void 0 !== this._initialHeight && (this._textareaElement.style.height = this._initialHeight) } _noopInputHandler() {} _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _scrollToCaretPosition(t) { const { selectionStart: e, selectionEnd: i } = t, n = this._getDocument();
                this._destroyed.isStopped || n.activeElement !== t || t.setSelectionRange(e, i) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Wv), Sa(Pc), Sa(uh, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["textarea", "cdkTextareaAutosize", ""]
            ], hostAttrs: ["rows", "1", 1, "cdk-textarea-autosize"], hostBindings: function(t, e) { 1 & t && Ba("input", (function() { return e._noopInputHandler() })) }, inputs: { minRows: ["cdkAutosizeMinRows", "minRows"], maxRows: ["cdkAutosizeMaxRows", "maxRows"], enabled: ["cdkTextareaAutosize", "enabled"] }, exportAs: ["cdkTextareaAutosize"] }), t })(), Kk = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [qv]
            ] }), t })();
    const Zk = ["underline"], Qk = ["connectionContainer"], Jk = ["inputContainer"], tE = ["label"];

    function eE(t, e) { 1 & t && (Ra(0), Ia(1, "div", 14), Oa(2, "div", 15), Oa(3, "div", 16), Oa(4, "div", 17), Ta(), Ia(5, "div", 18), Oa(6, "div", 15), Oa(7, "div", 16), Oa(8, "div", 17), Ta(), Ma()) }

    function iE(t, e) { 1 & t && (Ia(0, "div", 19), Wa(1, 1), Ta()) }

    function nE(t, e) { if (1 & t && (Ra(0), Wa(1, 2), Ia(2, "span"), _o(3), Ta(), Ma()), 2 & t) { const t = ja(2);
            ps(3), bo(t._control.placeholder) } }

    function sE(t, e) { 1 & t && Wa(0, 3, ["*ngSwitchCase", "true"]) }

    function rE(t, e) { 1 & t && (Ia(0, "span", 23), _o(1, " *"), Ta()) }

    function aE(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "label", 20, 21), Ba("cdkObserveContent", (function() { return Qe(t), ja().updateOutlineGap() })), Ca(2, nE, 4, 1, "ng-container", 12), Ca(3, sE, 1, 0, void 0, 12), Ca(4, rE, 2, 0, "span", 22), Ta() } if (2 & t) { const t = ja();
            no("mat-empty", t._control.empty && !t._shouldAlwaysFloat)("mat-form-field-empty", t._control.empty && !t._shouldAlwaysFloat)("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color), Da("cdkObserveContentDisabled", "outline" != t.appearance)("id", t._labelId)("ngSwitch", t._hasLabel()), va("for", t._control.id)("aria-owns", t._control.id), ps(2), Da("ngSwitchCase", !1), ps(1), Da("ngSwitchCase", !0), ps(1), Da("ngIf", !t.hideRequiredMarker && t._control.required && !t._control.disabled) } }

    function oE(t, e) { 1 & t && (Ia(0, "div", 24), Wa(1, 4), Ta()) }

    function lE(t, e) { if (1 & t && (Ia(0, "div", 25, 26), Oa(2, "span", 27), Ta()), 2 & t) { const t = ja();
            ps(2), no("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color) } }

    function cE(t, e) { 1 & t && (Ia(0, "div"), Wa(1, 5), Ta()), 2 & t && Da("@transitionMessages", ja()._subscriptAnimationState) }

    function hE(t, e) { if (1 & t && (Ia(0, "div", 31), _o(1), Ta()), 2 & t) { const t = ja(2);
            Da("id", t._hintLabelId), ps(1), bo(t.hintLabel) } }

    function dE(t, e) { if (1 & t && (Ia(0, "div", 28), Ca(1, hE, 2, 2, "div", 29), Wa(2, 6), Oa(3, "div", 30), Wa(4, 7), Ta()), 2 & t) { const t = ja();
            Da("@transitionMessages", t._subscriptAnimationState), ps(1), Da("ngIf", t.hintLabel) } }
    const uE = ["*", [
            ["", "matPrefix", ""]
        ],
        [
            ["mat-placeholder"]
        ],
        [
            ["mat-label"]
        ],
        [
            ["", "matSuffix", ""]
        ],
        [
            ["mat-error"]
        ],
        [
            ["mat-hint", 3, "align", "end"]
        ],
        [
            ["mat-hint", "align", "end"]
        ]
    ], mE = ["*", "[matPrefix]", "mat-placeholder", "mat-label", "[matSuffix]", "mat-error", "mat-hint:not([align='end'])", "mat-hint[align='end']"];
    let pE = 0, fE = (() => { class t { constructor() { this.id = `mat-error-${pE++}` } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-error"]
            ], hostAttrs: ["role", "alert", 1, "mat-error"], hostVars: 1, hostBindings: function(t, e) { 2 & t && va("id", e.id) }, inputs: { id: "id" } }), t })();
    const gE = { transitionMessages: Lw("transitionMessages", [Hw("enter", Uw({ opacity: 1, transform: "translateY(0%)" })), Gw("void => enter", [Uw({ opacity: 0, transform: "translateY(-100%)" }), Bw("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) };
    let _E = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t }), t })();

    function bE(t) { return Error(`A hint was already declared for 'align="${t}"'.`) }
    let yE = 0, vE = (() => { class t { constructor() { this.align = "start", this.id = `mat-hint-${yE++}` } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-hint"]
            ], hostAttrs: [1, "mat-hint"], hostVars: 4, hostBindings: function(t, e) { 2 & t && (va("id", e.id)("align", null), no("mat-right", "end" == e.align)) }, inputs: { align: "align", id: "id" } }), t })(), wE = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-label"]
            ] }), t })(), CE = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-placeholder"]
            ] }), t })(), xE = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matPrefix", ""]
            ] }), t })(), SE = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matSuffix", ""]
            ] }), t })(), kE = 0; class EE { constructor(t) { this._elementRef = t } }
    const DE = yS(EE, "primary"), AE = new Vt("MAT_FORM_FIELD_DEFAULT_OPTIONS"), IE = new Vt("MatFormField");
    let TE = (() => { class t extends DE { constructor(t, e, i, n, s, r, a, o) { super(t), this._elementRef = t, this._changeDetectorRef = e, this._dir = n, this._defaults = s, this._platform = r, this._ngZone = a, this._outlineGapCalculationNeededImmediately = !1, this._outlineGapCalculationNeededOnStable = !1, this._destroyed = new k, this._showAlwaysAnimate = !1, this._subscriptAnimationState = "", this._hintLabel = "", this._hintLabelId = `mat-hint-${kE++}`, this._labelId = `mat-form-field-label-${kE++}`, this._labelOptions = i || {}, this.floatLabel = this._getDefaultFloatLabelState(), this._animationsEnabled = "NoopAnimations" !== o, this.appearance = s && s.appearance ? s.appearance : "legacy", this._hideRequiredMarker = !(!s || null == s.hideRequiredMarker) && s.hideRequiredMarker } get appearance() { return this._appearance } set appearance(t) { const e = this._appearance;
                this._appearance = t || this._defaults && this._defaults.appearance || "legacy", "outline" === this._appearance && e !== t && (this._outlineGapCalculationNeededOnStable = !0) } get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(t) { this._hideRequiredMarker = Vv(t) } get _shouldAlwaysFloat() { return "always" === this.floatLabel && !this._showAlwaysAnimate } get _canLabelFloat() { return "never" !== this.floatLabel } get hintLabel() { return this._hintLabel } set hintLabel(t) { this._hintLabel = t, this._processHints() } get floatLabel() { return "legacy" !== this.appearance && "never" === this._floatLabel ? "auto" : this._floatLabel } set floatLabel(t) { t !== this._floatLabel && (this._floatLabel = t || this._getDefaultFloatLabelState(), this._changeDetectorRef.markForCheck()) } get _control() { return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic } set _control(t) { this._explicitFormFieldControl = t } get _labelChild() { return this._labelChildNonStatic || this._labelChildStatic } getConnectedOverlayOrigin() { return this._connectionContainerRef || this._elementRef } ngAfterContentInit() { this._validateControlChild(); const t = this._control;
                t.controlType && this._elementRef.nativeElement.classList.add(`mat-form-field-type-${t.controlType}`), t.stateChanges.pipe(bm(null)).subscribe(() => { this._validatePlaceholders(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), t.ngControl && t.ngControl.valueChanges && t.ngControl.valueChanges.pipe(jk(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.asObservable().pipe(jk(this._destroyed)).subscribe(() => { this._outlineGapCalculationNeededOnStable && this.updateOutlineGap() }) }), q(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._outlineGapCalculationNeededOnStable = !0, this._changeDetectorRef.markForCheck() }), this._hintChildren.changes.pipe(bm(null)).subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.pipe(bm(null)).subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._dir && this._dir.change.pipe(jk(this._destroyed)).subscribe(() => { "function" == typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => this.updateOutlineGap()) }) : this.updateOutlineGap() }) } ngAfterContentChecked() { this._validateControlChild(), this._outlineGapCalculationNeededImmediately && this.updateOutlineGap() } ngAfterViewInit() { this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _shouldForward(t) { const e = this._control ? this._control.ngControl : null; return e && e[t] } _hasPlaceholder() { return !!(this._control && this._control.placeholder || this._placeholderChild) } _hasLabel() { return !!this._labelChild } _shouldLabelFloat() { return this._canLabelFloat && (this._control.shouldLabelFloat || this._shouldAlwaysFloat) } _hideControlPlaceholder() { return "legacy" === this.appearance && !this._hasLabel() || this._hasLabel() && !this._shouldLabelFloat() } _hasFloatingLabel() { return this._hasLabel() || "legacy" === this.appearance && this._hasPlaceholder() } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _animateAndLockLabel() { this._hasFloatingLabel() && this._canLabelFloat && (this._animationsEnabled && this._label && (this._showAlwaysAnimate = !0, Nk(this._label.nativeElement, "transitionend").pipe(lm(1)).subscribe(() => { this._showAlwaysAnimate = !1 })), this.floatLabel = "always", this._changeDetectorRef.markForCheck()) } _validatePlaceholders() { if (this._control.placeholder && this._placeholderChild) throw Error("Placeholder attribute and child element were both specified.") } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { if (this._hintChildren) { let t, e;
                    this._hintChildren.forEach(i => { if ("start" === i.align) { if (t || this.hintLabel) throw bE("start");
                            t = i } else if ("end" === i.align) { if (e) throw bE("end");
                            e = i } }) } } _getDefaultFloatLabelState() { return this._defaults && this._defaults.floatLabel || this._labelOptions.float || "auto" } _syncDescribedByIds() { if (this._control) { let t = []; if ("hint" === this._getDisplayedMessages()) { const e = this._hintChildren ? this._hintChildren.find(t => "start" === t.align) : null,
                            i = this._hintChildren ? this._hintChildren.find(t => "end" === t.align) : null;
                        e ? t.push(e.id) : this._hintLabel && t.push(this._hintLabelId), i && t.push(i.id) } else this._errorChildren && (t = this._errorChildren.map(t => t.id));
                    this._control.setDescribedByIds(t) } } _validateControlChild() { if (!this._control) throw Error("mat-form-field must contain a MatFormFieldControl.") } updateOutlineGap() { const t = this._label ? this._label.nativeElement : null; if ("outline" !== this.appearance || !t || !t.children.length || !t.textContent.trim()) return; if (!this._platform.isBrowser) return; if (!this._isAttachedToDOM()) return void(this._outlineGapCalculationNeededImmediately = !0); let e = 0,
                    i = 0; const n = this._connectionContainerRef.nativeElement,
                    s = n.querySelectorAll(".mat-form-field-outline-start"),
                    r = n.querySelectorAll(".mat-form-field-outline-gap"); if (this._label && this._label.nativeElement.children.length) { const s = n.getBoundingClientRect(); if (0 === s.width && 0 === s.height) return this._outlineGapCalculationNeededOnStable = !0, void(this._outlineGapCalculationNeededImmediately = !1); const r = this._getStartEnd(s),
                        a = this._getStartEnd(t.children[0].getBoundingClientRect()); let o = 0; for (const e of t.children) o += e.offsetWidth;
                    e = Math.abs(a - r) - 5, i = o > 0 ? .75 * o + 10 : 0 } for (let a = 0; a < s.length; a++) s[a].style.width = `${e}px`; for (let a = 0; a < r.length; a++) r[a].style.width = `${i}px`;
                this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1 } _getStartEnd(t) { return this._dir && "rtl" === this._dir.value ? t.right : t.left } _isAttachedToDOM() { const t = this._elementRef.nativeElement; if (t.getRootNode) { const e = t.getRootNode(); return e && e !== t } return document.documentElement.contains(t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(ck, 8), Sa(Rw, 8), Sa(AE, 8), Sa(Wv), Sa(Pc), Sa(aS, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-form-field"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, _E, !0), rc(i, _E, !0), sc(i, wE, !0), rc(i, wE, !0), sc(i, CE, !0), sc(i, fE, !0), sc(i, vE, !0), sc(i, xE, !0), sc(i, SE, !0)), 2 & t && (tc(n = oc()) && (e._controlNonStatic = n.first), tc(n = oc()) && (e._controlStatic = n.first), tc(n = oc()) && (e._labelChildNonStatic = n.first), tc(n = oc()) && (e._labelChildStatic = n.first), tc(n = oc()) && (e._placeholderChild = n.first), tc(n = oc()) && (e._errorChildren = n), tc(n = oc()) && (e._hintChildren = n), tc(n = oc()) && (e._prefixChildren = n), tc(n = oc()) && (e._suffixChildren = n)) }, viewQuery: function(t, e) { var i;
                1 & t && (ic(Zk, !0), ec(Qk, !0), ic(Jk, !0), ic(tE, !0)), 2 & t && (tc(i = oc()) && (e.underlineRef = i.first), tc(i = oc()) && (e._connectionContainerRef = i.first), tc(i = oc()) && (e._inputContainerRef = i.first), tc(i = oc()) && (e._label = i.first)) }, hostAttrs: [1, "mat-form-field"], hostVars: 44, hostBindings: function(t, e) { 2 & t && no("mat-form-field-appearance-standard", "standard" == e.appearance)("mat-form-field-appearance-fill", "fill" == e.appearance)("mat-form-field-appearance-outline", "outline" == e.appearance)("mat-form-field-appearance-legacy", "legacy" == e.appearance)("mat-form-field-invalid", e._control.errorState)("mat-form-field-can-float", e._canLabelFloat)("mat-form-field-should-float", e._shouldLabelFloat())("mat-form-field-has-label", e._hasFloatingLabel())("mat-form-field-hide-placeholder", e._hideControlPlaceholder())("mat-form-field-disabled", e._control.disabled)("mat-form-field-autofilled", e._control.autofilled)("mat-focused", e._control.focused)("mat-accent", "accent" == e.color)("mat-warn", "warn" == e.color)("ng-untouched", e._shouldForward("untouched"))("ng-touched", e._shouldForward("touched"))("ng-pristine", e._shouldForward("pristine"))("ng-dirty", e._shouldForward("dirty"))("ng-valid", e._shouldForward("valid"))("ng-invalid", e._shouldForward("invalid"))("ng-pending", e._shouldForward("pending"))("_mat-animation-noopable", !e._animationsEnabled) }, inputs: { color: "color", floatLabel: "floatLabel", appearance: "appearance", hideRequiredMarker: "hideRequiredMarker", hintLabel: "hintLabel" }, exportAs: ["matFormField"], features: [Ho([{ provide: IE, useExisting: t }]), Eo], ngContentSelectors: mE, decls: 15, vars: 8, consts: [
                [1, "mat-form-field-wrapper"],
                [1, "mat-form-field-flex", 3, "click"],
                ["connectionContainer", ""],
                [4, "ngIf"],
                ["class", "mat-form-field-prefix", 4, "ngIf"],
                [1, "mat-form-field-infix"],
                ["inputContainer", ""],
                [1, "mat-form-field-label-wrapper"],
                ["class", "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "mat-empty", "mat-form-field-empty", "mat-accent", "mat-warn", "ngSwitch", "cdkObserveContent", 4, "ngIf"],
                ["class", "mat-form-field-suffix", 4, "ngIf"],
                ["class", "mat-form-field-underline", 4, "ngIf"],
                [1, "mat-form-field-subscript-wrapper", 3, "ngSwitch"],
                [4, "ngSwitchCase"],
                ["class", "mat-form-field-hint-wrapper", 4, "ngSwitchCase"],
                [1, "mat-form-field-outline"],
                [1, "mat-form-field-outline-start"],
                [1, "mat-form-field-outline-gap"],
                [1, "mat-form-field-outline-end"],
                [1, "mat-form-field-outline", "mat-form-field-outline-thick"],
                [1, "mat-form-field-prefix"],
                [1, "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "ngSwitch", "cdkObserveContent"],
                ["label", ""],
                ["class", "mat-placeholder-required mat-form-field-required-marker", "aria-hidden", "true", 4, "ngIf"],
                ["aria-hidden", "true", 1, "mat-placeholder-required", "mat-form-field-required-marker"],
                [1, "mat-form-field-suffix"],
                [1, "mat-form-field-underline"],
                ["underline", ""],
                [1, "mat-form-field-ripple"],
                [1, "mat-form-field-hint-wrapper"],
                ["class", "mat-hint", 3, "id", 4, "ngIf"],
                [1, "mat-form-field-hint-spacer"],
                [1, "mat-hint", 3, "id"]
            ], template: function(t, e) { 1 & t && ($a(uE), Ia(0, "div", 0), Ia(1, "div", 1, 2), Ba("click", (function(t) { return e._control.onContainerClick && e._control.onContainerClick(t) })), Ca(3, eE, 9, 0, "ng-container", 3), Ca(4, iE, 2, 0, "div", 4), Ia(5, "div", 5, 6), Wa(7), Ia(8, "span", 7), Ca(9, aE, 5, 16, "label", 8), Ta(), Ta(), Ca(10, oE, 2, 0, "div", 9), Ta(), Ca(11, lE, 3, 4, "div", 10), Ia(12, "div", 11), Ca(13, cE, 2, 1, "div", 12), Ca(14, dE, 5, 2, "div", 13), Ta(), Ta()), 2 & t && (ps(3), Da("ngIf", "outline" == e.appearance), ps(1), Da("ngIf", e._prefixChildren.length), ps(5), Da("ngIf", e._hasFloatingLabel()), ps(1), Da("ngIf", e._suffixChildren.length), ps(1), Da("ngIf", "outline" != e.appearance), ps(1), Da("ngSwitch", e._getDisplayedMessages()), ps(1), Da("ngSwitchCase", "error"), ps(1), Da("ngSwitchCase", "hint")) }, directives: [yd, xd, Sd, sw], styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:scaleX(1);transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n", '.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n', '.mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n', ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n"], encapsulation: 2, data: { animation: [gE.transitionMessages] }, changeDetection: 0 }), t })(), OE = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [Jd, rw]
            ] }), t })(), RE = (() => { class t extends Xk { get matAutosizeMinRows() { return this.minRows } set matAutosizeMinRows(t) { this.minRows = t } get matAutosizeMaxRows() { return this.maxRows } set matAutosizeMaxRows(t) { this.maxRows = t } get matAutosize() { return this.enabled } set matAutosize(t) { this.enabled = t } get matTextareaAutosize() { return this.enabled } set matTextareaAutosize(t) { this.enabled = t } } return t.\u0275fac = function(e) { return ME(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["textarea", "mat-autosize", ""],
                ["textarea", "matTextareaAutosize", ""]
            ], hostAttrs: ["rows", "1", 1, "cdk-textarea-autosize", "mat-autosize"], inputs: { cdkAutosizeMinRows: "cdkAutosizeMinRows", cdkAutosizeMaxRows: "cdkAutosizeMaxRows", matAutosizeMinRows: "matAutosizeMinRows", matAutosizeMaxRows: "matAutosizeMaxRows", matAutosize: ["mat-autosize", "matAutosize"], matTextareaAutosize: "matTextareaAutosize" }, exportAs: ["matTextareaAutosize"], features: [Eo] }), t })();
    const ME = ln(RE), PE = new Vt("MAT_INPUT_VALUE_ACCESSOR"), FE = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"];
    let NE = 0; class LE { constructor(t, e, i, n) { this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = i, this.ngControl = n } }
    const BE = CS(LE);
    let VE = (() => { class t extends BE { constructor(t, e, i, n, s, r, a, o, l) { super(r, n, s, i), this._elementRef = t, this._platform = e, this.ngControl = i, this._autofillMonitor = o, this._uid = `mat-input-${NE++}`, this._isServer = !1, this._isNativeSelect = !1, this.focused = !1, this.stateChanges = new k, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._required = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(t => Xv().has(t)); const c = this._elementRef.nativeElement;
                this._inputValueAccessor = a || c, this._previousNativeValue = this.value, this.id = this.id, e.IOS && l.runOutsideAngular(() => { t.nativeElement.addEventListener("keyup", t => { let e = t.target;
                        e.value || e.selectionStart || e.selectionEnd || (e.setSelectionRange(1, 1), e.setSelectionRange(0, 0)) }) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === c.nodeName.toLowerCase(), this._isNativeSelect && (this.controlType = c.multiple ? "mat-native-select-multiple" : "mat-native-select") } get disabled() { return this.ngControl && null !== this.ngControl.disabled ? this.ngControl.disabled : this._disabled } set disabled(t) { this._disabled = Vv(t), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(t) { this._id = t || this._uid } get required() { return this._required } set required(t) { this._required = Vv(t) } get type() { return this._type } set type(t) { this._type = t || "text", this._validateType(), !this._isTextarea() && Xv().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(t) { t !== this.value && (this._inputValueAccessor.value = t, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(t) { this._readonly = Vv(t) } ngOnInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(t => { this.autofilled = t.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement) } ngDoCheck() { this.ngControl && this.updateErrorState(), this._dirtyCheckNativeValue() } focus(t) { this._elementRef.nativeElement.focus(t) } _focusChanged(t) { t === this.focused || this.readonly && t || (this.focused = t, this.stateChanges.next()) } _onInput() {} _isTextarea() { return "textarea" === this._elementRef.nativeElement.nodeName.toLowerCase() } _dirtyCheckNativeValue() { const t = this._elementRef.nativeElement.value;
                this._previousNativeValue !== t && (this._previousNativeValue = t, this.stateChanges.next()) } _validateType() { if (FE.indexOf(this._type) > -1) throw Error(`Input type "${this._type}" isn't supported by matInput.`) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let t = this._elementRef.nativeElement.validity; return t && t.badInput } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const t = this._elementRef.nativeElement,
                        e = t.options[0]; return this.focused || t.multiple || !this.empty || !!(t.selectedIndex > -1 && e && e.label) } return this.focused || !this.empty } setDescribedByIds(t) { this._ariaDescribedby = t.join(" ") } onContainerClick() { this.focused || this.focus() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Wv), Sa(Tg, 10), Sa(R_, 8), Sa(W_, 8), Sa(LS), Sa(PE, 10), Sa(qk), Sa(Pc)) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "matInput", ""],
                ["textarea", "matInput", ""],
                ["select", "matNativeControl", ""],
                ["input", "matNativeControl", ""],
                ["textarea", "matNativeControl", ""]
            ], hostAttrs: [1, "mat-input-element", "mat-form-field-autofill-control"], hostVars: 10, hostBindings: function(t, e) { 1 & t && Ba("blur", (function() { return e._focusChanged(!1) }))("focus", (function() { return e._focusChanged(!0) }))("input", (function() { return e._onInput() })), 2 & t && (xo("disabled", e.disabled)("required", e.required), va("id", e.id)("placeholder", e.placeholder)("readonly", e.readonly && !e._isNativeSelect || null)("aria-describedby", e._ariaDescribedby || null)("aria-invalid", e.errorState)("aria-required", e.required.toString()), no("mat-input-server", e._isServer)) }, inputs: { id: "id", disabled: "disabled", required: "required", type: "type", value: "value", readonly: "readonly", placeholder: "placeholder", errorStateMatcher: "errorStateMatcher" }, exportAs: ["matInput"], features: [Ho([{ provide: _E, useExisting: t }]), Eo, Ro] }), t })(), zE = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [LS], imports: [
                [Kk, OE], Kk, OE
            ] }), t })(), UE = 1;
    const HE = (() => Promise.resolve())(), jE = {};

    function GE(t) { return t in jE && (delete jE[t], !0) }
    const $E = { setImmediate(t) { const e = UE++; return jE[e] = !0, HE.then(() => GE(e) && t()), e }, clearImmediate(t) { GE(t) } }; class WE extends Ov { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t.scheduled || (t.scheduled = $E.setImmediate(t.flush.bind(t, null)))) } recycleAsyncId(t, e, i = 0) { if (null !== i && i > 0 || null === i && this.delay > 0) return super.recycleAsyncId(t, e, i);
            0 === t.actions.length && ($E.clearImmediate(e), t.scheduled = void 0) } } class qE extends Mv { flush(t) { this.active = !0, this.scheduled = void 0; const { actions: e } = this; let i, n = -1,
                s = e.length;
            t = t || e.shift();
            do { if (i = t.execute(t.state, t.delay)) break } while (++n < s && (t = e.shift())); if (this.active = !1, i) { for (; ++n < s && (t = e.shift());) t.unsubscribe(); throw i } } }
    const YE = new qE(WE);

    function XE(t, e) { return i => i.lift(new KE(t, e)) } class KE { constructor(t, e) { this.compare = t, this.keySelector = e } call(t, e) { return e.subscribe(new ZE(t, this.compare, this.keySelector)) } } class ZE extends p { constructor(t, e, i) { super(t), this.keySelector = i, this.hasKey = !1, "function" == typeof e && (this.compare = e) } compare(t, e) { return t === e } _next(t) { let e; try { const { keySelector: i } = this;
                e = i ? i(t) : t } catch (n) { return this.destination.error(n) } let i = !1; if (this.hasKey) try { const { compare: t } = this;
                i = t(this.key, e) } catch (n) { return this.destination.error(n) } else this.hasKey = !0;
            i || (this.key = e, this.destination.next(t)) } } class QE extends Ov { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } schedule(t, e = 0) { return e > 0 ? super.schedule(t, e) : (this.delay = e, this.state = t, this.scheduler.flush(this), this) } execute(t, e) { return e > 0 || this.closed ? super.execute(t, e) : this._execute(t, e) } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 || null === i && this.delay > 0 ? super.requestAsyncId(t, e, i) : t.flush(this) } } class JE extends Mv {}
    const tD = new JE(QE);

    function eD(t, e) { return new v(e ? i => e.schedule(iD, 0, { error: t, subscriber: i }) : e => e.error(t)) }

    function iD({ error: t, subscriber: e }) { e.error(t) }
    let nD = (() => { class t { constructor(t, e, i) { this.kind = t, this.value = e, this.error = i, this.hasValue = "N" === t } observe(t) { switch (this.kind) {
                    case "N":
                        return t.next && t.next(this.value);
                    case "E":
                        return t.error && t.error(this.error);
                    case "C":
                        return t.complete && t.complete() } } do(t, e, i) { switch (this.kind) {
                    case "N":
                        return t && t(this.value);
                    case "E":
                        return e && e(this.error);
                    case "C":
                        return i && i() } } accept(t, e, i) { return t && "function" == typeof t.next ? this.observe(t) : this.do(t, e, i) } toObservable() { switch (this.kind) {
                    case "N":
                        return Mu(this.value);
                    case "E":
                        return eD(this.error);
                    case "C":
                        return Uu() } throw new Error("unexpected notification kind value") } static createNext(e) { return void 0 !== e ? new t("N", e) : t.undefinedValueNotification } static createError(e) { return new t("E", void 0, e) } static createComplete() { return t.completeNotification } } return t.completeNotification = new t("C"), t.undefinedValueNotification = new t("N", void 0), t })(); class sD extends p { constructor(t, e, i = 0) { super(t), this.scheduler = e, this.delay = i } static dispatch(t) { const { notification: e, destination: i } = t;
            e.observe(i), this.unsubscribe() } scheduleMessage(t) { this.destination.add(this.scheduler.schedule(sD.dispatch, this.delay, new rD(t, this.destination))) } _next(t) { this.scheduleMessage(nD.createNext(t)) } _error(t) { this.scheduleMessage(nD.createError(t)), this.unsubscribe() } _complete() { this.scheduleMessage(nD.createComplete()), this.unsubscribe() } } class rD { constructor(t, e) { this.notification = t, this.destination = e } } class aD extends k { constructor(t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, i) { super(), this.scheduler = i, this._events = [], this._infiniteTimeWindow = !1, this._bufferSize = t < 1 ? 1 : t, this._windowTime = e < 1 ? 1 : e, e === Number.POSITIVE_INFINITY ? (this._infiniteTimeWindow = !0, this.next = this.nextInfiniteTimeWindow) : this.next = this.nextTimeWindow } nextInfiniteTimeWindow(t) { const e = this._events;
            e.push(t), e.length > this._bufferSize && e.shift(), super.next(t) } nextTimeWindow(t) { this._events.push(new oD(this._getNow(), t)), this._trimBufferThenGetEvents(), super.next(t) } _subscribe(t) { const e = this._infiniteTimeWindow,
                i = e ? this._events : this._trimBufferThenGetEvents(),
                n = this.scheduler,
                s = i.length; let r; if (this.closed) throw new C; if (this.isStopped || this.hasError ? r = d.EMPTY : (this.observers.push(t), r = new x(this, t)), n && t.add(t = new sD(t, n)), e)
                for (let a = 0; a < s && !t.closed; a++) t.next(i[a]);
            else
                for (let a = 0; a < s && !t.closed; a++) t.next(i[a].value); return this.hasError ? t.error(this.thrownError) : this.isStopped && t.complete(), r } _getNow() { return (this.scheduler || tD).now() } _trimBufferThenGetEvents() { const t = this._getNow(),
                e = this._bufferSize,
                i = this._windowTime,
                n = this._events,
                s = n.length; let r = 0; for (; r < s && !(t - n[r].time < i);) r++; return s > e && (r = Math.max(r, s - e)), r > 0 && n.splice(0, r), n } } class oD { constructor(t, e) { this.time = t, this.value = e } }

    function lD(t) { return t && "function" == typeof t.connect } class cD { constructor(t = !1, e, i = !0) { this._multiple = t, this._emitChanges = i, this._selection = new Set, this._deselectedToEmit = [], this._selectedToEmit = [], this.changed = new k, e && e.length && (t ? e.forEach(t => this._markSelected(t)) : this._markSelected(e[0]), this._selectedToEmit.length = 0) } get selected() { return this._selected || (this._selected = Array.from(this._selection.values())), this._selected } select(...t) { this._verifyValueAssignment(t), t.forEach(t => this._markSelected(t)), this._emitChangeEvent() } deselect(...t) { this._verifyValueAssignment(t), t.forEach(t => this._unmarkSelected(t)), this._emitChangeEvent() } toggle(t) { this.isSelected(t) ? this.deselect(t) : this.select(t) } clear() { this._unmarkAll(), this._emitChangeEvent() } isSelected(t) { return this._selection.has(t) } isEmpty() { return 0 === this._selection.size } hasValue() { return !this.isEmpty() } sort(t) { this._multiple && this.selected && this._selected.sort(t) } isMultipleSelection() { return this._multiple } _emitChangeEvent() { this._selected = null, (this._selectedToEmit.length || this._deselectedToEmit.length) && (this.changed.next({ source: this, added: this._selectedToEmit, removed: this._deselectedToEmit }), this._deselectedToEmit = [], this._selectedToEmit = []) } _markSelected(t) { this.isSelected(t) || (this._multiple || this._unmarkAll(), this._selection.add(t), this._emitChanges && this._selectedToEmit.push(t)) } _unmarkSelected(t) { this.isSelected(t) && (this._selection.delete(t), this._emitChanges && this._deselectedToEmit.push(t)) } _unmarkAll() { this.isEmpty() || this._selection.forEach(t => this._unmarkSelected(t)) } _verifyValueAssignment(t) { if (t.length > 1 && !this._multiple) throw Error("Cannot pass multiple values into SelectionModel with single-value mode.") } }
    let hD = (() => { class t { constructor() { this._listeners = [] } notify(t, e) { for (let i of this._listeners) i(t, e) } listen(t) { return this._listeners.push(t), () => { this._listeners = this._listeners.filter(e => t !== e) } } ngOnDestroy() { this._listeners = [] } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return new t }, token: t, providedIn: "root" }), t })(), dD = (() => { class t { constructor(t, e, i) { this._ngZone = t, this._platform = e, this._scrolled = new k, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = i } register(t) { this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t))) } deregister(t) { const e = this.scrollContainers.get(t);
                e && (e.unsubscribe(), this.scrollContainers.delete(t)) } scrolled(t = 20) { return this._platform.isBrowser ? new v(e => { this._globalSubscription || this._addGlobalListener(); const i = t > 0 ? this._scrolled.pipe(Hk(t)).subscribe(e) : this._scrolled.subscribe(e); return this._scrolledCount++, () => { i.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : Mu() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((t, e) => this.deregister(e)), this._scrolled.complete() } ancestorScrolled(t, e) { const i = this.getAncestorScrollContainers(t); return this.scrolled(e).pipe(Gu(t => !t || i.indexOf(t) > -1)) } getAncestorScrollContainers(t) { const e = []; return this.scrollContainers.forEach((i, n) => { this._scrollableContainsElement(n, t) && e.push(n) }), e } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _scrollableContainsElement(t, e) { let i = e.nativeElement,
                    n = t.getElementRef().nativeElement;
                do { if (i == n) return !0 } while (i = i.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => Nk(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Pc), Xt(Wv), Xt(uh, 8)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(Pc), Xt(Wv), Xt(uh, 8)) }, token: t, providedIn: "root" }), t })(), uD = (() => { class t { constructor(t, e, i, n) { this.elementRef = t, this.scrollDispatcher = e, this.ngZone = i, this.dir = n, this._destroyed = new k, this._elementScrolled = new v(t => this.ngZone.runOutsideAngular(() => Nk(this.elementRef.nativeElement, "scroll").pipe(jk(this._destroyed)).subscribe(t))) } ngOnInit() { this.scrollDispatcher.register(this) } ngOnDestroy() { this.scrollDispatcher.deregister(this), this._destroyed.next(), this._destroyed.complete() } elementScrolled() { return this._elementScrolled } getElementRef() { return this.elementRef } scrollTo(t) { const e = this.elementRef.nativeElement,
                    i = this.dir && "rtl" == this.dir.value;
                null == t.left && (t.left = i ? t.end : t.start), null == t.right && (t.right = i ? t.start : t.end), null != t.bottom && (t.top = e.scrollHeight - e.clientHeight - t.bottom), i && 0 != tw() ? (null != t.left && (t.right = e.scrollWidth - e.clientWidth - t.left), 2 == tw() ? t.left = t.right : 1 == tw() && (t.left = t.right ? -t.right : t.right)) : null != t.right && (t.left = e.scrollWidth - e.clientWidth - t.right), this._applyScrollToOptions(t) } _applyScrollToOptions(t) { const e = this.elementRef.nativeElement; "object" == typeof document && "scrollBehavior" in document.documentElement.style ? e.scrollTo(t) : (null != t.top && (e.scrollTop = t.top), null != t.left && (e.scrollLeft = t.left)) } measureScrollOffset(t) { const e = this.elementRef.nativeElement; if ("top" == t) return e.scrollTop; if ("bottom" == t) return e.scrollHeight - e.clientHeight - e.scrollTop; const i = this.dir && "rtl" == this.dir.value; return "start" == t ? t = i ? "right" : "left" : "end" == t && (t = i ? "left" : "right"), i && 2 == tw() ? "left" == t ? e.scrollWidth - e.clientWidth - e.scrollLeft : e.scrollLeft : i && 1 == tw() ? "left" == t ? e.scrollLeft + e.scrollWidth - e.clientWidth : -e.scrollLeft : "left" == t ? e.scrollLeft : e.scrollWidth - e.clientWidth - e.scrollLeft } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(dD), Sa(Pc), Sa(Rw, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdk-scrollable", ""],
                ["", "cdkScrollable", ""]
            ] }), t })(), mD = (() => { class t { constructor(t, e, i) { this._platform = t, this._document = i, e.runOutsideAngular(() => { const e = this._getWindow();
                    this._change = t.isBrowser ? q(Nk(e, "resize"), Nk(e, "orientationchange")) : Mu(), this._invalidateCache = this.change().subscribe(() => this._updateViewportSize()) }) } ngOnDestroy() { this._invalidateCache.unsubscribe() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const t = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), t } getViewportRect() { const t = this.getViewportScrollPosition(),
                    { width: e, height: i } = this.getViewportSize(); return { top: t.top, left: t.left, bottom: t.top + i, right: t.left + e, height: i, width: e } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const t = this._getDocument(),
                    e = this._getWindow(),
                    i = t.documentElement,
                    n = i.getBoundingClientRect(); return { top: -n.top || t.body.scrollTop || e.scrollY || i.scrollTop || 0, left: -n.left || t.body.scrollLeft || e.scrollX || i.scrollLeft || 0 } } change(t = 20) { return t > 0 ? this._change.pipe(Hk(t)) : this._change } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _updateViewportSize() { const t = this._getWindow();
                this._viewportSize = this._platform.isBrowser ? { width: t.innerWidth, height: t.innerHeight } : { width: 0, height: 0 } } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Wv), Xt(Pc), Xt(uh, 8)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(Wv), Xt(Pc), Xt(uh, 8)) }, token: t, providedIn: "root" }), t })(), pD = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [Pw, qv], Pw
            ] }), t })();

    function fD() { throw Error("Host already has a portal attached") } class gD { attach(t) { return null == t && function() { throw Error("Attempting to attach a portal to a null PortalOutlet") }(), t.hasAttached() && fD(), this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost;
            null == t ? function() { throw Error("Attempting to detach a portal that is not attached to a host") }() : (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class _D extends gD { constructor(t, e, i, n) { super(), this.component = t, this.viewContainerRef = e, this.injector = i, this.componentFactoryResolver = n } } class bD extends gD { constructor(t, e, i) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = i } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class yD extends gD { constructor(t) { super(), this.element = t instanceof Wo ? t.nativeElement : t } } class vD { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(t) { return t || function() { throw Error("Must provide a portal to attach") }(), this.hasAttached() && fD(), this._isDisposed && function() { throw Error("This PortalOutlet has already been disposed") }(), t instanceof _D ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof bD ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof yD ? (this._attachedPortal = t, this.attachDomPortal(t)) : void
            function() { throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.") }() } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class wD extends vD { constructor(t, e, i, n, s) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = i, this._defaultInjector = n, this.attachDomPortal = t => { if (!this._document) throw Error("Cannot attach DOM portal without _document constructor parameter"); const e = t.element; if (!e.parentNode) throw Error("DOM portal content must be attached to a parent node."); const i = this._document.createComment("dom-portal");
                e.parentNode.insertBefore(i, e), this.outletElement.appendChild(e), super.setDisposeFn(() => { i.parentNode && i.parentNode.replaceChild(e, i) }) }, this._document = s } attachComponentPortal(t) { const e = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let i; return t.viewContainerRef ? (i = t.viewContainerRef.createComponent(e, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => i.destroy())) : (i = e.create(t.injector || this._defaultInjector), this._appRef.attachView(i.hostView), this.setDisposeFn(() => { this._appRef.detachView(i.hostView), i.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(i)), i } attachTemplatePortal(t) { let e = t.viewContainerRef,
                i = e.createEmbeddedView(t.templateRef, t.context); return i.detectChanges(), i.rootNodes.forEach(t => this.outletElement.appendChild(t)), this.setDisposeFn(() => { let t = e.indexOf(i); - 1 !== t && e.remove(t) }), i } dispose() { super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement) } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } }
    let CD = (() => { class t extends bD { constructor(t, e) { super(t, e) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl), Sa(bl)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkPortal", ""]
            ], exportAs: ["cdkPortal"], features: [Eo] }), t })(), xD = (() => { class t extends vD { constructor(t, e, i) { super(), this._componentFactoryResolver = t, this._viewContainerRef = e, this._isInitialized = !1, this.attached = new jl, this.attachDomPortal = t => { if (!this._document) throw Error("Cannot attach DOM portal without _document constructor parameter"); const e = t.element; if (!e.parentNode) throw Error("DOM portal content must be attached to a parent node."); const i = this._document.createComment("dom-portal");
                    t.setAttachedHost(this), e.parentNode.insertBefore(i, e), this._getRootNode().appendChild(e), super.setDisposeFn(() => { i.parentNode && i.parentNode.replaceChild(e, i) }) }, this._document = i } get portal() { return this._attachedPortal } set portal(t) {
                (!this.hasAttached() || t || this._isInitialized) && (this.hasAttached() && super.detach(), t && super.attach(t), this._attachedPortal = t) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(t) { t.setAttachedHost(this); const e = null != t.viewContainerRef ? t.viewContainerRef : this._viewContainerRef,
                    i = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component),
                    n = e.createComponent(i, e.length, t.injector || e.injector); return e !== this._viewContainerRef && this._getRootNode().appendChild(n.hostView.rootNodes[0]), super.setDisposeFn(() => n.destroy()), this._attachedPortal = t, this._attachedRef = n, this.attached.emit(n), n } attachTemplatePortal(t) { t.setAttachedHost(this); const e = this._viewContainerRef.createEmbeddedView(t.templateRef, t.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = t, this._attachedRef = e, this.attached.emit(e), e } _getRootNode() { const t = this._viewContainerRef.element.nativeElement; return t.nodeType === t.ELEMENT_NODE ? t : t.parentNode } } return t.\u0275fac = function(e) { return new(e || t)(Sa($o), Sa(bl), Sa(uh)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkPortalOutlet", ""]
            ], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [Eo] }), t })(), SD = (() => { class t extends xD {} return t.\u0275fac = function(e) { return kD(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkPortalHost", ""],
                ["", "portalHost", ""]
            ], inputs: { portal: ["cdkPortalHost", "portal"] }, exportAs: ["cdkPortalHost"], features: [Ho([{ provide: xD, useExisting: t }]), Eo] }), t })();
    const kD = ln(SD);
    let ED = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })(); class DD { constructor(t, e) { this._parentInjector = t, this._customTokens = e } get(t, e) { const i = this._customTokens.get(t); return void 0 !== i ? i : this._parentInjector.get(t, e) } } class AD { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() {} enable() { if (this._canBeEnabled()) { const t = this._document.documentElement;
                this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = Hv(-this._previousScrollPosition.left), t.style.top = Hv(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement,
                    e = t.style,
                    i = this._document.body.style,
                    n = e.scrollBehavior || "",
                    s = i.scrollBehavior || "";
                this._isEnabled = !1, e.left = this._previousHTMLStyles.left, e.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), e.scrollBehavior = i.scrollBehavior = "auto", window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), e.scrollBehavior = n, i.scrollBehavior = s } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const t = this._document.body,
                e = this._viewportRuler.getViewportSize(); return t.scrollHeight > e.height || t.scrollWidth > e.width } }

    function ID() { return Error("Scroll strategy has already been attached.") } class TD { constructor(t, e, i, n) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = i, this._config = n, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { if (this._overlayRef) throw ID();
            this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0);
            this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const t = this._viewportRuler.getViewportScrollPosition().top;
                Math.abs(t - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class OD { enable() {} disable() {} attach() {} }

    function RD(t, e) { return e.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right) }

    function MD(t, e) { return e.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right) } class PD { constructor(t, e, i, n) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = i, this._config = n, this._scrollSubscription = null } attach(t) { if (this._overlayRef) throw ID();
            this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const t = this._overlayRef.overlayElement.getBoundingClientRect(),
                        { width: e, height: i } = this._viewportRuler.getViewportSize();
                    RD(t, [{ width: e, height: i, bottom: i, right: e, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } }
    let FD = (() => { class t { constructor(t, e, i, n) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = i, this.noop = () => new OD, this.close = t => new TD(this._scrollDispatcher, this._ngZone, this._viewportRuler, t), this.block = () => new AD(this._viewportRuler, this._document), this.reposition = t => new PD(this._scrollDispatcher, this._viewportRuler, this._ngZone, t), this._document = n } } return t.\u0275fac = function(e) { return new(e || t)(Xt(dD), Xt(mD), Xt(Pc), Xt(uh)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(dD), Xt(mD), Xt(Pc), Xt(uh)) }, token: t, providedIn: "root" }), t })(); class ND { constructor(t) { if (this.scrollStrategy = new OD, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const i of e) void 0 !== t[i] && (this[i] = t[i]) } } } class LD { constructor(t, e, i, n, s) { this.offsetX = i, this.offsetY = n, this.panelClass = s, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY } } class BD { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } }

    function VD(t, e) { if ("top" !== e && "bottom" !== e && "center" !== e) throw Error(`ConnectedPosition: Invalid ${t} "${e}". ` + 'Expected "top", "bottom" or "center".') }

    function zD(t, e) { if ("start" !== e && "end" !== e && "center" !== e) throw Error(`ConnectedPosition: Invalid ${t} "${e}". ` + 'Expected "start", "end" or "center".') }
    let UD = (() => { class t { constructor(t) { this._attachedOverlays = [], this._keydownListener = t => { const e = this._attachedOverlays; for (let i = e.length - 1; i > -1; i--)
                        if (e[i]._keydownEventSubscriptions > 0) { e[i]._keydownEvents.next(t); break } }, this._document = t } ngOnDestroy() { this._detach() } add(t) { this.remove(t), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0), this._attachedOverlays.push(t) } remove(t) { const e = this._attachedOverlays.indexOf(t);
                e > -1 && this._attachedOverlays.splice(e, 1), 0 === this._attachedOverlays.length && this._detach() } _detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(uh)) }, token: t, providedIn: "root" }), t })();
    const HD = !("undefined" == typeof window || !window || !window.__karma__ && !window.jasmine);
    let jD = (() => { class t { constructor(t, e) { this._platform = e, this._document = t } ngOnDestroy() { const t = this._containerElement;
                t && t.parentNode && t.parentNode.removeChild(t) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const t = this._platform ? this._platform.isBrowser : "undefined" != typeof window; if (t || HD) { const t = this._document.querySelectorAll('.cdk-overlay-container[platform="server"], .cdk-overlay-container[platform="test"]'); for (let e = 0; e < t.length; e++) t[e].parentNode.removeChild(t[e]) } const e = this._document.createElement("div");
                e.classList.add("cdk-overlay-container"), HD ? e.setAttribute("platform", "test") : t || e.setAttribute("platform", "server"), this._document.body.appendChild(e), this._containerElement = e } } return t.\u0275fac = function(e) { return new(e || t)(Xt(uh), Xt(Wv)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(uh), Xt(Wv)) }, token: t, providedIn: "root" }), t })(); class GD { constructor(t, e, i, n, s, r, a, o) { this._portalOutlet = t, this._host = e, this._pane = i, this._config = n, this._ngZone = s, this._keyboardDispatcher = r, this._document = a, this._location = o, this._backdropElement = null, this._backdropClick = new k, this._attachments = new k, this._detachments = new k, this._locationChanges = d.EMPTY, this._backdropClickHandler = t => this._backdropClick.next(t), this._keydownEventsObservable = new v(t => { const e = this._keydownEvents.subscribe(t); return this._keydownEventSubscriptions++, () => { e.unsubscribe(), this._keydownEventSubscriptions-- } }), this._keydownEvents = new k, this._keydownEventSubscriptions = 0, n.scrollStrategy && (this._scrollStrategy = n.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = n.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.asObservable().pipe(lm(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && this._location && (this._locationChanges = this._location.subscribe(() => this.dispose())), e } detach() { if (!this.hasAttached()) return;
            this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), t } dispose() { const t = this.hasAttached();
            this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick.asObservable() } attachments() { return this._attachments.asObservable() } detachments() { return this._detachments.asObservable() } keydownEvents() { return this._keydownEventsObservable } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign(Object.assign({}, this._config), t), this._updateElementSize() } setDirection(t) { this._config = Object.assign(Object.assign({}, this._config), { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style;
            t.width = Hv(this._config.width), t.height = Hv(this._config.height), t.minWidth = Hv(this._config.minWidth), t.minHeight = Hv(this._config.minHeight), t.maxWidth = Hv(this._config.maxWidth), t.maxHeight = Hv(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "auto" : "none" } _attachBackdrop() { this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add("cdk-overlay-backdrop-showing") }) }) : this._backdropElement.classList.add("cdk-overlay-backdrop-showing") } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { let t, e = this._backdropElement; if (!e) return; let i = () => { e && (e.removeEventListener("click", this._backdropClickHandler), e.removeEventListener("transitionend", i), e.parentNode && e.parentNode.removeChild(e)), this._backdropElement == e && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(e, this._config.backdropClass, !1), clearTimeout(t) };
            e.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { e.addEventListener("transitionend", i) }), e.style.pointerEvents = "none", t = this._ngZone.runOutsideAngular(() => setTimeout(i, 500)) } _toggleClasses(t, e, i) { const n = t.classList;
            Uv(e).forEach(t => { t && (i ? n.add(t) : n.remove(t)) }) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.asObservable().pipe(jk(q(this._attachments, this._detachments))).subscribe(() => { this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe()) }) }) } _disposeScrollStrategy() { const t = this._scrollStrategy;
            t && (t.disable(), t.detach && t.detach()) } }
    const $D = /([A-Za-z%]+)$/; class WD { constructor(t, e, i, n, s) { this._viewportRuler = e, this._document = i, this._platform = n, this._overlayContainer = s, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new k, this._resizeSubscription = d.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges.asObservable(), this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { if (this._overlayRef && t !== this._overlayRef) throw Error("This position strategy is already attached to an overlay");
            this._validatePositions(), t.hostElement.classList.add("cdk-overlay-connected-position-bounding-box"), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition();
            this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect,
                e = this._overlayRect,
                i = this._viewportRect,
                n = []; let s; for (let r of this._preferredPositions) { let a = this._getOriginPoint(t, r),
                    o = this._getOverlayPoint(a, e, r),
                    l = this._getOverlayFit(o, e, i, r); if (l.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(r, a);
                this._canFitWithFlexibleDimensions(l, o, i) ? n.push({ position: r, origin: a, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(a, r) }) : (!s || s.overlayFit.visibleArea < l.visibleArea) && (s = { overlayFit: l, overlayPoint: o, originPoint: a, position: r, overlayRect: e }) } if (n.length) { let t = null,
                    e = -1; for (const i of n) { const n = i.boundingBoxRect.width * i.boundingBoxRect.height * (i.position.weight || 1);
                    n > e && (e = n, t = i) } return this._isPushed = !1, void this._applyPosition(t.position, t.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(s.position, s.originPoint);
            this._applyPosition(s.position, s.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && qD(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove("cdk-overlay-connected-position-bounding-box"), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0],
                    e = this._getOriginPoint(this._originRect, t);
                this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let i, n; if ("center" == e.originX) i = t.left + t.width / 2;
            else { const n = this._isRtl() ? t.right : t.left,
                    s = this._isRtl() ? t.left : t.right;
                i = "start" == e.originX ? n : s } return n = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: i, y: n } } _getOverlayPoint(t, e, i) { let n, s; return n = "center" == i.overlayX ? -e.width / 2 : "start" === i.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, s = "center" == i.overlayY ? -e.height / 2 : "top" == i.overlayY ? 0 : -e.height, { x: t.x + n, y: t.y + s } } _getOverlayFit(t, e, i, n) { let { x: s, y: r } = t, a = this._getOffset(n, "x"), o = this._getOffset(n, "y");
            a && (s += a), o && (r += o); let l = 0 - r,
                c = r + e.height - i.height,
                h = this._subtractOverflows(e.width, 0 - s, s + e.width - i.width),
                d = this._subtractOverflows(e.height, l, c),
                u = h * d; return { visibleArea: u, isCompletelyWithinViewport: e.width * e.height === u, fitsInViewportVertically: d === e.height, fitsInViewportHorizontally: h == e.width } } _canFitWithFlexibleDimensions(t, e, i) { if (this._hasFlexibleDimensions) { const n = i.bottom - e.y,
                    s = i.right - e.x,
                    r = YD(this._overlayRef.getConfig().minHeight),
                    a = YD(this._overlayRef.getConfig().minWidth),
                    o = t.fitsInViewportHorizontally || null != a && a <= s; return (t.fitsInViewportVertically || null != r && r <= n) && o } return !1 } _pushOverlayOnScreen(t, e, i) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const n = this._viewportRect,
                s = Math.max(t.x + e.width - n.right, 0),
                r = Math.max(t.y + e.height - n.bottom, 0),
                a = Math.max(n.top - i.top - t.y, 0),
                o = Math.max(n.left - i.left - t.x, 0); let l = 0,
                c = 0; return l = e.width <= n.width ? o || -s : t.x < this._viewportMargin ? n.left - i.left - t.x : 0, c = e.height <= n.height ? a || -r : t.y < this._viewportMargin ? n.top - i.top - t.y : 0, this._previousPushAmount = { x: l, y: c }, { x: t.x + l, y: t.y + c } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const e = this._getScrollVisibility(),
                    i = new BD(t, e);
                this._positionChanges.next(i) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let i, n = t.overlayY;
            i = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let s = 0; s < e.length; s++) e[s].style.transformOrigin = `${i} ${n}` } _calculateBoundingBoxRect(t, e) { const i = this._viewportRect,
                n = this._isRtl(); let s, r, a, o, l, c; if ("top" === e.overlayY) r = t.y, s = i.height - r + this._viewportMargin;
            else if ("bottom" === e.overlayY) a = i.height - t.y + 2 * this._viewportMargin, s = i.height - a + this._viewportMargin;
            else { const e = Math.min(i.bottom - t.y + i.top, t.y),
                    n = this._lastBoundingBoxSize.height;
                s = 2 * e, r = t.y - e, s > n && !this._isInitialRender && !this._growAfterOpen && (r = t.y - n / 2) } if ("end" === e.overlayX && !n || "start" === e.overlayX && n) c = i.width - t.x + this._viewportMargin, o = t.x - this._viewportMargin;
            else if ("start" === e.overlayX && !n || "end" === e.overlayX && n) l = t.x, o = i.right - t.x;
            else { const e = Math.min(i.right - t.x + i.left, t.x),
                    n = this._lastBoundingBoxSize.width;
                o = 2 * e, l = t.x - e, o > n && !this._isInitialRender && !this._growAfterOpen && (l = t.x - n / 2) } return { top: r, left: l, bottom: a, right: c, width: o, height: s } } _setBoundingBoxStyles(t, e) { const i = this._calculateBoundingBoxRect(t, e);
            this._isInitialRender || this._growAfterOpen || (i.height = Math.min(i.height, this._lastBoundingBoxSize.height), i.width = Math.min(i.width, this._lastBoundingBoxSize.width)); const n = {}; if (this._hasExactPosition()) n.top = n.left = "0", n.bottom = n.right = n.maxHeight = n.maxWidth = "", n.width = n.height = "100%";
            else { const t = this._overlayRef.getConfig().maxHeight,
                    s = this._overlayRef.getConfig().maxWidth;
                n.height = Hv(i.height), n.top = Hv(i.top), n.bottom = Hv(i.bottom), n.width = Hv(i.width), n.left = Hv(i.left), n.right = Hv(i.right), n.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", n.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", t && (n.maxHeight = Hv(t)), s && (n.maxWidth = Hv(s)) } this._lastBoundingBoxSize = i, qD(this._boundingBox.style, n) } _resetBoundingBoxStyles() { qD(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { qD(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const i = {},
                n = this._hasExactPosition(),
                s = this._hasFlexibleDimensions,
                r = this._overlayRef.getConfig(); if (n) { const n = this._viewportRuler.getViewportScrollPosition();
                qD(i, this._getExactOverlayY(e, t, n)), qD(i, this._getExactOverlayX(e, t, n)) } else i.position = "static"; let a = "",
                o = this._getOffset(e, "x"),
                l = this._getOffset(e, "y");
            o && (a += `translateX(${o}px) `), l && (a += `translateY(${l}px)`), i.transform = a.trim(), r.maxHeight && (n ? i.maxHeight = Hv(r.maxHeight) : s && (i.maxHeight = "")), r.maxWidth && (n ? i.maxWidth = Hv(r.maxWidth) : s && (i.maxWidth = "")), qD(this._pane.style, i) } _getExactOverlayY(t, e, i) { let n = { top: "", bottom: "" },
                s = this._getOverlayPoint(e, this._overlayRect, t);
            this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, i)); let r = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return s.y -= r, "bottom" === t.overlayY ? n.bottom = `${this._document.documentElement.clientHeight-(s.y+this._overlayRect.height)}px` : n.top = Hv(s.y), n } _getExactOverlayX(t, e, i) { let n, s = { left: "", right: "" },
                r = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (r = this._pushOverlayOnScreen(r, this._overlayRect, i)), n = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === n ? s.right = `${this._document.documentElement.clientWidth-(r.x+this._overlayRect.width)}px` : s.left = Hv(r.x), s } _getScrollVisibility() { const t = this._getOriginRect(),
                e = this._pane.getBoundingClientRect(),
                i = this._scrollables.map(t => t.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: MD(t, i), isOriginOutsideView: RD(t, i), isOverlayClipped: MD(e, i), isOverlayOutsideView: RD(e, i) } } _subtractOverflows(t, ...e) { return e.reduce((t, e) => t - Math.max(e, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth,
                e = this._document.documentElement.clientHeight,
                i = this._viewportRuler.getViewportScrollPosition(); return { top: i.top + this._viewportMargin, left: i.left + this._viewportMargin, right: i.left + t - this._viewportMargin, bottom: i.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { if (!this._preferredPositions.length) throw Error("FlexibleConnectedPositionStrategy: At least one position is required.");
            this._preferredPositions.forEach(t => { zD("originX", t.originX), VD("originY", t.originY), zD("overlayX", t.overlayX), VD("overlayY", t.overlayY) }) } _addPanelClasses(t) { this._pane && Uv(t).forEach(t => { "" !== t && -1 === this._appliedPanelClasses.indexOf(t) && (this._appliedPanelClasses.push(t), this._pane.classList.add(t)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof Wo) return t.nativeElement.getBoundingClientRect(); if (t instanceof Element) return t.getBoundingClientRect(); const e = t.width || 0,
                i = t.height || 0; return { top: t.y, bottom: t.y + i, left: t.x, right: t.x + e, height: i, width: e } } }

    function qD(t, e) { for (let i in e) e.hasOwnProperty(i) && (t[i] = e[i]); return t }

    function YD(t) { if ("number" != typeof t && null != t) { const [e, i] = t.split($D); return i && "px" !== i ? null : parseFloat(e) } return t || null } class XD { constructor(t, e, i, n, s, r, a) { this._preferredPositions = [], this._positionStrategy = new WD(i, n, s, r, a).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e) } get _isRtl() { return "rtl" === this._overlayRef.getDirection() } get onPositionChange() { return this._positionStrategy.positionChanges } get positions() { return this._preferredPositions } attach(t) { this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null) } dispose() { this._positionStrategy.dispose() } detach() { this._positionStrategy.detach() } apply() { this._positionStrategy.apply() } recalculateLastPosition() { this._positionStrategy.reapplyLastPosition() } withScrollableContainers(t) { this._positionStrategy.withScrollableContainers(t) } withFallbackPosition(t, e, i, n) { const s = new LD(t, e, i, n); return this._preferredPositions.push(s), this._positionStrategy.withPositions(this._preferredPositions), this } withDirection(t) { return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this } withOffsetX(t) { return this._positionStrategy.withDefaultOffsetX(t), this } withOffsetY(t) { return this._positionStrategy.withDefaultOffsetY(t), this } withLockedPosition(t) { return this._positionStrategy.withLockedPosition(t), this } withPositions(t) { return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this } setOrigin(t) { return this._positionStrategy.setOrigin(t), this } } class KD { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig();
            this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add("cdk-global-overlay-wrapper"), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style,
                e = this._overlayRef.hostElement.style,
                i = this._overlayRef.getConfig(),
                { width: n, height: s, maxWidth: r, maxHeight: a } = i,
                o = !("100%" !== n && "100vw" !== n || r && "100%" !== r && "100vw" !== r),
                l = !("100%" !== s && "100vh" !== s || a && "100%" !== a && "100vh" !== a);
            t.position = this._cssPosition, t.marginLeft = o ? "0" : this._leftOffset, t.marginTop = l ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, o ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = l ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style,
                e = this._overlayRef.hostElement,
                i = e.style;
            e.classList.remove("cdk-global-overlay-wrapper"), i.justifyContent = i.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } }
    let ZD = (() => { class t { constructor(t, e, i, n) { this._viewportRuler = t, this._document = e, this._platform = i, this._overlayContainer = n } global() { return new KD } connectedTo(t, e, i) { return new XD(e, i, t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } flexibleConnectedTo(t) { return new WD(t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(mD), Xt(uh), Xt(Wv), Xt(jD)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(mD), Xt(uh), Xt(Wv), Xt(jD)) }, token: t, providedIn: "root" }), t })(), QD = 0, JD = (() => { class t { constructor(t, e, i, n, s, r, a, o, l, c) { this.scrollStrategies = t, this._overlayContainer = e, this._componentFactoryResolver = i, this._positionBuilder = n, this._keyboardDispatcher = s, this._injector = r, this._ngZone = a, this._document = o, this._directionality = l, this._location = c } create(t) { const e = this._createHostElement(),
                    i = this._createPaneElement(e),
                    n = this._createPortalOutlet(i),
                    s = new ND(t); return s.direction = s.direction || this._directionality.value, new GD(n, e, i, s, this._ngZone, this._keyboardDispatcher, this._document, this._location) } position() { return this._positionBuilder } _createPaneElement(t) { const e = this._document.createElement("div"); return e.id = `cdk-overlay-${QD++}`, e.classList.add("cdk-overlay-pane"), t.appendChild(e), e } _createHostElement() { const t = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(t), t } _createPortalOutlet(t) { return this._appRef || (this._appRef = this._injector.get(th)), new wD(t, this._componentFactoryResolver, this._appRef, this._injector, this._document) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(FD), Xt(jD), Xt($o), Xt(ZD), Xt(UD), Xt(ra), Xt(Pc), Xt(uh), Xt(Rw), Xt(Dh, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })();
    const tA = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom" }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom" }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }], eA = new Vt("cdk-connected-overlay-scroll-strategy");
    let iA = (() => { class t { constructor(t) { this.elementRef = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdk-overlay-origin", ""],
                ["", "overlay-origin", ""],
                ["", "cdkOverlayOrigin", ""]
            ], exportAs: ["cdkOverlayOrigin"] }), t })(), nA = (() => { class t { constructor(t, e, i, n, s) { this._overlay = t, this._dir = s, this._hasBackdrop = !1, this._lockPosition = !1, this._growAfterOpen = !1, this._flexibleDimensions = !1, this._push = !1, this._backdropSubscription = d.EMPTY, this.viewportMargin = 0, this.open = !1, this.backdropClick = new jl, this.positionChange = new jl, this.attach = new jl, this.detach = new jl, this.overlayKeydown = new jl, this._templatePortal = new bD(e, i), this._scrollStrategyFactory = n, this.scrollStrategy = this._scrollStrategyFactory() } get offsetX() { return this._offsetX } set offsetX(t) { this._offsetX = t, this._position && this._updatePositionStrategy(this._position) } get offsetY() { return this._offsetY } set offsetY(t) { this._offsetY = t, this._position && this._updatePositionStrategy(this._position) } get hasBackdrop() { return this._hasBackdrop } set hasBackdrop(t) { this._hasBackdrop = Vv(t) } get lockPosition() { return this._lockPosition } set lockPosition(t) { this._lockPosition = Vv(t) } get flexibleDimensions() { return this._flexibleDimensions } set flexibleDimensions(t) { this._flexibleDimensions = Vv(t) } get growAfterOpen() { return this._growAfterOpen } set growAfterOpen(t) { this._growAfterOpen = Vv(t) } get push() { return this._push } set push(t) { this._push = Vv(t) } get overlayRef() { return this._overlayRef } get dir() { return this._dir ? this._dir.value : "ltr" } ngOnDestroy() { this._overlayRef && this._overlayRef.dispose(), this._backdropSubscription.unsubscribe() } ngOnChanges(t) { this._position && (this._updatePositionStrategy(this._position), this._overlayRef.updateSize({ width: this.width, minWidth: this.minWidth, height: this.height, minHeight: this.minHeight }), t.origin && this.open && this._position.apply()), t.open && (this.open ? this._attachOverlay() : this._detachOverlay()) } _createOverlay() { this.positions && this.positions.length || (this.positions = tA), this._overlayRef = this._overlay.create(this._buildConfig()), this._overlayRef.keydownEvents().subscribe(t => { this.overlayKeydown.next(t), 27 !== t.keyCode || Iv(t) || (t.preventDefault(), this._detachOverlay()) }) } _buildConfig() { const t = this._position = this.positionStrategy || this._createPositionStrategy(),
                    e = new ND({ direction: this._dir, positionStrategy: t, scrollStrategy: this.scrollStrategy, hasBackdrop: this.hasBackdrop }); return (this.width || 0 === this.width) && (e.width = this.width), (this.height || 0 === this.height) && (e.height = this.height), (this.minWidth || 0 === this.minWidth) && (e.minWidth = this.minWidth), (this.minHeight || 0 === this.minHeight) && (e.minHeight = this.minHeight), this.backdropClass && (e.backdropClass = this.backdropClass), this.panelClass && (e.panelClass = this.panelClass), e } _updatePositionStrategy(t) { const e = this.positions.map(t => ({ originX: t.originX, originY: t.originY, overlayX: t.overlayX, overlayY: t.overlayY, offsetX: t.offsetX || this.offsetX, offsetY: t.offsetY || this.offsetY, panelClass: t.panelClass || void 0 })); return t.setOrigin(this.origin.elementRef).withPositions(e).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector) } _createPositionStrategy() { const t = this._overlay.position().flexibleConnectedTo(this.origin.elementRef); return this._updatePositionStrategy(t), t.positionChanges.subscribe(t => this.positionChange.emit(t)), t } _attachOverlay() { this._overlayRef ? this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop : this._createOverlay(), this._overlayRef.hasAttached() || (this._overlayRef.attach(this._templatePortal), this.attach.emit()), this.hasBackdrop ? this._backdropSubscription = this._overlayRef.backdropClick().subscribe(t => { this.backdropClick.emit(t) }) : this._backdropSubscription.unsubscribe() } _detachOverlay() { this._overlayRef && (this._overlayRef.detach(), this.detach.emit()), this._backdropSubscription.unsubscribe() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(JD), Sa(gl), Sa(bl), Sa(eA), Sa(Rw, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdk-connected-overlay", ""],
                ["", "connected-overlay", ""],
                ["", "cdkConnectedOverlay", ""]
            ], inputs: { viewportMargin: ["cdkConnectedOverlayViewportMargin", "viewportMargin"], open: ["cdkConnectedOverlayOpen", "open"], scrollStrategy: ["cdkConnectedOverlayScrollStrategy", "scrollStrategy"], offsetX: ["cdkConnectedOverlayOffsetX", "offsetX"], offsetY: ["cdkConnectedOverlayOffsetY", "offsetY"], hasBackdrop: ["cdkConnectedOverlayHasBackdrop", "hasBackdrop"], lockPosition: ["cdkConnectedOverlayLockPosition", "lockPosition"], flexibleDimensions: ["cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions"], growAfterOpen: ["cdkConnectedOverlayGrowAfterOpen", "growAfterOpen"], push: ["cdkConnectedOverlayPush", "push"], positions: ["cdkConnectedOverlayPositions", "positions"], origin: ["cdkConnectedOverlayOrigin", "origin"], positionStrategy: ["cdkConnectedOverlayPositionStrategy", "positionStrategy"], width: ["cdkConnectedOverlayWidth", "width"], height: ["cdkConnectedOverlayHeight", "height"], minWidth: ["cdkConnectedOverlayMinWidth", "minWidth"], minHeight: ["cdkConnectedOverlayMinHeight", "minHeight"], backdropClass: ["cdkConnectedOverlayBackdropClass", "backdropClass"], panelClass: ["cdkConnectedOverlayPanelClass", "panelClass"], transformOriginSelector: ["cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"] }, outputs: { backdropClick: "backdropClick", positionChange: "positionChange", attach: "attach", detach: "detach", overlayKeydown: "overlayKeydown" }, exportAs: ["cdkConnectedOverlay"], features: [Ro] }), t })();
    const sA = { provide: eA, deps: [JD], useFactory: function(t) { return () => t.scrollStrategies.reposition() } };
    let rA = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [JD, sA], imports: [
                [Pw, ED, pD], pD
            ] }), t })();

    function aA(t) { return t instanceof Date && !isNaN(+t) }

    function oA(t, e = Pv) { const i = aA(t) ? +t - e.now() : Math.abs(t); return t => t.lift(new lA(i, e)) } class lA { constructor(t, e) { this.delay = t, this.scheduler = e } call(t, e) { return e.subscribe(new cA(t, this.delay, this.scheduler)) } } class cA extends p { constructor(t, e, i) { super(t), this.delay = e, this.scheduler = i, this.queue = [], this.active = !1, this.errored = !1 } static dispatch(t) { const e = t.source,
                i = e.queue,
                n = t.scheduler,
                s = t.destination; for (; i.length > 0 && i[0].time - n.now() <= 0;) i.shift().notification.observe(s); if (i.length > 0) { const e = Math.max(0, i[0].time - n.now());
                this.schedule(t, e) } else this.unsubscribe(), e.active = !1 } _schedule(t) { this.active = !0, this.destination.add(t.schedule(cA.dispatch, this.delay, { source: this, destination: this.destination, scheduler: t })) } scheduleNotification(t) { if (!0 === this.errored) return; const e = this.scheduler,
                i = new hA(e.now() + this.delay, t);
            this.queue.push(i), !1 === this.active && this._schedule(e) } _next(t) { this.scheduleNotification(nD.createNext(t)) } _error(t) { this.errored = !0, this.queue = [], this.destination.error(t), this.unsubscribe() } _complete() { this.scheduleNotification(nD.createComplete()), this.unsubscribe() } } class hA { constructor(t, e) { this.time = t, this.notification = e } }
    const dA = ["panel"];

    function uA(t, e) { if (1 & t && (Ia(0, "div", 0, 1), Wa(2), Ta()), 2 & t) { const t = ja();
            Da("id", t.id)("ngClass", t._classList) } }
    const mA = ["*"];
    let pA = 0; class fA { constructor(t, e) { this.source = t, this.option = e } } class gA {}
    const _A = vS(gA), bA = new Vt("mat-autocomplete-default-options", { providedIn: "root", factory: function() { return { autoActiveFirstOption: !1 } } });
    let yA = (() => { class t extends _A { constructor(t, e, i) { super(), this._changeDetectorRef = t, this._elementRef = e, this._activeOptionChanges = d.EMPTY, this.showPanel = !1, this._isOpen = !1, this.displayWith = null, this.optionSelected = new jl, this.opened = new jl, this.closed = new jl, this.optionActivated = new jl, this._classList = {}, this.id = `mat-autocomplete-${pA++}`, this._autoActiveFirstOption = !!i.autoActiveFirstOption } get isOpen() { return this._isOpen && this.showPanel } get autoActiveFirstOption() { return this._autoActiveFirstOption } set autoActiveFirstOption(t) { this._autoActiveFirstOption = Vv(t) } set classList(t) { this._classList = t && t.length ? t.split(" ").reduce((t, e) => (t[e.trim()] = !0, t), {}) : {}, this._setVisibilityClasses(this._classList), this._elementRef.nativeElement.className = "" } ngAfterContentInit() { this._keyManager = new uw(this.options).withWrap(), this._activeOptionChanges = this._keyManager.change.subscribe(t => { this.optionActivated.emit({ source: this, option: this.options.toArray()[t] || null }) }), this._setVisibility() } ngOnDestroy() { this._activeOptionChanges.unsubscribe() } _setScrollTop(t) { this.panel && (this.panel.nativeElement.scrollTop = t) } _getScrollTop() { return this.panel ? this.panel.nativeElement.scrollTop : 0 } _setVisibility() { this.showPanel = !!this.options.length, this._setVisibilityClasses(this._classList), this._changeDetectorRef.markForCheck() } _emitSelectEvent(t) { const e = new fA(this, t);
                this.optionSelected.emit(e) } _setVisibilityClasses(t) { t["mat-autocomplete-visible"] = this.showPanel, t["mat-autocomplete-hidden"] = !this.showPanel } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jr), Sa(Wo), Sa(bA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-autocomplete"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, rk, !0), sc(i, tk, !0)), 2 & t && (tc(n = oc()) && (e.options = n), tc(n = oc()) && (e.optionGroups = n)) }, viewQuery: function(t, e) { var i;
                1 & t && (ec(gl, !0), ic(dA, !0)), 2 & t && (tc(i = oc()) && (e.template = i.first), tc(i = oc()) && (e.panel = i.first)) }, hostAttrs: [1, "mat-autocomplete"], inputs: { disableRipple: "disableRipple", displayWith: "displayWith", autoActiveFirstOption: "autoActiveFirstOption", classList: ["class", "classList"], panelWidth: "panelWidth" }, outputs: { optionSelected: "optionSelected", opened: "opened", closed: "closed", optionActivated: "optionActivated" }, exportAs: ["matAutocomplete"], features: [Ho([{ provide: sk, useExisting: t }]), Eo], ngContentSelectors: mA, decls: 1, vars: 0, consts: [
                ["role", "listbox", 1, "mat-autocomplete-panel", 3, "id", "ngClass"],
                ["panel", ""]
            ], template: function(t, e) { 1 & t && ($a(), Ca(0, uA, 3, 2, "ng-template")) }, directives: [pd], styles: [".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), vA = (() => { class t { constructor(t) { this.elementRef = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matAutocompleteOrigin", ""]
            ], exportAs: ["matAutocompleteOrigin"] }), t })();
    const wA = new Vt("mat-autocomplete-scroll-strategy"), CA = { provide: wA, deps: [JD], useFactory: function(t) { return () => t.scrollStrategies.reposition() } }, xA = { provide: vg, useExisting: St(() => SA), multi: !0 };
    let SA = (() => { class t { constructor(t, e, i, n, s, r, a, o, l, c) { this._element = t, this._overlay = e, this._viewContainerRef = i, this._zone = n, this._changeDetectorRef = s, this._dir = a, this._formField = o, this._document = l, this._viewportRuler = c, this._componentDestroyed = !1, this._autocompleteDisabled = !1, this._manuallyFloatingLabel = !1, this._viewportSubscription = d.EMPTY, this._canOpenOnNextFocus = !0, this._closeKeyEventStream = new k, this._windowBlurHandler = () => { this._canOpenOnNextFocus = this._document.activeElement !== this._element.nativeElement || this.panelOpen }, this._onChange = () => {}, this._onTouched = () => {}, this.position = "auto", this.autocompleteAttribute = "off", this._overlayAttached = !1, this.optionSelections = Hu(() => this.autocomplete && this.autocomplete.options ? q(...this.autocomplete.options.map(t => t.onSelectionChange)) : this._zone.onStable.asObservable().pipe(lm(1), pm(() => this.optionSelections))), this._scrollStrategy = r } get autocompleteDisabled() { return this._autocompleteDisabled } set autocompleteDisabled(t) { this._autocompleteDisabled = Vv(t) } ngAfterViewInit() { const t = this._getWindow();
                void 0 !== t && (this._zone.runOutsideAngular(() => { t.addEventListener("blur", this._windowBlurHandler) }), this._isInsideShadowRoot = !!ew(this._element.nativeElement)) } ngOnChanges(t) { t.position && this._positionStrategy && (this._setStrategyPositions(this._positionStrategy), this.panelOpen && this._overlayRef.updatePosition()) } ngOnDestroy() { const t = this._getWindow();
                void 0 !== t && t.removeEventListener("blur", this._windowBlurHandler), this._viewportSubscription.unsubscribe(), this._componentDestroyed = !0, this._destroyPanel(), this._closeKeyEventStream.complete() } get panelOpen() { return this._overlayAttached && this.autocomplete.showPanel } openPanel() { this._attachOverlay(), this._floatLabel() } closePanel() { this._resetLabel(), this._overlayAttached && (this.panelOpen && this.autocomplete.closed.emit(), this.autocomplete._isOpen = this._overlayAttached = !1, this._overlayRef && this._overlayRef.hasAttached() && (this._overlayRef.detach(), this._closingActionsSubscription.unsubscribe()), this._componentDestroyed || this._changeDetectorRef.detectChanges()) } updatePosition() { this._overlayAttached && this._overlayRef.updatePosition() } get panelClosingActions() { return q(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(Gu(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ? this._overlayRef.detachments().pipe(Gu(() => this._overlayAttached)) : Mu()).pipe(L(t => t instanceof nk ? t : null)) } get activeOption() { return this.autocomplete && this.autocomplete._keyManager ? this.autocomplete._keyManager.activeItem : null } _getOutsideClickStream() { return q(Nk(this._document, "click"), Nk(this._document, "touchend")).pipe(Gu(t => { const e = this._isInsideShadowRoot && t.composedPath ? t.composedPath()[0] : t.target,
                        i = this._formField ? this._formField._elementRef.nativeElement : null; return this._overlayAttached && e !== this._element.nativeElement && (!i || !i.contains(e)) && !!this._overlayRef && !this._overlayRef.overlayElement.contains(e) })) } writeValue(t) { Promise.resolve(null).then(() => this._setTriggerValue(t)) } registerOnChange(t) { this._onChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this._element.nativeElement.disabled = t } _handleKeydown(t) { const e = t.keyCode; if (27 === e && t.preventDefault(), this.activeOption && 13 === e && this.panelOpen) this.activeOption._selectViaInteraction(), this._resetActiveItem(), t.preventDefault();
                else if (this.autocomplete) { const i = this.autocomplete._keyManager.activeItem,
                        n = 38 === e || 40 === e;
                    this.panelOpen || 9 === e ? this.autocomplete._keyManager.onKeydown(t) : n && this._canOpen() && this.openPanel(), (n || this.autocomplete._keyManager.activeItem !== i) && this._scrollToOption() } } _handleInput(t) { let e = t.target,
                    i = e.value; "number" === e.type && (i = "" == i ? null : parseFloat(i)), this._previousValue !== i && (this._previousValue = i, this._onChange(i), this._canOpen() && this._document.activeElement === t.target && this.openPanel()) } _handleFocus() { this._canOpenOnNextFocus ? this._canOpen() && (this._previousValue = this._element.nativeElement.value, this._attachOverlay(), this._floatLabel(!0)) : this._canOpenOnNextFocus = !0 } _floatLabel(t = !1) { this._formField && "auto" === this._formField.floatLabel && (t ? this._formField._animateAndLockLabel() : this._formField.floatLabel = "always", this._manuallyFloatingLabel = !0) } _resetLabel() { this._manuallyFloatingLabel && (this._formField.floatLabel = "auto", this._manuallyFloatingLabel = !1) } _scrollToOption() { const t = this.autocomplete._keyManager.activeItemIndex || 0,
                    e = ak(t, this.autocomplete.options, this.autocomplete.optionGroups); if (0 === t && 1 === e) this.autocomplete._setScrollTop(0);
                else { const i = ok(t + e, 48, this.autocomplete._getScrollTop(), 256);
                    this.autocomplete._setScrollTop(i) } } _subscribeToClosingActions() { return q(this._zone.onStable.asObservable().pipe(lm(1)), this.autocomplete.options.changes.pipe(Sm(() => this._positionStrategy.reapplyLastPosition()), oA(0))).pipe(pm(() => { const t = this.panelOpen; return this._resetActiveItem(), this.autocomplete._setVisibility(), this.panelOpen && (this._overlayRef.updatePosition(), t !== this.panelOpen && this.autocomplete.opened.emit()), this.panelClosingActions }), lm(1)).subscribe(t => this._setValueAndClose(t)) } _destroyPanel() { this._overlayRef && (this.closePanel(), this._overlayRef.dispose(), this._overlayRef = null) } _setTriggerValue(t) { const e = this.autocomplete && this.autocomplete.displayWith ? this.autocomplete.displayWith(t) : t,
                    i = null != e ? e : "";
                this._formField ? this._formField._control.value = i : this._element.nativeElement.value = i, this._previousValue = i } _setValueAndClose(t) { t && t.source && (this._clearPreviousSelectedOption(t.source), this._setTriggerValue(t.source.value), this._onChange(t.source.value), this._element.nativeElement.focus(), this.autocomplete._emitSelectEvent(t.source)), this.closePanel() } _clearPreviousSelectedOption(t) { this.autocomplete.options.forEach(e => { e != t && e.selected && e.deselect() }) } _attachOverlay() { if (!this.autocomplete) throw Error("Attempting to open an undefined instance of `mat-autocomplete`. Make sure that the id passed to the `matAutocomplete` is correct and that you're attempting to open it after the ngAfterContentInit hook."); let t = this._overlayRef;
                t ? (this._positionStrategy.setOrigin(this._getConnectedElement()), t.updateSize({ width: this._getPanelWidth() })) : (this._portal = new bD(this.autocomplete.template, this._viewContainerRef), t = this._overlay.create(this._getOverlayConfig()), this._overlayRef = t, t.keydownEvents().subscribe(t => {
                    (27 === t.keyCode || 38 === t.keyCode && t.altKey) && (this._resetActiveItem(), this._closeKeyEventStream.next(), t.stopPropagation(), t.preventDefault()) }), this._viewportRuler && (this._viewportSubscription = this._viewportRuler.change().subscribe(() => { this.panelOpen && t && t.updateSize({ width: this._getPanelWidth() }) }))), t && !t.hasAttached() && (t.attach(this._portal), this._closingActionsSubscription = this._subscribeToClosingActions()); const e = this.panelOpen;
                this.autocomplete._setVisibility(), this.autocomplete._isOpen = this._overlayAttached = !0, this.panelOpen && e !== this.panelOpen && this.autocomplete.opened.emit() } _getOverlayConfig() { return new ND({ positionStrategy: this._getOverlayPosition(), scrollStrategy: this._scrollStrategy(), width: this._getPanelWidth(), direction: this._dir }) } _getOverlayPosition() { const t = this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withFlexibleDimensions(!1).withPush(!1); return this._setStrategyPositions(t), this._positionStrategy = t, t } _setStrategyPositions(t) { const e = { originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" },
                    i = { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom", panelClass: "mat-autocomplete-panel-above" }; let n;
                n = "above" === this.position ? [i] : "below" === this.position ? [e] : [e, i], t.withPositions(n) } _getConnectedElement() { return this.connectedTo ? this.connectedTo.elementRef : this._formField ? this._formField.getConnectedOverlayOrigin() : this._element } _getPanelWidth() { return this.autocomplete.panelWidth || this._getHostWidth() } _getHostWidth() { return this._getConnectedElement().nativeElement.getBoundingClientRect().width } _resetActiveItem() { this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1) } _canOpen() { const t = this._element.nativeElement; return !t.readOnly && !t.disabled && !this._autocompleteDisabled } _getWindow() { var t; return (null === (t = this._document) || void 0 === t ? void 0 : t.defaultView) || window } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(JD), Sa(bl), Sa(Pc), Sa(jr), Sa(wA), Sa(Rw, 8), Sa(IE, 9), Sa(uh, 8), Sa(mD)) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "matAutocomplete", ""],
                ["textarea", "matAutocomplete", ""]
            ], hostAttrs: [1, "mat-autocomplete-trigger"], hostVars: 7, hostBindings: function(t, e) { 1 & t && Ba("focusin", (function() { return e._handleFocus() }))("blur", (function() { return e._onTouched() }))("input", (function(t) { return e._handleInput(t) }))("keydown", (function(t) { return e._handleKeydown(t) })), 2 & t && va("autocomplete", e.autocompleteAttribute)("role", e.autocompleteDisabled ? null : "combobox")("aria-autocomplete", e.autocompleteDisabled ? null : "list")("aria-activedescendant", e.panelOpen && e.activeOption ? e.activeOption.id : null)("aria-expanded", e.autocompleteDisabled ? null : e.panelOpen.toString())("aria-owns", e.autocompleteDisabled || !e.panelOpen || null == e.autocomplete ? null : e.autocomplete.id)("aria-haspopup", !e.autocompleteDisabled) }, inputs: { position: ["matAutocompletePosition", "position"], autocompleteAttribute: ["autocomplete", "autocompleteAttribute"], autocompleteDisabled: ["matAutocompleteDisabled", "autocompleteDisabled"], autocomplete: ["matAutocomplete", "autocomplete"], connectedTo: ["matAutocompleteConnectedTo", "connectedTo"] }, exportAs: ["matAutocompleteTrigger"], features: [Ho([xA]), Ro] }), t })(), kA = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [CA], imports: [
                [lk, rA, _S, Jd], lk, _S
            ] }), t })();

    function EA(t, e) {} class DA { constructor() { this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.maxWidth = "80vw", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.autoFocus = !0, this.restoreFocus = !0, this.closeOnNavigation = !0 } }
    const AA = { dialogContainer: Lw("dialogContainer", [Hw("void, exit", Uw({ opacity: 0, transform: "scale(0.7)" })), Hw("enter", Uw({ transform: "none" })), Gw("* => enter", Bw("150ms cubic-bezier(0, 0, 0.2, 1)", Uw({ transform: "none", opacity: 1 }))), Gw("* => void, * => exit", Bw("75ms cubic-bezier(0.4, 0.0, 0.2, 1)", Uw({ opacity: 0 })))]) };

    function IA() { throw Error("Attempting to attach dialog content after content is already attached") }
    let TA = (() => { class t extends vD { constructor(t, e, i, n, s) { super(), this._elementRef = t, this._focusTrapFactory = e, this._changeDetectorRef = i, this._config = s, this._elementFocusedBeforeDialogWasOpened = null, this._state = "enter", this._animationStateChanged = new jl, this.attachDomPortal = t => (this._portalOutlet.hasAttached() && IA(), this._savePreviouslyFocusedElement(), this._portalOutlet.attachDomPortal(t)), this._ariaLabelledBy = s.ariaLabelledBy || null, this._document = n } attachComponentPortal(t) { return this._portalOutlet.hasAttached() && IA(), this._savePreviouslyFocusedElement(), this._portalOutlet.attachComponentPortal(t) } attachTemplatePortal(t) { return this._portalOutlet.hasAttached() && IA(), this._savePreviouslyFocusedElement(), this._portalOutlet.attachTemplatePortal(t) } _trapFocus() { const t = this._elementRef.nativeElement; if (this._focusTrap || (this._focusTrap = this._focusTrapFactory.create(t)), this._config.autoFocus) this._focusTrap.focusInitialElementWhenReady();
                else { const e = this._document.activeElement;
                    e === t || t.contains(e) || t.focus() } } _restoreFocus() { const t = this._elementFocusedBeforeDialogWasOpened; if (this._config.restoreFocus && t && "function" == typeof t.focus) { const e = this._document.activeElement,
                        i = this._elementRef.nativeElement;
                    e && e !== this._document.body && e !== i && !i.contains(e) || t.focus() } this._focusTrap && this._focusTrap.destroy() } _savePreviouslyFocusedElement() { this._document && (this._elementFocusedBeforeDialogWasOpened = this._document.activeElement, this._elementRef.nativeElement.focus && Promise.resolve().then(() => this._elementRef.nativeElement.focus())) } _onAnimationDone(t) { "enter" === t.toState ? this._trapFocus() : "exit" === t.toState && this._restoreFocus(), this._animationStateChanged.emit(t) } _onAnimationStart(t) { this._animationStateChanged.emit(t) } _startExitAnimation() { this._state = "exit", this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(bw), Sa(jr), Sa(uh, 8), Sa(DA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-dialog-container"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ec(xD, !0), 2 & t && tc(i = oc()) && (e._portalOutlet = i.first) }, hostAttrs: ["tabindex", "-1", "aria-modal", "true", 1, "mat-dialog-container"], hostVars: 6, hostBindings: function(t, e) { 1 & t && Va("@dialogContainer.start", (function(t) { return e._onAnimationStart(t) }))("@dialogContainer.done", (function(t) { return e._onAnimationDone(t) })), 2 & t && (va("id", e._id)("role", e._config.role)("aria-labelledby", e._config.ariaLabel ? null : e._ariaLabelledBy)("aria-label", e._config.ariaLabel)("aria-describedby", e._config.ariaDescribedBy || null), So("@dialogContainer", e._state)) }, features: [Eo], decls: 1, vars: 0, consts: [
                ["cdkPortalOutlet", ""]
            ], template: function(t, e) { 1 & t && Ca(0, EA, 0, 0, "ng-template", 0) }, directives: [xD], styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"], encapsulation: 2, data: { animation: [AA.dialogContainer] } }), t })(), OA = 0; class RA { constructor(t, e, i = `mat-dialog-${OA++}`) { this._overlayRef = t, this._containerInstance = e, this.id = i, this.disableClose = this._containerInstance._config.disableClose, this._afterOpened = new k, this._afterClosed = new k, this._beforeClosed = new k, this._state = 0, e._id = i, e._animationStateChanged.pipe(Gu(t => "done" === t.phaseName && "enter" === t.toState), lm(1)).subscribe(() => { this._afterOpened.next(), this._afterOpened.complete() }), e._animationStateChanged.pipe(Gu(t => "done" === t.phaseName && "exit" === t.toState), lm(1)).subscribe(() => { clearTimeout(this._closeFallbackTimeout), this._overlayRef.dispose() }), t.detachments().subscribe(() => { this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._afterClosed.next(this._result), this._afterClosed.complete(), this.componentInstance = null, this._overlayRef.dispose() }), t.keydownEvents().pipe(Gu(t => 27 === t.keyCode && !this.disableClose && !Iv(t))).subscribe(t => { t.preventDefault(), this.close() }) } close(t) { this._result = t, this._containerInstance._animationStateChanged.pipe(Gu(t => "start" === t.phaseName), lm(1)).subscribe(e => { this._beforeClosed.next(t), this._beforeClosed.complete(), this._state = 2, this._overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => { this._overlayRef.dispose() }, e.totalTime + 100) }), this._containerInstance._startExitAnimation(), this._state = 1 } afterOpened() { return this._afterOpened.asObservable() } afterClosed() { return this._afterClosed.asObservable() } beforeClosed() { return this._beforeClosed.asObservable() } backdropClick() { return this._overlayRef.backdropClick() } keydownEvents() { return this._overlayRef.keydownEvents() } updatePosition(t) { let e = this._getPositionStrategy(); return t && (t.left || t.right) ? t.left ? e.left(t.left) : e.right(t.right) : e.centerHorizontally(), t && (t.top || t.bottom) ? t.top ? e.top(t.top) : e.bottom(t.bottom) : e.centerVertically(), this._overlayRef.updatePosition(), this } updateSize(t = "", e = "") { return this._getPositionStrategy().width(t).height(e), this._overlayRef.updatePosition(), this } addPanelClass(t) { return this._overlayRef.addPanelClass(t), this } removePanelClass(t) { return this._overlayRef.removePanelClass(t), this } getState() { return this._state } _getPositionStrategy() { return this._overlayRef.getConfig().positionStrategy } }
    const MA = new Vt("MatDialogData"), PA = new Vt("mat-dialog-default-options"), FA = new Vt("mat-dialog-scroll-strategy"), NA = { provide: FA, deps: [JD], useFactory: function(t) { return () => t.scrollStrategies.block() } };
    let LA = (() => { class t { constructor(t, e, i, n, s, r, a) { this._overlay = t, this._injector = e, this._defaultOptions = n, this._parentDialog = r, this._overlayContainer = a, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new k, this._afterOpenedAtThisLevel = new k, this._ariaHiddenElements = new Map, this.afterAllClosed = Hu(() => this.openDialogs.length ? this._afterAllClosed : this._afterAllClosed.pipe(bm(void 0))), this._scrollStrategy = s } get openDialogs() { return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel } get afterOpened() { return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel } get _afterAllClosed() { const t = this._parentDialog; return t ? t._afterAllClosed : this._afterAllClosedAtThisLevel } open(t, e) { if ((e = function(t, e) { return Object.assign(Object.assign({}, e), t) }(e, this._defaultOptions || new DA)).id && this.getDialogById(e.id)) throw Error(`Dialog with id "${e.id}" exists already. The dialog id must be unique.`); const i = this._createOverlay(e),
                    n = this._attachDialogContainer(i, e),
                    s = this._attachDialogContent(t, n, i, e); return this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push(s), s.afterClosed().subscribe(() => this._removeOpenDialog(s)), this.afterOpened.next(s), s } closeAll() { this._closeDialogs(this.openDialogs) } getDialogById(t) { return this.openDialogs.find(e => e.id === t) } ngOnDestroy() { this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete() } _createOverlay(t) { const e = this._getOverlayConfig(t); return this._overlay.create(e) } _getOverlayConfig(t) { const e = new ND({ positionStrategy: this._overlay.position().global(), scrollStrategy: t.scrollStrategy || this._scrollStrategy(), panelClass: t.panelClass, hasBackdrop: t.hasBackdrop, direction: t.direction, minWidth: t.minWidth, minHeight: t.minHeight, maxWidth: t.maxWidth, maxHeight: t.maxHeight, disposeOnNavigation: t.closeOnNavigation }); return t.backdropClass && (e.backdropClass = t.backdropClass), e } _attachDialogContainer(t, e) { const i = ra.create({ parent: e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, providers: [{ provide: DA, useValue: e }] }),
                    n = new _D(TA, e.viewContainerRef, i, e.componentFactoryResolver); return t.attach(n).instance } _attachDialogContent(t, e, i, n) { const s = new RA(i, e, n.id); if (n.hasBackdrop && i.backdropClick().subscribe(() => { s.disableClose || s.close() }), t instanceof gl) e.attachTemplatePortal(new bD(t, null, { $implicit: n.data, dialogRef: s }));
                else { const i = this._createInjector(n, s, e),
                        r = e.attachComponentPortal(new _D(t, n.viewContainerRef, i));
                    s.componentInstance = r.instance } return s.updateSize(n.width, n.height).updatePosition(n.position), s } _createInjector(t, e, i) { const n = t && t.viewContainerRef && t.viewContainerRef.injector,
                    s = [{ provide: TA, useValue: i }, { provide: MA, useValue: t.data }, { provide: RA, useValue: e }]; return !t.direction || n && n.get(Rw, null) || s.push({ provide: Rw, useValue: { value: t.direction, change: Mu() } }), ra.create({ parent: n || this._injector, providers: s }) } _removeOpenDialog(t) { const e = this.openDialogs.indexOf(t);
                e > -1 && (this.openDialogs.splice(e, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((t, e) => { t ? e.setAttribute("aria-hidden", t) : e.removeAttribute("aria-hidden") }), this._ariaHiddenElements.clear(), this._afterAllClosed.next())) } _hideNonDialogContentFromAssistiveTechnology() { const t = this._overlayContainer.getContainerElement(); if (t.parentElement) { const e = t.parentElement.children; for (let i = e.length - 1; i > -1; i--) { let n = e[i];
                        n === t || "SCRIPT" === n.nodeName || "STYLE" === n.nodeName || n.hasAttribute("aria-live") || (this._ariaHiddenElements.set(n, n.getAttribute("aria-hidden")), n.setAttribute("aria-hidden", "true")) } } } _closeDialogs(t) { let e = t.length; for (; e--;) t[e].close() } } return t.\u0275fac = function(e) { return new(e || t)(Xt(JD), Xt(ra), Xt(Dh, 8), Xt(PA, 8), Xt(FA), Xt(t, 12), Xt(jD)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), BA = 0, VA = (() => { class t { constructor(t, e, i) { this.dialogRef = t, this._elementRef = e, this._dialog = i, this.type = "button" } ngOnInit() { this.dialogRef || (this.dialogRef = jA(this._elementRef, this._dialog.openDialogs)) } ngOnChanges(t) { const e = t._matDialogClose || t._matDialogCloseResult;
                e && (this.dialogResult = e.currentValue) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(RA, 8), Sa(Wo), Sa(LA)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-dialog-close", ""],
                ["", "matDialogClose", ""]
            ], hostVars: 2, hostBindings: function(t, e) { 1 & t && Ba("click", (function() { return e.dialogRef.close(e.dialogResult) })), 2 & t && va("aria-label", e.ariaLabel || null)("type", e.type) }, inputs: { type: "type", dialogResult: ["mat-dialog-close", "dialogResult"], ariaLabel: ["aria-label", "ariaLabel"], _matDialogClose: ["matDialogClose", "_matDialogClose"] }, exportAs: ["matDialogClose"], features: [Ro] }), t })(), zA = (() => { class t { constructor(t, e, i) { this._dialogRef = t, this._elementRef = e, this._dialog = i, this.id = `mat-dialog-title-${BA++}` } ngOnInit() { this._dialogRef || (this._dialogRef = jA(this._elementRef, this._dialog.openDialogs)), this._dialogRef && Promise.resolve().then(() => { const t = this._dialogRef._containerInstance;
                    t && !t._ariaLabelledBy && (t._ariaLabelledBy = this.id) }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(RA, 8), Sa(Wo), Sa(LA)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-dialog-title", ""],
                ["", "matDialogTitle", ""]
            ], hostAttrs: [1, "mat-dialog-title"], hostVars: 1, hostBindings: function(t, e) { 2 & t && xo("id", e.id) }, inputs: { id: "id" }, exportAs: ["matDialogTitle"] }), t })(), UA = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-dialog-content", ""],
                ["mat-dialog-content"],
                ["", "matDialogContent", ""]
            ], hostAttrs: [1, "mat-dialog-content"] }), t })(), HA = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-dialog-actions", ""],
                ["mat-dialog-actions"],
                ["", "matDialogActions", ""]
            ], hostAttrs: [1, "mat-dialog-actions"] }), t })();

    function jA(t, e) { let i = t.nativeElement.parentElement; for (; i && !i.classList.contains("mat-dialog-container");) i = i.parentElement; return i ? e.find(t => t.id === i.id) : null }
    let GA = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [LA, NA], imports: [
                [rA, ED, _S], _S
            ] }), t })();
    const $A = ["mat-calendar-body", ""];

    function WA(t, e) { if (1 & t && (Ia(0, "tr", 2), Ia(1, "td", 3), _o(2), Ta(), Ta()), 2 & t) { const t = ja();
            ps(1), io("padding-top", t._cellPadding)("padding-bottom", t._cellPadding), va("colspan", t.numCols), ps(1), yo(" ", t.label, " ") } }

    function qA(t, e) { if (1 & t && (Ia(0, "td", 7), _o(1), Ta()), 2 & t) { const t = ja(2);
            io("padding-top", t._cellPadding)("padding-bottom", t._cellPadding), va("colspan", t._firstRowOffset), ps(1), yo(" ", t._firstRowOffset >= t.labelMinRequiredCells ? t.label : "", " ") } }

    function YA(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "td", 8), Ba("click", (function() { Qe(t); const i = e.$implicit; return ja(2)._cellClicked(i) })), Ia(1, "div", 9), _o(2), Ta(), Ta() } if (2 & t) { const t = e.$implicit,
                i = e.index,
                n = ja().index,
                s = ja();
            io("width", s._cellWidth)("padding-top", s._cellPadding)("padding-bottom", s._cellPadding), no("mat-calendar-body-disabled", !t.enabled)("mat-calendar-body-active", s._isActiveCell(n, i)), Da("ngClass", t.cssClasses)("tabindex", s._isActiveCell(n, i) ? 0 : -1), va("aria-label", t.ariaLabel)("aria-disabled", !t.enabled || null)("aria-selected", s.selectedValue === t.value), ps(1), no("mat-calendar-body-selected", s.selectedValue === t.value)("mat-calendar-body-today", s.todayValue === t.value), ps(1), yo(" ", t.displayValue, " ") } }

    function XA(t, e) { if (1 & t && (Ia(0, "tr", 4), Ca(1, qA, 2, 6, "td", 5), Ca(2, YA, 3, 20, "td", 6), Ta()), 2 & t) { const t = e.$implicit,
                i = e.index,
                n = ja();
            ps(1), Da("ngIf", 0 === i && n._firstRowOffset), ps(1), Da("ngForOf", t) } }

    function KA(t, e) { if (1 & t && (Ia(0, "th", 5), _o(1), Ta()), 2 & t) { const t = e.$implicit;
            va("aria-label", t.long), ps(1), bo(t.narrow) } }
    const ZA = ["*"];

    function QA(t, e) {}

    function JA(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "mat-month-view", 5), Ba("activeDateChange", (function(e) { return Qe(t), ja().activeDate = e }))("selectedChange", (function(e) { return Qe(t), ja()._dateSelected(e) }))("_userSelection", (function() { return Qe(t), ja()._userSelected() })), Ta() } if (2 & t) { const t = ja();
            Da("activeDate", t.activeDate)("selected", t.selected)("dateFilter", t.dateFilter)("maxDate", t.maxDate)("minDate", t.minDate)("dateClass", t.dateClass) } }

    function tI(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "mat-year-view", 6), Ba("activeDateChange", (function(e) { return Qe(t), ja().activeDate = e }))("monthSelected", (function(e) { return Qe(t), ja()._monthSelectedInYearView(e) }))("selectedChange", (function(e) { return Qe(t), ja()._goToDateInView(e, "month") })), Ta() } if (2 & t) { const t = ja();
            Da("activeDate", t.activeDate)("selected", t.selected)("dateFilter", t.dateFilter)("maxDate", t.maxDate)("minDate", t.minDate) } }

    function eI(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "mat-multi-year-view", 7), Ba("activeDateChange", (function(e) { return Qe(t), ja().activeDate = e }))("yearSelected", (function(e) { return Qe(t), ja()._yearSelectedInMultiYearView(e) }))("selectedChange", (function(e) { return Qe(t), ja()._goToDateInView(e, "year") })), Ta() } if (2 & t) { const t = ja();
            Da("activeDate", t.activeDate)("selected", t.selected)("dateFilter", t.dateFilter)("maxDate", t.maxDate)("minDate", t.minDate) } }
    const iI = ["button"];

    function nI(t, e) { 1 & t && (Ci(), Ia(0, "svg", 3), Oa(1, "path", 4), Ta()) }
    const sI = [
        [
            ["", "matDatepickerToggleIcon", ""]
        ]
    ], rI = ["[matDatepickerToggleIcon]"];

    function aI(t) { return Error(`MatDatepicker: No provider found for ${t}. You must import one of the following ` + "modules at your application root: MatNativeDateModule, MatMomentDateModule, or provide a custom implementation.") }
    let oI = (() => { class t { constructor() { this.changes = new k, this.calendarLabel = "Calendar", this.openCalendarLabel = "Open calendar", this.prevMonthLabel = "Previous month", this.nextMonthLabel = "Next month", this.prevYearLabel = "Previous year", this.nextYearLabel = "Next year", this.prevMultiYearLabel = "Previous 20 years", this.nextMultiYearLabel = "Next 20 years", this.switchToMonthViewLabel = "Choose date", this.switchToMultiYearViewLabel = "Choose month and year" } formatYearRange(t, e) { return `${t} \u2013 ${e}` } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return new t }, token: t, providedIn: "root" }), t })(); class lI { constructor(t, e, i, n, s = {}) { this.value = t, this.displayValue = e, this.ariaLabel = i, this.enabled = n, this.cssClasses = s } }
    let cI = (() => { class t { constructor(t, e) { this._elementRef = t, this._ngZone = e, this.numCols = 7, this.activeCell = 0, this.cellAspectRatio = 1, this.selectedValueChange = new jl } _cellClicked(t) { t.enabled && this.selectedValueChange.emit(t.value) } ngOnChanges(t) { const e = t.numCols,
                    { rows: i, numCols: n } = this;
                (t.rows || e) && (this._firstRowOffset = i && i.length && i[0].length ? n - i[0].length : 0), (t.cellAspectRatio || e || !this._cellPadding) && (this._cellPadding = `${50*this.cellAspectRatio/n}%`), !e && this._cellWidth || (this._cellWidth = `${100/n}%`) } _isActiveCell(t, e) { let i = t * this.numCols + e; return t && (i -= this._firstRowOffset), i == this.activeCell } _focusActiveCell() { this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.asObservable().pipe(lm(1)).subscribe(() => { const t = this._elementRef.nativeElement.querySelector(".mat-calendar-body-active");
                        t && t.focus() }) }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Pc)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["", "mat-calendar-body", ""]
            ], hostAttrs: ["role", "grid", "aria-readonly", "true", 1, "mat-calendar-body"], inputs: { numCols: "numCols", activeCell: "activeCell", cellAspectRatio: "cellAspectRatio", label: "label", rows: "rows", todayValue: "todayValue", selectedValue: "selectedValue", labelMinRequiredCells: "labelMinRequiredCells" }, outputs: { selectedValueChange: "selectedValueChange" }, exportAs: ["matCalendarBody"], features: [Ro], attrs: $A, decls: 2, vars: 2, consts: [
                ["aria-hidden", "true", 4, "ngIf"],
                ["role", "row", 4, "ngFor", "ngForOf"],
                ["aria-hidden", "true"],
                [1, "mat-calendar-body-label"],
                ["role", "row"],
                ["aria-hidden", "true", "class", "mat-calendar-body-label", 3, "paddingTop", "paddingBottom", 4, "ngIf"],
                ["role", "gridcell", "class", "mat-calendar-body-cell mat-focus-indicator", "role", "button", 3, "ngClass", "tabindex", "mat-calendar-body-disabled", "mat-calendar-body-active", "width", "paddingTop", "paddingBottom", "click", 4, "ngFor", "ngForOf"],
                ["aria-hidden", "true", 1, "mat-calendar-body-label"],
                ["role", "gridcell", "role", "button", 1, "mat-calendar-body-cell", "mat-focus-indicator", 3, "ngClass", "tabindex", "click"],
                [1, "mat-calendar-body-cell-content"]
            ], template: function(t, e) { 1 & t && (Ca(0, WA, 3, 6, "tr", 0), Ca(1, XA, 3, 2, "tr", 1)), 2 & t && (Da("ngIf", e._firstRowOffset < e.labelMinRequiredCells), ps(1), Da("ngForOf", e.rows)) }, directives: [yd, _d, pd], styles: [".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.7142857143%;padding-right:4.7142857143%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:none;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}.cdk-high-contrast-active .mat-calendar-body-cell-content{border:none}.cdk-high-contrast-active .mat-datepicker-popup:not(:empty),.cdk-high-contrast-active .mat-calendar-body-selected{outline:solid 1px}.cdk-high-contrast-active .mat-calendar-body-today{outline:dotted 1px}.cdk-high-contrast-active .cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-high-contrast-active .cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){outline:dotted 2px}[dir=rtl] .mat-calendar-body-label{text-align:right}\n"], encapsulation: 2, changeDetection: 0 }), t })(), hI = (() => { class t { constructor(t, e, i, n) { if (this._changeDetectorRef = t, this._dateFormats = e, this._dateAdapter = i, this._dir = n, this._rerenderSubscription = d.EMPTY, this.selectedChange = new jl, this._userSelection = new jl, this.activeDateChange = new jl, !this._dateAdapter) throw aI("DateAdapter"); if (!this._dateFormats) throw aI("MAT_DATE_FORMATS");
                this._activeDate = this._dateAdapter.today() } get activeDate() { return this._activeDate } set activeDate(t) { const e = this._activeDate,
                    i = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) || this._dateAdapter.today();
                this._activeDate = this._dateAdapter.clampDate(i, this.minDate, this.maxDate), this._hasSameMonthAndYear(e, this._activeDate) || this._init() } get selected() { return this._selected } set selected(t) { this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(t)), this._selectedDate = this._getDateInCurrentMonth(this._selected) } get minDate() { return this._minDate } set minDate(t) { this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } get maxDate() { return this._maxDate } set maxDate(t) { this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } ngAfterContentInit() { this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(bm(null)).subscribe(() => this._init()) } ngOnDestroy() { this._rerenderSubscription.unsubscribe() } _dateSelected(t) { if (this._selectedDate != t) { const e = this._dateAdapter.getYear(this.activeDate),
                        i = this._dateAdapter.getMonth(this.activeDate),
                        n = this._dateAdapter.createDate(e, i, t);
                    this.selectedChange.emit(n) } this._userSelection.emit() } _handleCalendarBodyKeydown(t) { const e = this._activeDate,
                    i = this._isRtl(); switch (t.keyCode) {
                    case 37:
                        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, i ? 1 : -1); break;
                    case 39:
                        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, i ? -1 : 1); break;
                    case 38:
                        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7); break;
                    case 40:
                        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7); break;
                    case 36:
                        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate)); break;
                    case 35:
                        this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, this._dateAdapter.getNumDaysInMonth(this._activeDate) - this._dateAdapter.getDate(this._activeDate)); break;
                    case 33:
                        this.activeDate = t.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, -1) : this._dateAdapter.addCalendarMonths(this._activeDate, -1); break;
                    case 34:
                        this.activeDate = t.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, 1) : this._dateAdapter.addCalendarMonths(this._activeDate, 1); break;
                    case 13:
                    case 32:
                        return void(this.dateFilter && !this.dateFilter(this._activeDate) || (this._dateSelected(this._dateAdapter.getDate(this._activeDate)), this._userSelection.emit(), t.preventDefault()));
                    default:
                        return } this._dateAdapter.compareDate(e, this.activeDate) && this.activeDateChange.emit(this.activeDate), this._focusActiveCell(), t.preventDefault() } _init() { this._selectedDate = this._getDateInCurrentMonth(this.selected), this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today()), this._monthLabel = this._dateAdapter.getMonthNames("short")[this._dateAdapter.getMonth(this.activeDate)].toLocaleUpperCase(); let t = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);
                this._firstWeekOffset = (7 + this._dateAdapter.getDayOfWeek(t) - this._dateAdapter.getFirstDayOfWeek()) % 7, this._initWeekdays(), this._createWeekCells(), this._changeDetectorRef.markForCheck() } _focusActiveCell() { this._matCalendarBody._focusActiveCell() } _initWeekdays() { const t = this._dateAdapter.getFirstDayOfWeek(),
                    e = this._dateAdapter.getDayOfWeekNames("narrow"); let i = this._dateAdapter.getDayOfWeekNames("long").map((t, i) => ({ long: t, narrow: e[i] }));
                this._weekdays = i.slice(t).concat(i.slice(0, t)) } _createWeekCells() { const t = this._dateAdapter.getNumDaysInMonth(this.activeDate),
                    e = this._dateAdapter.getDateNames();
                this._weeks = [
                    []
                ]; for (let i = 0, n = this._firstWeekOffset; i < t; i++, n++) { 7 == n && (this._weeks.push([]), n = 0); const t = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1),
                        s = this._shouldEnableDate(t),
                        r = this._dateAdapter.format(t, this._dateFormats.display.dateA11yLabel),
                        a = this.dateClass ? this.dateClass(t) : void 0;
                    this._weeks[this._weeks.length - 1].push(new lI(i + 1, e[i], r, s, a)) } } _shouldEnableDate(t) { return !!t && (!this.minDate || this._dateAdapter.compareDate(t, this.minDate) >= 0) && (!this.maxDate || this._dateAdapter.compareDate(t, this.maxDate) <= 0) && (!this.dateFilter || this.dateFilter(t)) } _getDateInCurrentMonth(t) { return t && this._hasSameMonthAndYear(t, this.activeDate) ? this._dateAdapter.getDate(t) : null } _hasSameMonthAndYear(t, e) { return !(!t || !e || this._dateAdapter.getMonth(t) != this._dateAdapter.getMonth(e) || this._dateAdapter.getYear(t) != this._dateAdapter.getYear(e)) } _getValidDateOrNull(t) { return this._dateAdapter.isDateInstance(t) && this._dateAdapter.isValid(t) ? t : null } _isRtl() { return this._dir && "rtl" === this._dir.value } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jr), Sa(ES, 8), Sa(kS, 8), Sa(Rw, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-month-view"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(cI, !0), 2 & t && tc(i = oc()) && (e._matCalendarBody = i.first) }, inputs: { activeDate: "activeDate", selected: "selected", minDate: "minDate", maxDate: "maxDate", dateFilter: "dateFilter", dateClass: "dateClass" }, outputs: { selectedChange: "selectedChange", _userSelection: "_userSelection", activeDateChange: "activeDateChange" }, exportAs: ["matMonthView"], decls: 7, vars: 7, consts: [
                ["role", "presentation", 1, "mat-calendar-table"],
                [1, "mat-calendar-table-header"],
                ["scope", "col", 4, "ngFor", "ngForOf"],
                ["colspan", "7", "aria-hidden", "true", 1, "mat-calendar-table-header-divider"],
                ["mat-calendar-body", "", 3, "label", "rows", "todayValue", "selectedValue", "labelMinRequiredCells", "activeCell", "selectedValueChange", "keydown"],
                ["scope", "col"]
            ], template: function(t, e) { 1 & t && (Ia(0, "table", 0), Ia(1, "thead", 1), Ia(2, "tr"), Ca(3, KA, 2, 2, "th", 2), Ta(), Ia(4, "tr"), Oa(5, "th", 3), Ta(), Ta(), Ia(6, "tbody", 4), Ba("selectedValueChange", (function(t) { return e._dateSelected(t) }))("keydown", (function(t) { return e._handleCalendarBodyKeydown(t) })), Ta(), Ta()), 2 & t && (ps(3), Da("ngForOf", e._weekdays), ps(3), Da("label", e._monthLabel)("rows", e._weeks)("todayValue", e._todayDate)("selectedValue", e._selectedDate)("labelMinRequiredCells", 3)("activeCell", e._dateAdapter.getDate(e.activeDate) - 1)) }, directives: [_d, cI], encapsulation: 2, changeDetection: 0 }), t })(), dI = (() => { class t { constructor(t, e, i) { if (this._changeDetectorRef = t, this._dateAdapter = e, this._dir = i, this._rerenderSubscription = d.EMPTY, this.selectedChange = new jl, this.yearSelected = new jl, this.activeDateChange = new jl, !this._dateAdapter) throw aI("DateAdapter");
                this._activeDate = this._dateAdapter.today() } get activeDate() { return this._activeDate } set activeDate(t) { let e = this._activeDate; const i = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) || this._dateAdapter.today();
                this._activeDate = this._dateAdapter.clampDate(i, this.minDate, this.maxDate), uI(this._dateAdapter, e, this._activeDate, this.minDate, this.maxDate) || this._init() } get selected() { return this._selected } set selected(t) { this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(t)), this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected) } get minDate() { return this._minDate } set minDate(t) { this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } get maxDate() { return this._maxDate } set maxDate(t) { this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } ngAfterContentInit() { this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(bm(null)).subscribe(() => this._init()) } ngOnDestroy() { this._rerenderSubscription.unsubscribe() } _init() { this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today()); const t = this._dateAdapter.getYear(this._activeDate) - mI(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);
                this._years = []; for (let e = 0, i = []; e < 24; e++) i.push(t + e), 4 == i.length && (this._years.push(i.map(t => this._createCellForYear(t))), i = []);
                this._changeDetectorRef.markForCheck() } _yearSelected(t) { this.yearSelected.emit(this._dateAdapter.createDate(t, 0, 1)); let e = this._dateAdapter.getMonth(this.activeDate),
                    i = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(t, e, 1));
                this.selectedChange.emit(this._dateAdapter.createDate(t, e, Math.min(this._dateAdapter.getDate(this.activeDate), i))) } _handleCalendarBodyKeydown(t) { const e = this._activeDate,
                    i = this._isRtl(); switch (t.keyCode) {
                    case 37:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, i ? 1 : -1); break;
                    case 39:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, i ? -1 : 1); break;
                    case 38:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -4); break;
                    case 40:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, 4); break;
                    case 36:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -mI(this._dateAdapter, this.activeDate, this.minDate, this.maxDate)); break;
                    case 35:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, 24 - mI(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) - 1); break;
                    case 33:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, t.altKey ? -240 : -24); break;
                    case 34:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, t.altKey ? 240 : 24); break;
                    case 13:
                    case 32:
                        this._yearSelected(this._dateAdapter.getYear(this._activeDate)); break;
                    default:
                        return } this._dateAdapter.compareDate(e, this.activeDate) && this.activeDateChange.emit(this.activeDate), this._focusActiveCell(), t.preventDefault() } _getActiveCell() { return mI(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) } _focusActiveCell() { this._matCalendarBody._focusActiveCell() } _createCellForYear(t) { let e = this._dateAdapter.getYearName(this._dateAdapter.createDate(t, 0, 1)); return new lI(t, e, e, this._shouldEnableYear(t)) } _shouldEnableYear(t) { if (null == t || this.maxDate && t > this._dateAdapter.getYear(this.maxDate) || this.minDate && t < this._dateAdapter.getYear(this.minDate)) return !1; if (!this.dateFilter) return !0; for (let e = this._dateAdapter.createDate(t, 0, 1); this._dateAdapter.getYear(e) == t; e = this._dateAdapter.addCalendarDays(e, 1))
                    if (this.dateFilter(e)) return !0; return !1 } _getValidDateOrNull(t) { return this._dateAdapter.isDateInstance(t) && this._dateAdapter.isValid(t) ? t : null } _isRtl() { return this._dir && "rtl" === this._dir.value } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jr), Sa(kS, 8), Sa(Rw, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-multi-year-view"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(cI, !0), 2 & t && tc(i = oc()) && (e._matCalendarBody = i.first) }, inputs: { activeDate: "activeDate", selected: "selected", minDate: "minDate", maxDate: "maxDate", dateFilter: "dateFilter" }, outputs: { selectedChange: "selectedChange", yearSelected: "yearSelected", activeDateChange: "activeDateChange" }, exportAs: ["matMultiYearView"], decls: 5, vars: 6, consts: [
                ["role", "presentation", 1, "mat-calendar-table"],
                [1, "mat-calendar-table-header"],
                ["colspan", "4", 1, "mat-calendar-table-header-divider"],
                ["mat-calendar-body", "", 3, "rows", "todayValue", "selectedValue", "numCols", "cellAspectRatio", "activeCell", "selectedValueChange", "keydown"]
            ], template: function(t, e) { 1 & t && (Ia(0, "table", 0), Ia(1, "thead", 1), Ia(2, "tr"), Oa(3, "th", 2), Ta(), Ta(), Ia(4, "tbody", 3), Ba("selectedValueChange", (function(t) { return e._yearSelected(t) }))("keydown", (function(t) { return e._handleCalendarBodyKeydown(t) })), Ta(), Ta()), 2 & t && (ps(4), Da("rows", e._years)("todayValue", e._todayYear)("selectedValue", e._selectedYear)("numCols", 4)("cellAspectRatio", 4 / 7)("activeCell", e._getActiveCell())) }, directives: [cI], encapsulation: 2, changeDetection: 0 }), t })();

    function uI(t, e, i, n, s) { const r = t.getYear(e),
            a = t.getYear(i),
            o = pI(t, n, s); return Math.floor((r - o) / 24) === Math.floor((a - o) / 24) }

    function mI(t, e, i, n) { return ((t.getYear(e) - pI(t, i, n)) % 24 + 24) % 24 }

    function pI(t, e, i) { let n = 0; return i ? n = t.getYear(i) - 24 + 1 : e && (n = t.getYear(e)), n }
    let fI = (() => { class t { constructor(t, e, i, n) { if (this._changeDetectorRef = t, this._dateFormats = e, this._dateAdapter = i, this._dir = n, this._rerenderSubscription = d.EMPTY, this.selectedChange = new jl, this.monthSelected = new jl, this.activeDateChange = new jl, !this._dateAdapter) throw aI("DateAdapter"); if (!this._dateFormats) throw aI("MAT_DATE_FORMATS");
                this._activeDate = this._dateAdapter.today() } get activeDate() { return this._activeDate } set activeDate(t) { let e = this._activeDate; const i = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) || this._dateAdapter.today();
                this._activeDate = this._dateAdapter.clampDate(i, this.minDate, this.maxDate), this._dateAdapter.getYear(e) !== this._dateAdapter.getYear(this._activeDate) && this._init() } get selected() { return this._selected } set selected(t) { this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(t)), this._selectedMonth = this._getMonthInCurrentYear(this._selected) } get minDate() { return this._minDate } set minDate(t) { this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } get maxDate() { return this._maxDate } set maxDate(t) { this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } ngAfterContentInit() { this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(bm(null)).subscribe(() => this._init()) } ngOnDestroy() { this._rerenderSubscription.unsubscribe() } _monthSelected(t) { const e = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), t, 1);
                this.monthSelected.emit(e); const i = this._dateAdapter.getNumDaysInMonth(e);
                this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), t, Math.min(this._dateAdapter.getDate(this.activeDate), i))) } _handleCalendarBodyKeydown(t) { const e = this._activeDate,
                    i = this._isRtl(); switch (t.keyCode) {
                    case 37:
                        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, i ? 1 : -1); break;
                    case 39:
                        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, i ? -1 : 1); break;
                    case 38:
                        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4); break;
                    case 40:
                        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4); break;
                    case 36:
                        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate)); break;
                    case 35:
                        this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate)); break;
                    case 33:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, t.altKey ? -10 : -1); break;
                    case 34:
                        this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, t.altKey ? 10 : 1); break;
                    case 13:
                    case 32:
                        this._monthSelected(this._dateAdapter.getMonth(this._activeDate)); break;
                    default:
                        return } this._dateAdapter.compareDate(e, this.activeDate) && this.activeDateChange.emit(this.activeDate), this._focusActiveCell(), t.preventDefault() } _init() { this._selectedMonth = this._getMonthInCurrentYear(this.selected), this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today()), this._yearLabel = this._dateAdapter.getYearName(this.activeDate); let t = this._dateAdapter.getMonthNames("short");
                this._months = [
                    [0, 1, 2, 3],
                    [4, 5, 6, 7],
                    [8, 9, 10, 11]
                ].map(e => e.map(e => this._createCellForMonth(e, t[e]))), this._changeDetectorRef.markForCheck() } _focusActiveCell() { this._matCalendarBody._focusActiveCell() } _getMonthInCurrentYear(t) { return t && this._dateAdapter.getYear(t) == this._dateAdapter.getYear(this.activeDate) ? this._dateAdapter.getMonth(t) : null } _createCellForMonth(t, e) { let i = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), t, 1), this._dateFormats.display.monthYearA11yLabel); return new lI(t, e.toLocaleUpperCase(), i, this._shouldEnableMonth(t)) } _shouldEnableMonth(t) { const e = this._dateAdapter.getYear(this.activeDate); if (null == t || this._isYearAndMonthAfterMaxDate(e, t) || this._isYearAndMonthBeforeMinDate(e, t)) return !1; if (!this.dateFilter) return !0; for (let i = this._dateAdapter.createDate(e, t, 1); this._dateAdapter.getMonth(i) == t; i = this._dateAdapter.addCalendarDays(i, 1))
                    if (this.dateFilter(i)) return !0; return !1 } _isYearAndMonthAfterMaxDate(t, e) { if (this.maxDate) { const i = this._dateAdapter.getYear(this.maxDate),
                        n = this._dateAdapter.getMonth(this.maxDate); return t > i || t === i && e > n } return !1 } _isYearAndMonthBeforeMinDate(t, e) { if (this.minDate) { const i = this._dateAdapter.getYear(this.minDate),
                        n = this._dateAdapter.getMonth(this.minDate); return t < i || t === i && e < n } return !1 } _getValidDateOrNull(t) { return this._dateAdapter.isDateInstance(t) && this._dateAdapter.isValid(t) ? t : null } _isRtl() { return this._dir && "rtl" === this._dir.value } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jr), Sa(ES, 8), Sa(kS, 8), Sa(Rw, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-year-view"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(cI, !0), 2 & t && tc(i = oc()) && (e._matCalendarBody = i.first) }, inputs: { activeDate: "activeDate", selected: "selected", minDate: "minDate", maxDate: "maxDate", dateFilter: "dateFilter" }, outputs: { selectedChange: "selectedChange", monthSelected: "monthSelected", activeDateChange: "activeDateChange" }, exportAs: ["matYearView"], decls: 5, vars: 8, consts: [
                ["role", "presentation", 1, "mat-calendar-table"],
                [1, "mat-calendar-table-header"],
                ["colspan", "4", 1, "mat-calendar-table-header-divider"],
                ["mat-calendar-body", "", 3, "label", "rows", "todayValue", "selectedValue", "labelMinRequiredCells", "numCols", "cellAspectRatio", "activeCell", "selectedValueChange", "keydown"]
            ], template: function(t, e) { 1 & t && (Ia(0, "table", 0), Ia(1, "thead", 1), Ia(2, "tr"), Oa(3, "th", 2), Ta(), Ta(), Ia(4, "tbody", 3), Ba("selectedValueChange", (function(t) { return e._monthSelected(t) }))("keydown", (function(t) { return e._handleCalendarBodyKeydown(t) })), Ta(), Ta()), 2 & t && (ps(4), Da("label", e._yearLabel)("rows", e._months)("todayValue", e._todayMonth)("selectedValue", e._selectedMonth)("labelMinRequiredCells", 2)("numCols", 4)("cellAspectRatio", 4 / 7)("activeCell", e._dateAdapter.getMonth(e.activeDate))) }, directives: [cI], encapsulation: 2, changeDetection: 0 }), t })(), gI = (() => { class t { constructor(t, e, i, n, s) { this._intl = t, this.calendar = e, this._dateAdapter = i, this._dateFormats = n, this.calendar.stateChanges.subscribe(() => s.markForCheck()) } get periodButtonText() { if ("month" == this.calendar.currentView) return this._dateAdapter.format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel).toLocaleUpperCase(); if ("year" == this.calendar.currentView) return this._dateAdapter.getYearName(this.calendar.activeDate); const t = this._dateAdapter.getYear(this.calendar.activeDate) - mI(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate),
                    e = t + 24 - 1,
                    i = this._dateAdapter.getYearName(this._dateAdapter.createDate(t, 0, 1)),
                    n = this._dateAdapter.getYearName(this._dateAdapter.createDate(e, 0, 1)); return this._intl.formatYearRange(i, n) } get periodButtonLabel() { return "month" == this.calendar.currentView ? this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel } get prevButtonLabel() { return { month: this._intl.prevMonthLabel, year: this._intl.prevYearLabel, "multi-year": this._intl.prevMultiYearLabel } [this.calendar.currentView] } get nextButtonLabel() { return { month: this._intl.nextMonthLabel, year: this._intl.nextYearLabel, "multi-year": this._intl.nextMultiYearLabel } [this.calendar.currentView] } currentPeriodClicked() { this.calendar.currentView = "month" == this.calendar.currentView ? "multi-year" : "month" } previousClicked() { this.calendar.activeDate = "month" == this.calendar.currentView ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, "year" == this.calendar.currentView ? -1 : -24) } nextClicked() { this.calendar.activeDate = "month" == this.calendar.currentView ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, "year" == this.calendar.currentView ? 1 : 24) } previousEnabled() { return !this.calendar.minDate || !this.calendar.minDate || !this._isSameView(this.calendar.activeDate, this.calendar.minDate) } nextEnabled() { return !this.calendar.maxDate || !this._isSameView(this.calendar.activeDate, this.calendar.maxDate) } _isSameView(t, e) { return "month" == this.calendar.currentView ? this._dateAdapter.getYear(t) == this._dateAdapter.getYear(e) && this._dateAdapter.getMonth(t) == this._dateAdapter.getMonth(e) : "year" == this.calendar.currentView ? this._dateAdapter.getYear(t) == this._dateAdapter.getYear(e) : uI(this._dateAdapter, t, e, this.calendar.minDate, this.calendar.maxDate) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(oI), Sa(St(() => _I)), Sa(kS, 8), Sa(ES, 8), Sa(jr)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-calendar-header"]
            ], exportAs: ["matCalendarHeader"], ngContentSelectors: ZA, decls: 9, vars: 8, consts: [
                [1, "mat-calendar-header"],
                [1, "mat-calendar-controls"],
                ["mat-button", "", "type", "button", "cdkAriaLive", "polite", 1, "mat-calendar-period-button", 3, "click"],
                [1, "mat-calendar-arrow"],
                [1, "mat-calendar-spacer"],
                ["mat-icon-button", "", "type", "button", 1, "mat-calendar-previous-button", 3, "disabled", "click"],
                ["mat-icon-button", "", "type", "button", 1, "mat-calendar-next-button", 3, "disabled", "click"]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "div", 0), Ia(1, "div", 1), Ia(2, "button", 2), Ba("click", (function() { return e.currentPeriodClicked() })), _o(3), Oa(4, "div", 3), Ta(), Oa(5, "div", 4), Wa(6), Ia(7, "button", 5), Ba("click", (function() { return e.previousClicked() })), Ta(), Ia(8, "button", 6), Ba("click", (function() { return e.nextClicked() })), Ta(), Ta(), Ta()), 2 & t && (ps(2), va("aria-label", e.periodButtonLabel), ps(1), yo(" ", e.periodButtonText, " "), ps(1), no("mat-calendar-invert", "month" != e.calendar.currentView), ps(3), Da("disabled", !e.previousEnabled()), va("aria-label", e.prevButtonLabel), ps(1), Da("disabled", !e.nextEnabled()), va("aria-label", e.nextButtonLabel)) }, directives: [fk, xw], encapsulation: 2, changeDetection: 0 }), t })(), _I = (() => { class t { constructor(t, e, i, n) { if (this._dateAdapter = e, this._dateFormats = i, this._changeDetectorRef = n, this._moveFocusOnNextTick = !1, this.startView = "month", this.selectedChange = new jl, this.yearSelected = new jl, this.monthSelected = new jl, this._userSelection = new jl, this.stateChanges = new k, !this._dateAdapter) throw aI("DateAdapter"); if (!this._dateFormats) throw aI("MAT_DATE_FORMATS");
                this._intlChanges = t.changes.subscribe(() => { n.markForCheck(), this.stateChanges.next() }) } get startAt() { return this._startAt } set startAt(t) { this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } get selected() { return this._selected } set selected(t) { this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } get minDate() { return this._minDate } set minDate(t) { this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } get maxDate() { return this._maxDate } set maxDate(t) { this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } get activeDate() { return this._clampedActiveDate } set activeDate(t) { this._clampedActiveDate = this._dateAdapter.clampDate(t, this.minDate, this.maxDate), this.stateChanges.next(), this._changeDetectorRef.markForCheck() } get currentView() { return this._currentView } set currentView(t) { this._currentView = t, this._moveFocusOnNextTick = !0, this._changeDetectorRef.markForCheck() } ngAfterContentInit() { this._calendarHeaderPortal = new _D(this.headerComponent || gI), this.activeDate = this.startAt || this._dateAdapter.today(), this._currentView = this.startView } ngAfterViewChecked() { this._moveFocusOnNextTick && (this._moveFocusOnNextTick = !1, this.focusActiveCell()) } ngOnDestroy() { this._intlChanges.unsubscribe(), this.stateChanges.complete() } ngOnChanges(t) { const e = t.minDate || t.maxDate || t.dateFilter; if (e && !e.firstChange) { const t = this._getCurrentViewComponent();
                    t && (this._changeDetectorRef.detectChanges(), t._init()) } this.stateChanges.next() } focusActiveCell() { this._getCurrentViewComponent()._focusActiveCell() } updateTodaysDate() { const t = this.currentView; let e;
                e = "month" === t ? this.monthView : "year" === t ? this.yearView : this.multiYearView, e.ngAfterContentInit() } _dateSelected(t) { t && !this._dateAdapter.sameDate(t, this.selected) && this.selectedChange.emit(t) } _yearSelectedInMultiYearView(t) { this.yearSelected.emit(t) } _monthSelectedInYearView(t) { this.monthSelected.emit(t) } _userSelected() { this._userSelection.emit() } _goToDateInView(t, e) { this.activeDate = t, this.currentView = e } _getValidDateOrNull(t) { return this._dateAdapter.isDateInstance(t) && this._dateAdapter.isValid(t) ? t : null } _getCurrentViewComponent() { return this.monthView || this.yearView || this.multiYearView } } return t.\u0275fac = function(e) { return new(e || t)(Sa(oI), Sa(kS, 8), Sa(ES, 8), Sa(jr)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-calendar"]
            ], viewQuery: function(t, e) { var i;
                1 & t && (ic(hI, !0), ic(fI, !0), ic(dI, !0)), 2 & t && (tc(i = oc()) && (e.monthView = i.first), tc(i = oc()) && (e.yearView = i.first), tc(i = oc()) && (e.multiYearView = i.first)) }, hostAttrs: [1, "mat-calendar"], inputs: { startView: "startView", startAt: "startAt", selected: "selected", minDate: "minDate", maxDate: "maxDate", headerComponent: "headerComponent", dateFilter: "dateFilter", dateClass: "dateClass" }, outputs: { selectedChange: "selectedChange", yearSelected: "yearSelected", monthSelected: "monthSelected", _userSelection: "_userSelection" }, exportAs: ["matCalendar"], features: [Ro], decls: 5, vars: 5, consts: [
                [3, "cdkPortalOutlet"],
                ["cdkMonitorSubtreeFocus", "", "tabindex", "-1", 1, "mat-calendar-content", 3, "ngSwitch"],
                [3, "activeDate", "selected", "dateFilter", "maxDate", "minDate", "dateClass", "activeDateChange", "selectedChange", "_userSelection", 4, "ngSwitchCase"],
                [3, "activeDate", "selected", "dateFilter", "maxDate", "minDate", "activeDateChange", "monthSelected", "selectedChange", 4, "ngSwitchCase"],
                [3, "activeDate", "selected", "dateFilter", "maxDate", "minDate", "activeDateChange", "yearSelected", "selectedChange", 4, "ngSwitchCase"],
                [3, "activeDate", "selected", "dateFilter", "maxDate", "minDate", "dateClass", "activeDateChange", "selectedChange", "_userSelection"],
                [3, "activeDate", "selected", "dateFilter", "maxDate", "minDate", "activeDateChange", "monthSelected", "selectedChange"],
                [3, "activeDate", "selected", "dateFilter", "maxDate", "minDate", "activeDateChange", "yearSelected", "selectedChange"]
            ], template: function(t, e) { 1 & t && (Ca(0, QA, 0, 0, "ng-template", 0), Ia(1, "div", 1), Ca(2, JA, 1, 6, "mat-month-view", 2), Ca(3, tI, 1, 5, "mat-year-view", 3), Ca(4, eI, 1, 5, "mat-multi-year-view", 4), Ta()), 2 & t && (Da("cdkPortalOutlet", e._calendarHeaderPortal), ps(1), Da("ngSwitch", e.currentView), ps(1), Da("ngSwitchCase", "month"), ps(1), Da("ngSwitchCase", "year"), ps(1), Da("ngSwitchCase", "multi-year")) }, directives: [xD, Dw, xd, Sd, hI, fI, dI], styles: ['.mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:none}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-previous-button,.mat-calendar-next-button{position:relative}.mat-calendar-previous-button::after,.mat-calendar-next-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:"";margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-previous-button,[dir=rtl] .mat-calendar-next-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:"";position:absolute;top:0;left:-8px;right:-8px;height:1px}\n'], encapsulation: 2, changeDetection: 0 }), t })();
    const bI = { transformPanel: Lw("transformPanel", [Hw("void", Uw({ opacity: 0, transform: "scale(1, 0.8)" })), Gw("void => enter", Bw("120ms cubic-bezier(0, 0, 0.2, 1)", Uw({ opacity: 1, transform: "scale(1, 1)" }))), Gw("* => void", Bw("100ms linear", Uw({ opacity: 0 })))]), fadeInCalendar: Lw("fadeInCalendar", [Hw("void", Uw({ opacity: 0 })), Hw("enter", Uw({ opacity: 1 })), Gw("void => *", Bw("120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)"))]) };
    let yI = 0;
    const vI = new Vt("mat-datepicker-scroll-strategy"), wI = { provide: vI, deps: [JD], useFactory: function(t) { return () => t.scrollStrategies.reposition() } }; class CI { constructor(t) { this._elementRef = t } }
    const xI = yS(CI);
    let SI = (() => { class t extends xI { constructor(t, e) { super(t), this._changeDetectorRef = e, this._animationState = "enter", this._animationDone = new k } ngAfterViewInit() { this._calendar.focusActiveCell() } ngOnDestroy() { this._animationDone.complete() } _startExitAnimation() { this._animationState = "void", this._changeDetectorRef && this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-datepicker-content"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(_I, !0), 2 & t && tc(i = oc()) && (e._calendar = i.first) }, hostAttrs: [1, "mat-datepicker-content"], hostVars: 3, hostBindings: function(t, e) { 1 & t && Va("@transformPanel.done", (function() { return e._animationDone.next() })), 2 & t && (So("@transformPanel", e._animationState), no("mat-datepicker-content-touch", e.datepicker.touchUi)) }, inputs: { color: "color" }, exportAs: ["matDatepickerContent"], features: [Eo], decls: 1, vars: 11, consts: [
                ["cdkTrapFocus", "", 3, "id", "ngClass", "startAt", "startView", "minDate", "maxDate", "dateFilter", "headerComponent", "selected", "dateClass", "selectedChange", "yearSelected", "monthSelected", "_userSelection"]
            ], template: function(t, e) { 1 & t && (Ia(0, "mat-calendar", 0), Ba("selectedChange", (function(t) { return e.datepicker.select(t) }))("yearSelected", (function(t) { return e.datepicker._selectYear(t) }))("monthSelected", (function(t) { return e.datepicker._selectMonth(t) }))("_userSelection", (function() { return e.datepicker.close() })), Ta()), 2 & t && Da("id", e.datepicker.id)("ngClass", e.datepicker.panelClass)("startAt", e.datepicker.startAt)("startView", e.datepicker.startView)("minDate", e.datepicker._minDate)("maxDate", e.datepicker._maxDate)("dateFilter", e.datepicker._dateFilter)("headerComponent", e.datepicker.calendarHeaderComponent)("selected", e.datepicker._selected)("dateClass", e.datepicker.dateClass)("@fadeInCalendar", "enter") }, directives: [_I, yw, pd], styles: [".mat-datepicker-content{display:block;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content-touch{display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation: landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation: portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}\n"], encapsulation: 2, data: { animation: [bI.transformPanel, bI.fadeInCalendar] }, changeDetection: 0 }), t })(), kI = (() => { class t { constructor(t, e, i, n, s, r, a, o) { if (this._dialog = t, this._overlay = e, this._ngZone = i, this._viewContainerRef = n, this._dateAdapter = r, this._dir = a, this._document = o, this.startView = "month", this._touchUi = !1, this.yearSelected = new jl, this.monthSelected = new jl, this.openedStream = new jl, this.closedStream = new jl, this._opened = !1, this.id = `mat-datepicker-${yI++}`, this._validSelected = null, this._focusedElementBeforeOpen = null, this._inputSubscription = d.EMPTY, this._disabledChange = new k, this._selectedChanged = new k, !this._dateAdapter) throw aI("DateAdapter");
                this._scrollStrategy = s } get startAt() { return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null) } set startAt(t) { this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(t)) } get color() { return this._color || (this._datepickerInput ? this._datepickerInput._getThemePalette() : void 0) } set color(t) { this._color = t } get touchUi() { return this._touchUi } set touchUi(t) { this._touchUi = Vv(t) } get disabled() { return void 0 === this._disabled && this._datepickerInput ? this._datepickerInput.disabled : !!this._disabled } set disabled(t) { const e = Vv(t);
                e !== this._disabled && (this._disabled = e, this._disabledChange.next(e)) } get opened() { return this._opened } set opened(t) { t ? this.open() : this.close() } get _selected() { return this._validSelected } set _selected(t) { this._validSelected = t } get _minDate() { return this._datepickerInput && this._datepickerInput.min } get _maxDate() { return this._datepickerInput && this._datepickerInput.max } get _dateFilter() { return this._datepickerInput && this._datepickerInput._dateFilter } ngOnDestroy() { this._destroyPopup(), this.close(), this._inputSubscription.unsubscribe(), this._disabledChange.complete() } select(t) { let e = this._selected;
                this._selected = t, this._dateAdapter.sameDate(e, this._selected) || this._selectedChanged.next(t) } _selectYear(t) { this.yearSelected.emit(t) } _selectMonth(t) { this.monthSelected.emit(t) } _registerInput(t) { if (this._datepickerInput) throw Error("A MatDatepicker can only be associated with a single input.");
                this._datepickerInput = t, this._inputSubscription = this._datepickerInput._valueChange.subscribe(t => this._selected = t) } open() { if (!this._opened && !this.disabled) { if (!this._datepickerInput) throw Error("Attempted to open an MatDatepicker with no associated input.");
                    this._document && (this._focusedElementBeforeOpen = this._document.activeElement), this.touchUi ? this._openAsDialog() : this._openAsPopup(), this._opened = !0, this.openedStream.emit() } } close() { if (!this._opened) return; if (this._popupComponentRef && this._popupRef) { const t = this._popupComponentRef.instance;
                    t._startExitAnimation(), t._animationDone.pipe(lm(1)).subscribe(() => this._destroyPopup()) } this._dialogRef && (this._dialogRef.close(), this._dialogRef = null); const t = () => { this._opened && (this._opened = !1, this.closedStream.emit(), this._focusedElementBeforeOpen = null) };
                this._focusedElementBeforeOpen && "function" == typeof this._focusedElementBeforeOpen.focus ? (this._focusedElementBeforeOpen.focus(), setTimeout(t)) : t() } _openAsDialog() { this._dialogRef && this._dialogRef.close(), this._dialogRef = this._dialog.open(SI, { direction: this._dir ? this._dir.value : "ltr", viewContainerRef: this._viewContainerRef, panelClass: "mat-datepicker-dialog", hasBackdrop: !0, disableClose: !1, width: "", height: "", minWidth: "", minHeight: "", maxWidth: "80vw", maxHeight: "", position: {}, autoFocus: !0, restoreFocus: !0 }), this._dialogRef.afterClosed().subscribe(() => this.close()), this._dialogRef.componentInstance.datepicker = this, this._dialogRef.componentInstance.color = this.color } _openAsPopup() { const t = new _D(SI, this._viewContainerRef);
                this._destroyPopup(), this._createPopup(); const e = this._popupComponentRef = this._popupRef.attach(t);
                e.instance.datepicker = this, e.instance.color = this.color, this._ngZone.onStable.asObservable().pipe(lm(1)).subscribe(() => { this._popupRef.updatePosition() }) } _createPopup() { const t = new ND({ positionStrategy: this._createPopupPositionStrategy(), hasBackdrop: !0, backdropClass: "mat-overlay-transparent-backdrop", direction: this._dir, scrollStrategy: this._scrollStrategy(), panelClass: "mat-datepicker-popup" });
                this._popupRef = this._overlay.create(t), this._popupRef.overlayElement.setAttribute("role", "dialog"), q(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(Gu(t => 27 === t.keyCode || this._datepickerInput && t.altKey && 38 === t.keyCode))).subscribe(t => { t && t.preventDefault(), this.close() }) } _destroyPopup() { this._popupRef && (this._popupRef.dispose(), this._popupRef = this._popupComponentRef = null) } _createPopupPositionStrategy() { return this._overlay.position().flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin()).withTransformOriginOn(".mat-datepicker-content").withFlexibleDimensions(!1).withViewportMargin(8).withLockedPosition().withPositions([{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom" }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom" }]) } _getValidDateOrNull(t) { return this._dateAdapter.isDateInstance(t) && this._dateAdapter.isValid(t) ? t : null } } return t.\u0275fac = function(e) { return new(e || t)(Sa(LA), Sa(JD), Sa(Pc), Sa(bl), Sa(vI), Sa(kS, 8), Sa(Rw, 8), Sa(uh, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-datepicker"]
            ], inputs: { startView: "startView", startAt: "startAt", color: "color", touchUi: "touchUi", disabled: "disabled", opened: "opened", calendarHeaderComponent: "calendarHeaderComponent", panelClass: "panelClass", dateClass: "dateClass" }, outputs: { yearSelected: "yearSelected", monthSelected: "monthSelected", openedStream: "opened", closedStream: "closed" }, exportAs: ["matDatepicker"], decls: 0, vars: 0, template: function(t, e) {}, encapsulation: 2, changeDetection: 0 }), t })();
    const EI = { provide: vg, useExisting: St(() => II), multi: !0 }, DI = { provide: Fg, useExisting: St(() => II), multi: !0 }; class AI { constructor(t, e) { this.target = t, this.targetElement = e, this.value = this.target.value } }
    let II = (() => { class t { constructor(t, e, i, n) { if (this._elementRef = t, this._dateAdapter = e, this._dateFormats = i, this._formField = n, this.dateChange = new jl, this.dateInput = new jl, this._valueChange = new jl, this._disabledChange = new jl, this._onTouched = () => {}, this._cvaOnChange = () => {}, this._validatorOnChange = () => {}, this._datepickerSubscription = d.EMPTY, this._localeSubscription = d.EMPTY, this._parseValidator = () => this._lastValueValid ? null : { matDatepickerParse: { text: this._elementRef.nativeElement.value } }, this._minValidator = t => { const e = this._getValidDateOrNull(this._dateAdapter.deserialize(t.value)); return !this.min || !e || this._dateAdapter.compareDate(this.min, e) <= 0 ? null : { matDatepickerMin: { min: this.min, actual: e } } }, this._maxValidator = t => { const e = this._getValidDateOrNull(this._dateAdapter.deserialize(t.value)); return !this.max || !e || this._dateAdapter.compareDate(this.max, e) >= 0 ? null : { matDatepickerMax: { max: this.max, actual: e } } }, this._filterValidator = t => { const e = this._getValidDateOrNull(this._dateAdapter.deserialize(t.value)); return this._dateFilter && e && !this._dateFilter(e) ? { matDatepickerFilter: !0 } : null }, this._validator = Bg.compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]), this._lastValueValid = !1, !this._dateAdapter) throw aI("DateAdapter"); if (!this._dateFormats) throw aI("MAT_DATE_FORMATS");
                this._localeSubscription = e.localeChanges.subscribe(() => { this.value = this.value }) } set matDatepicker(t) { t && (this._datepicker = t, this._datepicker._registerInput(this), this._datepickerSubscription.unsubscribe(), this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(t => { this.value = t, this._cvaOnChange(t), this._onTouched(), this.dateInput.emit(new AI(this, this._elementRef.nativeElement)), this.dateChange.emit(new AI(this, this._elementRef.nativeElement)) })) } set matDatepickerFilter(t) { this._dateFilter = t, this._validatorOnChange() } get value() { return this._value } set value(t) { t = this._dateAdapter.deserialize(t), this._lastValueValid = !t || this._dateAdapter.isValid(t), t = this._getValidDateOrNull(t); const e = this.value;
                this._value = t, this._formatValue(t), this._dateAdapter.sameDate(e, t) || this._valueChange.emit(t) } get min() { return this._min } set min(t) { this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(t)), this._validatorOnChange() } get max() { return this._max } set max(t) { this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(t)), this._validatorOnChange() } get disabled() { return !!this._disabled } set disabled(t) { const e = Vv(t),
                    i = this._elementRef.nativeElement;
                this._disabled !== e && (this._disabled = e, this._disabledChange.emit(e)), e && i.blur && i.blur() } ngOnDestroy() { this._datepickerSubscription.unsubscribe(), this._localeSubscription.unsubscribe(), this._valueChange.complete(), this._disabledChange.complete() } registerOnValidatorChange(t) { this._validatorOnChange = t } validate(t) { return this._validator ? this._validator(t) : null } getPopupConnectionElementRef() { return this.getConnectedOverlayOrigin() } getConnectedOverlayOrigin() { return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef } writeValue(t) { this.value = t } registerOnChange(t) { this._cvaOnChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t } _onKeydown(t) { this._datepicker && t.altKey && 40 === t.keyCode && !this._elementRef.nativeElement.readOnly && (this._datepicker.open(), t.preventDefault()) } _onInput(t) { const e = this._lastValueValid; let i = this._dateAdapter.parse(t, this._dateFormats.parse.dateInput);
                this._lastValueValid = !i || this._dateAdapter.isValid(i), i = this._getValidDateOrNull(i), this._dateAdapter.sameDate(i, this._value) ? e !== this._lastValueValid && this._validatorOnChange() : (this._value = i, this._cvaOnChange(i), this._valueChange.emit(i), this.dateInput.emit(new AI(this, this._elementRef.nativeElement))) } _onChange() { this.dateChange.emit(new AI(this, this._elementRef.nativeElement)) } _getThemePalette() { return this._formField ? this._formField.color : void 0 } _onBlur() { this.value && this._formatValue(this.value), this._onTouched() } _formatValue(t) { this._elementRef.nativeElement.value = t ? this._dateAdapter.format(t, this._dateFormats.display.dateInput) : "" } _getValidDateOrNull(t) { return this._dateAdapter.isDateInstance(t) && this._dateAdapter.isValid(t) ? t : null } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(kS, 8), Sa(ES, 8), Sa(IE, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "matDatepicker", ""]
            ], hostVars: 5, hostBindings: function(t, e) { 1 & t && Ba("input", (function(t) { return e._onInput(t.target.value) }))("change", (function() { return e._onChange() }))("blur", (function() { return e._onBlur() }))("keydown", (function(t) { return e._onKeydown(t) })), 2 & t && (xo("disabled", e.disabled), va("aria-haspopup", e._datepicker ? "dialog" : null)("aria-owns", (null == e._datepicker ? null : e._datepicker.opened) && e._datepicker.id || null)("min", e.min ? e._dateAdapter.toIso8601(e.min) : null)("max", e.max ? e._dateAdapter.toIso8601(e.max) : null)) }, inputs: { value: "value", matDatepicker: "matDatepicker", matDatepickerFilter: "matDatepickerFilter", min: "min", max: "max", disabled: "disabled" }, outputs: { dateChange: "dateChange", dateInput: "dateInput" }, exportAs: ["matDatepickerInput"], features: [Ho([EI, DI, { provide: PE, useExisting: t }])] }), t })(), TI = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matDatepickerToggleIcon", ""]
            ] }), t })(), OI = (() => { class t { constructor(t, e, i) { this._intl = t, this._changeDetectorRef = e, this._stateChanges = d.EMPTY; const n = Number(i);
                this.tabIndex = n || 0 === n ? n : null } get disabled() { return void 0 === this._disabled && this.datepicker ? this.datepicker.disabled : !!this._disabled } set disabled(t) { this._disabled = Vv(t) } ngOnChanges(t) { t.datepicker && this._watchStateChanges() } ngOnDestroy() { this._stateChanges.unsubscribe() } ngAfterContentInit() { this._watchStateChanges() } _open(t) { this.datepicker && !this.disabled && (this.datepicker.open(), t.stopPropagation()) } _watchStateChanges() { const t = this.datepicker ? this.datepicker._disabledChange : Mu(),
                    e = this.datepicker && this.datepicker._datepickerInput ? this.datepicker._datepickerInput._disabledChange : Mu(),
                    i = this.datepicker ? q(this.datepicker.openedStream, this.datepicker.closedStream) : Mu();
                this._stateChanges.unsubscribe(), this._stateChanges = q(this._intl.changes, t, e, i).subscribe(() => this._changeDetectorRef.markForCheck()) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(oI), Sa(jr), ka("tabindex")) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-datepicker-toggle"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, TI, !0), 2 & t && tc(n = oc()) && (e._customIcon = n.first) }, viewQuery: function(t, e) { var i;
                1 & t && ic(iI, !0), 2 & t && tc(i = oc()) && (e._button = i.first) }, hostAttrs: [1, "mat-datepicker-toggle"], hostVars: 7, hostBindings: function(t, e) { 1 & t && Ba("focus", (function() { return e._button.focus() })), 2 & t && (va("tabindex", e.disabled ? null : -1), no("mat-datepicker-toggle-active", e.datepicker && e.datepicker.opened)("mat-accent", e.datepicker && "accent" === e.datepicker.color)("mat-warn", e.datepicker && "warn" === e.datepicker.color)) }, inputs: { tabIndex: "tabIndex", disabled: "disabled", datepicker: ["for", "datepicker"], disableRipple: "disableRipple" }, exportAs: ["matDatepickerToggle"], features: [Ro], ngContentSelectors: rI, decls: 4, vars: 6, consts: [
                ["mat-icon-button", "", "type", "button", 3, "disabled", "disableRipple", "click"],
                ["button", ""],
                ["class", "mat-datepicker-toggle-default-icon", "viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 4, "ngIf"],
                ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "fill", "currentColor", "focusable", "false", 1, "mat-datepicker-toggle-default-icon"],
                ["d", "M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"]
            ], template: function(t, e) { 1 & t && ($a(sI), Ia(0, "button", 0, 1), Ba("click", (function(t) { return e._open(t) })), Ca(2, nI, 2, 0, "svg", 2), Wa(3), Ta()), 2 & t && (Da("disabled", e.disabled)("disableRipple", e.disableRipple), va("aria-haspopup", e.datepicker ? "dialog" : null)("aria-label", e._intl.openCalendarLabel)("tabindex", e.disabled ? -1 : e.tabIndex), ps(2), Da("ngIf", !e._customIcon)) }, directives: [fk, yd], styles: [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}\n"], encapsulation: 2, changeDetection: 0 }), t })(), RI = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [oI, wI], imports: [
                [Jd, _k, GA, rA, Tw, ED]
            ] }), t })();
    const MI = ["input"], PI = function() { return { enterDuration: 150 } }, FI = ["*"], NI = new Vt("mat-radio-default-options", { providedIn: "root", factory: function() { return { color: "accent" } } });
    let LI = 0;
    const BI = { provide: vg, useExisting: St(() => zI), multi: !0 }; class VI { constructor(t, e) { this.source = t, this.value = e } }
    let zI = (() => { class t { constructor(t) { this._changeDetector = t, this._value = null, this._name = `mat-radio-group-${LI++}`, this._selected = null, this._isInitialized = !1, this._labelPosition = "after", this._disabled = !1, this._required = !1, this._controlValueAccessorChangeFn = () => {}, this.onTouched = () => {}, this.change = new jl } get name() { return this._name } set name(t) { this._name = t, this._updateRadioButtonNames() } get labelPosition() { return this._labelPosition } set labelPosition(t) { this._labelPosition = "before" === t ? "before" : "after", this._markRadiosForCheck() } get value() { return this._value } set value(t) { this._value !== t && (this._value = t, this._updateSelectedRadioFromValue(), this._checkSelectedRadioButton()) } _checkSelectedRadioButton() { this._selected && !this._selected.checked && (this._selected.checked = !0) } get selected() { return this._selected } set selected(t) { this._selected = t, this.value = t ? t.value : null, this._checkSelectedRadioButton() } get disabled() { return this._disabled } set disabled(t) { this._disabled = Vv(t), this._markRadiosForCheck() } get required() { return this._required } set required(t) { this._required = Vv(t), this._markRadiosForCheck() } ngAfterContentInit() { this._isInitialized = !0 } _touch() { this.onTouched && this.onTouched() } _updateRadioButtonNames() { this._radios && this._radios.forEach(t => { t.name = this.name, t._markForCheck() }) } _updateSelectedRadioFromValue() { this._radios && (null === this._selected || this._selected.value !== this._value) && (this._selected = null, this._radios.forEach(t => { t.checked = this.value === t.value, t.checked && (this._selected = t) })) } _emitChangeEvent() { this._isInitialized && this.change.emit(new VI(this._selected, this._value)) } _markRadiosForCheck() { this._radios && this._radios.forEach(t => t._markForCheck()) } writeValue(t) { this.value = t, this._changeDetector.markForCheck() } registerOnChange(t) { this._controlValueAccessorChangeFn = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this.disabled = t, this._changeDetector.markForCheck() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jr)) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-radio-group"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, jI, !0), 2 & t && tc(n = oc()) && (e._radios = n) }, hostAttrs: ["role", "radiogroup", 1, "mat-radio-group"], inputs: { name: "name", labelPosition: "labelPosition", value: "value", selected: "selected", disabled: "disabled", required: "required", color: "color" }, outputs: { change: "change" }, exportAs: ["matRadioGroup"], features: [Ho([BI])] }), t })(); class UI { constructor(t) { this._elementRef = t } }
    const HI = vS(wS(UI));
    let jI = (() => { class t extends HI { constructor(t, e, i, n, s, r, a) { super(e), this._changeDetector = i, this._focusMonitor = n, this._radioDispatcher = s, this._animationMode = r, this._providerOverride = a, this._uniqueId = `mat-radio-${++LI}`, this.id = this._uniqueId, this.change = new jl, this._checked = !1, this._value = null, this._removeUniqueSelectionListener = () => {}, this.radioGroup = t, this._removeUniqueSelectionListener = s.listen((t, e) => { t !== this.id && e === this.name && (this.checked = !1) }) } get checked() { return this._checked } set checked(t) { const e = Vv(t);
                this._checked !== e && (this._checked = e, e && this.radioGroup && this.radioGroup.value !== this.value ? this.radioGroup.selected = this : !e && this.radioGroup && this.radioGroup.value === this.value && (this.radioGroup.selected = null), e && this._radioDispatcher.notify(this.id, this.name), this._changeDetector.markForCheck()) } get value() { return this._value } set value(t) { this._value !== t && (this._value = t, null !== this.radioGroup && (this.checked || (this.checked = this.radioGroup.value === t), this.checked && (this.radioGroup.selected = this))) } get labelPosition() { return this._labelPosition || this.radioGroup && this.radioGroup.labelPosition || "after" } set labelPosition(t) { this._labelPosition = t } get disabled() { return this._disabled || null !== this.radioGroup && this.radioGroup.disabled } set disabled(t) { this._setDisabled(Vv(t)) } get required() { return this._required || this.radioGroup && this.radioGroup.required } set required(t) { this._required = Vv(t) } get color() { return this._color || this.radioGroup && this.radioGroup.color || this._providerOverride && this._providerOverride.color || "accent" } set color(t) { this._color = t } get inputId() { return `${this.id||this._uniqueId}-input` } focus(t) { this._focusMonitor.focusVia(this._inputElement, "keyboard", t) } _markForCheck() { this._changeDetector.markForCheck() } ngOnInit() { this.radioGroup && (this.checked = this.radioGroup.value === this._value, this.name = this.radioGroup.name) } ngAfterViewInit() { this._focusMonitor.monitor(this._elementRef, !0).subscribe(t => {!t && this.radioGroup && this.radioGroup._touch() }) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef), this._removeUniqueSelectionListener() } _emitChangeEvent() { this.change.emit(new VI(this, this._value)) } _isRippleDisabled() { return this.disableRipple || this.disabled } _onInputClick(t) { t.stopPropagation() } _onInputChange(t) { t.stopPropagation(); const e = this.radioGroup && this.value !== this.radioGroup.value;
                this.checked = !0, this._emitChangeEvent(), this.radioGroup && (this.radioGroup._controlValueAccessorChangeFn(this.value), e && this.radioGroup._emitChangeEvent()) } _setDisabled(t) { this._disabled !== t && (this._disabled = t, this._changeDetector.markForCheck()) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(zI, 8), Sa(Wo), Sa(jr), Sa(Ew), Sa(hD), Sa(aS, 8), Sa(NI, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-radio-button"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(MI, !0), 2 & t && tc(i = oc()) && (e._inputElement = i.first) }, hostAttrs: [1, "mat-radio-button"], hostVars: 17, hostBindings: function(t, e) { 1 & t && Ba("focus", (function() { return e._inputElement.nativeElement.focus() })), 2 & t && (va("tabindex", -1)("id", e.id)("aria-label", null)("aria-labelledby", null)("aria-describedby", null), no("mat-radio-checked", e.checked)("mat-radio-disabled", e.disabled)("_mat-animation-noopable", "NoopAnimations" === e._animationMode)("mat-primary", "primary" === e.color)("mat-accent", "accent" === e.color)("mat-warn", "warn" === e.color)) }, inputs: { disableRipple: "disableRipple", tabIndex: "tabIndex", id: "id", checked: "checked", value: "value", labelPosition: "labelPosition", disabled: "disabled", required: "required", color: "color", name: "name", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"] }, outputs: { change: "change" }, exportAs: ["matRadioButton"], features: [Eo], ngContentSelectors: FI, decls: 13, vars: 19, consts: [
                [1, "mat-radio-label"],
                ["label", ""],
                [1, "mat-radio-container"],
                [1, "mat-radio-outer-circle"],
                [1, "mat-radio-inner-circle"],
                ["type", "radio", 1, "mat-radio-input", "cdk-visually-hidden", 3, "id", "checked", "disabled", "tabIndex", "required", "change", "click"],
                ["input", ""],
                ["mat-ripple", "", 1, "mat-radio-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered", "matRippleRadius", "matRippleAnimation"],
                [1, "mat-ripple-element", "mat-radio-persistent-ripple"],
                [1, "mat-radio-label-content"],
                [2, "display", "none"]
            ], template: function(t, e) { if (1 & t && ($a(), Ia(0, "label", 0, 1), Ia(2, "div", 2), Oa(3, "div", 3), Oa(4, "div", 4), Ia(5, "input", 5, 6), Ba("change", (function(t) { return e._onInputChange(t) }))("click", (function(t) { return e._onInputClick(t) })), Ta(), Ia(7, "div", 7), Oa(8, "div", 8), Ta(), Ta(), Ia(9, "div", 9), Ia(10, "span", 10), _o(11, "\xa0"), Ta(), Wa(12), Ta(), Ta()), 2 & t) { const t = xa(1);
                    va("for", e.inputId), ps(5), Da("id", e.inputId)("checked", e.checked)("disabled", e.disabled)("tabIndex", e.tabIndex)("required", e.required), va("name", e.name)("value", e.value)("aria-label", e.ariaLabel)("aria-labelledby", e.ariaLabelledby)("aria-describedby", e.ariaDescribedby), ps(2), Da("matRippleTrigger", t)("matRippleDisabled", e._isRippleDisabled())("matRippleCentered", !0)("matRippleRadius", 20)("matRippleAnimation", Ll(18, PI)), ps(2), no("mat-radio-label-before", "before" == e.labelPosition) } }, directives: [qS], styles: [".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;width:20px;transform:scale(0.001)}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-checked .mat-radio-inner-circle{transform:scale(0.5)}.cdk-high-contrast-active .mat-radio-checked .mat-radio-inner-circle{border:solid 10px}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-persistent-ripple,.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple{opacity:0}@media(hover: none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}.cdk-high-contrast-active .mat-radio-disabled{opacity:.5}\n"], encapsulation: 2, changeDetection: 0 }), t })(), GI = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [YS, _S], _S
            ] }), t })();
    const $I = ["trigger"], WI = ["panel"];

    function qI(t, e) { if (1 & t && (Ia(0, "span", 8), _o(1), Ta()), 2 & t) { const t = ja();
            ps(1), bo(t.placeholder || "\xa0") } }

    function YI(t, e) { if (1 & t && (Ia(0, "span"), _o(1), Ta()), 2 & t) { const t = ja(2);
            ps(1), bo(t.triggerValue || "\xa0") } }

    function XI(t, e) { 1 & t && Wa(0, 0, ["*ngSwitchCase", "true"]) }

    function KI(t, e) { 1 & t && (Ia(0, "span", 9), Ca(1, YI, 2, 1, "span", 10), Ca(2, XI, 1, 0, void 0, 11), Ta()), 2 & t && (Da("ngSwitch", !!ja().customTrigger), ps(2), Da("ngSwitchCase", !0)) }

    function ZI(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 12), Ia(1, "div", 13, 14), Ba("@transformPanel.done", (function(e) { return Qe(t), ja()._panelDoneAnimatingStream.next(e.toState) }))("keydown", (function(e) { return Qe(t), ja()._handleKeydown(e) })), Wa(3, 1), Ta(), Ta() } if (2 & t) { const t = ja();
            Da("@transformPanelWrap", void 0), ps(1), Co("mat-select-panel ", t._getPanelTheme(), ""), io("transform-origin", t._transformOrigin)("font-size", t._triggerFontSize, "px"), Da("ngClass", t.panelClass)("@transformPanel", t.multiple ? "showing-multiple" : "showing") } }
    const QI = [
        [
            ["mat-select-trigger"]
        ], "*"
    ], JI = ["mat-select-trigger", "*"], tT = { transformPanelWrap: Lw("transformPanelWrap", [Gw("* => void", Yw("@transformPanel", [Ww()], { optional: !0 }))]), transformPanel: Lw("transformPanel", [Hw("void", Uw({ transform: "scaleY(0.8)", minWidth: "100%", opacity: 0 })), Hw("showing", Uw({ opacity: 1, minWidth: "calc(100% + 32px)", transform: "scaleY(1)" })), Hw("showing-multiple", Uw({ opacity: 1, minWidth: "calc(100% + 64px)", transform: "scaleY(1)" })), Gw("void => *", Bw("120ms cubic-bezier(0, 0, 0.2, 1)")), Gw("* => void", Bw("100ms 25ms linear", Uw({ opacity: 0 })))]) };
    let eT = 0;
    const iT = new Vt("mat-select-scroll-strategy"), nT = new Vt("MAT_SELECT_CONFIG"), sT = { provide: iT, deps: [JD], useFactory: function(t) { return () => t.scrollStrategies.reposition() } }; class rT { constructor(t, e) { this.source = t, this.value = e } } class aT { constructor(t, e, i, n, s) { this._elementRef = t, this._defaultErrorStateMatcher = e, this._parentForm = i, this._parentFormGroup = n, this.ngControl = s } }
    const oT = vS(wS(bS(CS(aT))));
    let lT = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-select-trigger"]
            ] }), t })(), cT = (() => { class t extends oT { constructor(t, e, i, n, s, r, a, o, l, c, h, d, u, m) { super(s, n, a, o, c), this._viewportRuler = t, this._changeDetectorRef = e, this._ngZone = i, this._dir = r, this._parentFormField = l, this.ngControl = c, this._liveAnnouncer = u, this._panelOpen = !1, this._required = !1, this._scrollTop = 0, this._multiple = !1, this._compareWith = (t, e) => t === e, this._uid = `mat-select-${eT++}`, this._destroy = new k, this._triggerFontSize = 0, this._onChange = () => {}, this._onTouched = () => {}, this._optionIds = "", this._transformOrigin = "top", this._panelDoneAnimatingStream = new k, this._offsetY = 0, this._positions = [{ originX: "start", originY: "top", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "bottom", overlayX: "start", overlayY: "bottom" }], this._disableOptionCentering = !1, this._focused = !1, this.controlType = "mat-select", this.ariaLabel = "", this.optionSelectionChanges = Hu(() => { const t = this.options; return t ? t.changes.pipe(bm(t), pm(() => q(...t.map(t => t.onSelectionChange)))) : this._ngZone.onStable.asObservable().pipe(lm(1), pm(() => this.optionSelectionChanges)) }), this.openedChange = new jl, this._openedStream = this.openedChange.pipe(Gu(t => t), L(() => {})), this._closedStream = this.openedChange.pipe(Gu(t => !t), L(() => {})), this.selectionChange = new jl, this.valueChange = new jl, this.ngControl && (this.ngControl.valueAccessor = this), this._scrollStrategyFactory = d, this._scrollStrategy = this._scrollStrategyFactory(), this.tabIndex = parseInt(h) || 0, this.id = this.id, m && (null != m.disableOptionCentering && (this.disableOptionCentering = m.disableOptionCentering), null != m.typeaheadDebounceInterval && (this.typeaheadDebounceInterval = m.typeaheadDebounceInterval)) } get focused() { return this._focused || this._panelOpen } get placeholder() { return this._placeholder } set placeholder(t) { this._placeholder = t, this.stateChanges.next() } get required() { return this._required } set required(t) { this._required = Vv(t), this.stateChanges.next() } get multiple() { return this._multiple } set multiple(t) { if (this._selectionModel) throw Error("Cannot change `multiple` mode of select after initialization.");
                this._multiple = Vv(t) } get disableOptionCentering() { return this._disableOptionCentering } set disableOptionCentering(t) { this._disableOptionCentering = Vv(t) } get compareWith() { return this._compareWith } set compareWith(t) { if ("function" != typeof t) throw Error("`compareWith` must be a function.");
                this._compareWith = t, this._selectionModel && this._initializeSelection() } get value() { return this._value } set value(t) { t !== this._value && (this.writeValue(t), this._value = t) } get typeaheadDebounceInterval() { return this._typeaheadDebounceInterval } set typeaheadDebounceInterval(t) { this._typeaheadDebounceInterval = zv(t) } get id() { return this._id } set id(t) { this._id = t || this._uid, this.stateChanges.next() } ngOnInit() { this._selectionModel = new cD(this.multiple), this.stateChanges.next(), this._panelDoneAnimatingStream.pipe(XE(), jk(this._destroy)).subscribe(() => { this.panelOpen ? (this._scrollTop = 0, this.openedChange.emit(!0)) : (this.openedChange.emit(!1), this.overlayDir.offsetX = 0, this._changeDetectorRef.markForCheck()) }), this._viewportRuler.change().pipe(jk(this._destroy)).subscribe(() => { this._panelOpen && (this._triggerRect = this.trigger.nativeElement.getBoundingClientRect(), this._changeDetectorRef.markForCheck()) }) } ngAfterContentInit() { this._initKeyManager(), this._selectionModel.changed.pipe(jk(this._destroy)).subscribe(t => { t.added.forEach(t => t.select()), t.removed.forEach(t => t.deselect()) }), this.options.changes.pipe(bm(null), jk(this._destroy)).subscribe(() => { this._resetOptions(), this._initializeSelection() }) } ngDoCheck() { this.ngControl && this.updateErrorState() } ngOnChanges(t) { t.disabled && this.stateChanges.next(), t.typeaheadDebounceInterval && this._keyManager && this._keyManager.withTypeAhead(this._typeaheadDebounceInterval) } ngOnDestroy() { this._destroy.next(), this._destroy.complete(), this.stateChanges.complete() } toggle() { this.panelOpen ? this.close() : this.open() } open() {!this.disabled && this.options && this.options.length && !this._panelOpen && (this._triggerRect = this.trigger.nativeElement.getBoundingClientRect(), this._triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement).fontSize || "0"), this._panelOpen = !0, this._keyManager.withHorizontalOrientation(null), this._calculateOverlayPosition(), this._highlightCorrectOption(), this._changeDetectorRef.markForCheck(), this._ngZone.onStable.asObservable().pipe(lm(1)).subscribe(() => { this._triggerFontSize && this.overlayDir.overlayRef && this.overlayDir.overlayRef.overlayElement && (this.overlayDir.overlayRef.overlayElement.style.fontSize = `${this._triggerFontSize}px`) })) } close() { this._panelOpen && (this._panelOpen = !1, this._keyManager.withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr"), this._changeDetectorRef.markForCheck(), this._onTouched()) } writeValue(t) { this.options && this._setSelectionByValue(t) } registerOnChange(t) { this._onChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t, this._changeDetectorRef.markForCheck(), this.stateChanges.next() } get panelOpen() { return this._panelOpen } get selected() { return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0] } get triggerValue() { if (this.empty) return ""; if (this._multiple) { const t = this._selectionModel.selected.map(t => t.viewValue); return this._isRtl() && t.reverse(), t.join(", ") } return this._selectionModel.selected[0].viewValue } _isRtl() { return !!this._dir && "rtl" === this._dir.value } _handleKeydown(t) { this.disabled || (this.panelOpen ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t)) } _handleClosedKeydown(t) { const e = t.keyCode,
                    i = 40 === e || 38 === e || 37 === e || 39 === e,
                    n = 13 === e || 32 === e,
                    s = this._keyManager; if (!s.isTyping() && n && !Iv(t) || (this.multiple || t.altKey) && i) t.preventDefault(), this.open();
                else if (!this.multiple) { const i = this.selected;
                    36 === e || 35 === e ? (36 === e ? s.setFirstItemActive() : s.setLastItemActive(), t.preventDefault()) : s.onKeydown(t); const n = this.selected;
                    n && i !== n && this._liveAnnouncer.announce(n.viewValue, 1e4) } } _handleOpenKeydown(t) { const e = this._keyManager,
                    i = t.keyCode,
                    n = 40 === i || 38 === i,
                    s = e.isTyping(); if (36 === i || 35 === i) t.preventDefault(), 36 === i ? e.setFirstItemActive() : e.setLastItemActive();
                else if (n && t.altKey) t.preventDefault(), this.close();
                else if (s || 13 !== i && 32 !== i || !e.activeItem || Iv(t))
                    if (!s && this._multiple && 65 === i && t.ctrlKey) { t.preventDefault(); const e = this.options.some(t => !t.disabled && !t.selected);
                        this.options.forEach(t => { t.disabled || (e ? t.select() : t.deselect()) }) } else { const i = e.activeItemIndex;
                        e.onKeydown(t), this._multiple && n && t.shiftKey && e.activeItem && e.activeItemIndex !== i && e.activeItem._selectViaInteraction() } else t.preventDefault(), e.activeItem._selectViaInteraction() } _onFocus() { this.disabled || (this._focused = !0, this.stateChanges.next()) } _onBlur() { this._focused = !1, this.disabled || this.panelOpen || (this._onTouched(), this._changeDetectorRef.markForCheck(), this.stateChanges.next()) } _onAttached() { this.overlayDir.positionChange.pipe(lm(1)).subscribe(() => { this._changeDetectorRef.detectChanges(), this._calculateOverlayOffsetX(), this.panel.nativeElement.scrollTop = this._scrollTop }) } _getPanelTheme() { return this._parentFormField ? `mat-${this._parentFormField.color}` : "" } get empty() { return !this._selectionModel || this._selectionModel.isEmpty() } _initializeSelection() { Promise.resolve().then(() => { this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value), this.stateChanges.next() }) } _setSelectionByValue(t) { if (this.multiple && t) { if (!Array.isArray(t)) throw Error("Value must be an array in multiple-selection mode.");
                    this._selectionModel.clear(), t.forEach(t => this._selectValue(t)), this._sortValues() } else { this._selectionModel.clear(); const e = this._selectValue(t);
                    e ? this._keyManager.setActiveItem(e) : this.panelOpen || this._keyManager.setActiveItem(-1) } this._changeDetectorRef.markForCheck() } _selectValue(t) { const e = this.options.find(e => { try { return null != e.value && this._compareWith(e.value, t) } catch (i) { return Sn() && console.warn(i), !1 } }); return e && this._selectionModel.select(e), e } _initKeyManager() { this._keyManager = new uw(this.options).withTypeAhead(this._typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr").withAllowedModifierKeys(["shiftKey"]), this._keyManager.tabOut.pipe(jk(this._destroy)).subscribe(() => {!this.multiple && this._keyManager.activeItem && this._keyManager.activeItem._selectViaInteraction(), this.focus(), this.close() }), this._keyManager.change.pipe(jk(this._destroy)).subscribe(() => { this._panelOpen && this.panel ? this._scrollActiveOptionIntoView() : this._panelOpen || this.multiple || !this._keyManager.activeItem || this._keyManager.activeItem._selectViaInteraction() }) } _resetOptions() { const t = q(this.options.changes, this._destroy);
                this.optionSelectionChanges.pipe(jk(t)).subscribe(t => { this._onSelect(t.source, t.isUserInput), t.isUserInput && !this.multiple && this._panelOpen && (this.close(), this.focus()) }), q(...this.options.map(t => t._stateChanges)).pipe(jk(t)).subscribe(() => { this._changeDetectorRef.markForCheck(), this.stateChanges.next() }), this._setOptionIds() } _onSelect(t, e) { const i = this._selectionModel.isSelected(t);
                null != t.value || this._multiple ? (i !== t.selected && (t.selected ? this._selectionModel.select(t) : this._selectionModel.deselect(t)), e && this._keyManager.setActiveItem(t), this.multiple && (this._sortValues(), e && this.focus())) : (t.deselect(), this._selectionModel.clear(), this._propagateChanges(t.value)), i !== this._selectionModel.isSelected(t) && this._propagateChanges(), this.stateChanges.next() } _sortValues() { if (this.multiple) { const t = this.options.toArray();
                    this._selectionModel.sort((e, i) => this.sortComparator ? this.sortComparator(e, i, t) : t.indexOf(e) - t.indexOf(i)), this.stateChanges.next() } } _propagateChanges(t) { let e = null;
                e = this.multiple ? this.selected.map(t => t.value) : this.selected ? this.selected.value : t, this._value = e, this.valueChange.emit(e), this._onChange(e), this.selectionChange.emit(new rT(this, e)), this._changeDetectorRef.markForCheck() } _setOptionIds() { this._optionIds = this.options.map(t => t.id).join(" ") } _highlightCorrectOption() { this._keyManager && (this.empty ? this._keyManager.setFirstItemActive() : this._keyManager.setActiveItem(this._selectionModel.selected[0])) } _scrollActiveOptionIntoView() { const t = this._keyManager.activeItemIndex || 0,
                    e = ak(t, this.options, this.optionGroups);
                this.panel.nativeElement.scrollTop = ok(t + e, this._getItemHeight(), this.panel.nativeElement.scrollTop, 256) } focus(t) { this._elementRef.nativeElement.focus(t) } _getOptionIndex(t) { return this.options.reduce((e, i, n) => void 0 !== e ? e : t === i ? n : void 0, void 0) } _calculateOverlayPosition() { const t = this._getItemHeight(),
                    e = this._getItemCount(),
                    i = Math.min(e * t, 256),
                    n = e * t - i; let s = this.empty ? 0 : this._getOptionIndex(this._selectionModel.selected[0]);
                s += ak(s, this.options, this.optionGroups); const r = i / 2;
                this._scrollTop = this._calculateOverlayScroll(s, r, n), this._offsetY = this._calculateOverlayOffsetY(s, r, n), this._checkOverlayWithinViewport(n) } _calculateOverlayScroll(t, e, i) { const n = this._getItemHeight(); return Math.min(Math.max(0, n * t - e + n / 2), i) } _getAriaLabel() { return this.ariaLabelledby ? null : this.ariaLabel || this.placeholder } _getAriaLabelledby() { return this.ariaLabelledby ? this.ariaLabelledby : this._parentFormField && this._parentFormField._hasFloatingLabel() && !this._getAriaLabel() && this._parentFormField._labelId || null } _getAriaActiveDescendant() { return this.panelOpen && this._keyManager && this._keyManager.activeItem ? this._keyManager.activeItem.id : null } _calculateOverlayOffsetX() { const t = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect(),
                    e = this._viewportRuler.getViewportSize(),
                    i = this._isRtl(),
                    n = this.multiple ? 56 : 32; let s; if (this.multiple) s = 40;
                else { let t = this._selectionModel.selected[0] || this.options.first;
                    s = t && t.group ? 32 : 16 } i || (s *= -1); const r = 0 - (t.left + s - (i ? n : 0)),
                    a = t.right + s - e.width + (i ? 0 : n);
                r > 0 ? s += r + 8 : a > 0 && (s -= a + 8), this.overlayDir.offsetX = Math.round(s), this.overlayDir.overlayRef.updatePosition() } _calculateOverlayOffsetY(t, e, i) { const n = this._getItemHeight(),
                    s = (n - this._triggerRect.height) / 2,
                    r = Math.floor(256 / n); let a; return this._disableOptionCentering ? 0 : (a = 0 === this._scrollTop ? t * n : this._scrollTop === i ? (t - (this._getItemCount() - r)) * n + (n - (this._getItemCount() * n - 256) % n) : e - n / 2, Math.round(-1 * a - s)) } _checkOverlayWithinViewport(t) { const e = this._getItemHeight(),
                    i = this._viewportRuler.getViewportSize(),
                    n = this._triggerRect.top - 8,
                    s = i.height - this._triggerRect.bottom - 8,
                    r = Math.abs(this._offsetY),
                    a = Math.min(this._getItemCount() * e, 256) - r - this._triggerRect.height;
                a > s ? this._adjustPanelUp(a, s) : r > n ? this._adjustPanelDown(r, n, t) : this._transformOrigin = this._getOriginBasedOnOption() } _adjustPanelUp(t, e) { const i = Math.round(t - e);
                this._scrollTop -= i, this._offsetY -= i, this._transformOrigin = this._getOriginBasedOnOption(), this._scrollTop <= 0 && (this._scrollTop = 0, this._offsetY = 0, this._transformOrigin = "50% bottom 0px") } _adjustPanelDown(t, e, i) { const n = Math.round(t - e); if (this._scrollTop += n, this._offsetY += n, this._transformOrigin = this._getOriginBasedOnOption(), this._scrollTop >= i) return this._scrollTop = i, this._offsetY = 0, void(this._transformOrigin = "50% top 0px") } _getOriginBasedOnOption() { const t = this._getItemHeight(),
                    e = (t - this._triggerRect.height) / 2; return `50% ${Math.abs(this._offsetY)-e+t/2}px 0px` } _getItemCount() { return this.options.length + this.optionGroups.length } _getItemHeight() { return 3 * this._triggerFontSize } setDescribedByIds(t) { this._ariaDescribedby = t.join(" ") } onContainerClick() { this.focus(), this.open() } get shouldLabelFloat() { return this._panelOpen || !this.empty } } return t.\u0275fac = function(e) { return new(e || t)(Sa(mD), Sa(jr), Sa(Pc), Sa(LS), Sa(Wo), Sa(Rw, 8), Sa(R_, 8), Sa(W_, 8), Sa(IE, 8), Sa(Tg, 10), ka("tabindex"), Sa(iT), Sa(Cw), Sa(nT, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-select"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, lT, !0), sc(i, rk, !0), sc(i, tk, !0)), 2 & t && (tc(n = oc()) && (e.customTrigger = n.first), tc(n = oc()) && (e.options = n), tc(n = oc()) && (e.optionGroups = n)) }, viewQuery: function(t, e) { var i;
                1 & t && (ic($I, !0), ic(WI, !0), ic(nA, !0)), 2 & t && (tc(i = oc()) && (e.trigger = i.first), tc(i = oc()) && (e.panel = i.first), tc(i = oc()) && (e.overlayDir = i.first)) }, hostAttrs: ["role", "listbox", 1, "mat-select"], hostVars: 19, hostBindings: function(t, e) { 1 & t && Ba("keydown", (function(t) { return e._handleKeydown(t) }))("focus", (function() { return e._onFocus() }))("blur", (function() { return e._onBlur() })), 2 & t && (va("id", e.id)("tabindex", e.tabIndex)("aria-label", e._getAriaLabel())("aria-labelledby", e._getAriaLabelledby())("aria-required", e.required.toString())("aria-disabled", e.disabled.toString())("aria-invalid", e.errorState)("aria-owns", e.panelOpen ? e._optionIds : null)("aria-multiselectable", e.multiple)("aria-describedby", e._ariaDescribedby || null)("aria-activedescendant", e._getAriaActiveDescendant()), no("mat-select-disabled", e.disabled)("mat-select-invalid", e.errorState)("mat-select-required", e.required)("mat-select-empty", e.empty)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex", ariaLabel: ["aria-label", "ariaLabel"], id: "id", disableOptionCentering: "disableOptionCentering", typeaheadDebounceInterval: "typeaheadDebounceInterval", placeholder: "placeholder", required: "required", multiple: "multiple", compareWith: "compareWith", value: "value", panelClass: "panelClass", ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], errorStateMatcher: "errorStateMatcher", sortComparator: "sortComparator" }, outputs: { openedChange: "openedChange", _openedStream: "opened", _closedStream: "closed", selectionChange: "selectionChange", valueChange: "valueChange" }, exportAs: ["matSelect"], features: [Ho([{ provide: _E, useExisting: t }, { provide: sk, useExisting: t }]), Eo, Ro], ngContentSelectors: JI, decls: 9, vars: 9, consts: [
                ["cdk-overlay-origin", "", "aria-hidden", "true", 1, "mat-select-trigger", 3, "click"],
                ["origin", "cdkOverlayOrigin", "trigger", ""],
                [1, "mat-select-value", 3, "ngSwitch"],
                ["class", "mat-select-placeholder", 4, "ngSwitchCase"],
                ["class", "mat-select-value-text", 3, "ngSwitch", 4, "ngSwitchCase"],
                [1, "mat-select-arrow-wrapper"],
                [1, "mat-select-arrow"],
                ["cdk-connected-overlay", "", "cdkConnectedOverlayLockPosition", "", "cdkConnectedOverlayHasBackdrop", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", 3, "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayOffsetY", "backdropClick", "attach", "detach"],
                [1, "mat-select-placeholder"],
                [1, "mat-select-value-text", 3, "ngSwitch"],
                [4, "ngSwitchDefault"],
                [4, "ngSwitchCase"],
                [1, "mat-select-panel-wrap"],
                [3, "ngClass", "keydown"],
                ["panel", ""]
            ], template: function(t, e) { if (1 & t && ($a(QI), Ia(0, "div", 0, 1), Ba("click", (function() { return e.toggle() })), Ia(3, "div", 2), Ca(4, qI, 2, 1, "span", 3), Ca(5, KI, 3, 2, "span", 4), Ta(), Ia(6, "div", 5), Oa(7, "div", 6), Ta(), Ta(), Ca(8, ZI, 4, 10, "ng-template", 7), Ba("backdropClick", (function() { return e.close() }))("attach", (function() { return e._onAttached() }))("detach", (function() { return e.close() }))), 2 & t) { const t = xa(1);
                    ps(3), Da("ngSwitch", e.empty), ps(1), Da("ngSwitchCase", !0), ps(1), Da("ngSwitchCase", !1), ps(3), Da("cdkConnectedOverlayScrollStrategy", e._scrollStrategy)("cdkConnectedOverlayOrigin", t)("cdkConnectedOverlayOpen", e.panelOpen)("cdkConnectedOverlayPositions", e._positions)("cdkConnectedOverlayMinWidth", null == e._triggerRect ? null : e._triggerRect.width)("cdkConnectedOverlayOffsetY", e._offsetY) } }, directives: [iA, xd, Sd, nA, kd, pd], styles: [".mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}\n"], encapsulation: 2, data: { animation: [tT.transformPanelWrap, tT.transformPanel] }, changeDetection: 0 }), t })(), hT = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [sT], imports: [
                [Jd, rA, lk, _S], OE, lk, _S
            ] }), t })();
    const dT = ["sliderWrapper"], uT = Jv({ passive: !1 }), mT = { provide: vg, useExisting: St(() => _T), multi: !0 }; class pT {} class fT { constructor(t) { this._elementRef = t } }
    const gT = wS(yS(bS(fT), "accent"));
    let _T = (() => { class t extends gT { constructor(t, e, i, n, s, r, a, o) { super(t), this._focusMonitor = e, this._changeDetectorRef = i, this._dir = n, this._animationMode = r, this._ngZone = a, this._invert = !1, this._max = 100, this._min = 0, this._step = 1, this._thumbLabel = !1, this._tickInterval = 0, this._value = null, this._vertical = !1, this.change = new jl, this.input = new jl, this.valueChange = new jl, this.onTouched = () => {}, this._percent = 0, this._isSliding = !1, this._isActive = !1, this._tickIntervalPercent = 0, this._sliderDimensions = null, this._controlValueAccessorChangeFn = () => {}, this._dirChangeSubscription = d.EMPTY, this._pointerDown = t => { this.disabled || this._isSliding || !bT(t) && 0 !== t.button || this._runInsideZone(() => { const e = this.value,
                            i = yT(t);
                        this._isSliding = !0, this._lastPointerEvent = t, t.preventDefault(), this._focusHostElement(), this._onMouseenter(), this._bindGlobalEvents(t), this._focusHostElement(), this._updateValueFromPosition(i), this._valueOnSlideStart = this.value, this._pointerPositionOnStart = i, e != this.value && (this._emitInputEvent(), this._emitChangeEvent()) }) }, this._pointerMove = t => { if (this._isSliding) { t.preventDefault(); const e = this.value;
                        this._lastPointerEvent = t, this._updateValueFromPosition(yT(t)), e != this.value && this._emitInputEvent() } }, this._pointerUp = t => { if (this._isSliding) { const e = this._pointerPositionOnStart,
                            i = yT(t);
                        t.preventDefault(), this._removeGlobalEvents(), this._valueOnSlideStart = this._pointerPositionOnStart = this._lastPointerEvent = null, this._isSliding = !1, this._valueOnSlideStart == this.value || this.disabled || !e || e.x === i.x && e.y === i.y || this._emitChangeEvent() } }, this._windowBlur = () => { this._lastPointerEvent && this._pointerUp(this._lastPointerEvent) }, this._document = o, this.tabIndex = parseInt(s) || 0, this._runOutsizeZone(() => { const e = t.nativeElement;
                    e.addEventListener("mousedown", this._pointerDown, uT), e.addEventListener("touchstart", this._pointerDown, uT) }) } get invert() { return this._invert } set invert(t) { this._invert = Vv(t) } get max() { return this._max } set max(t) { this._max = zv(t, this._max), this._percent = this._calculatePercentage(this._value), this._changeDetectorRef.markForCheck() } get min() { return this._min } set min(t) { this._min = zv(t, this._min), null === this._value && (this.value = this._min), this._percent = this._calculatePercentage(this._value), this._changeDetectorRef.markForCheck() } get step() { return this._step } set step(t) { this._step = zv(t, this._step), this._step % 1 != 0 && (this._roundToDecimal = this._step.toString().split(".").pop().length), this._changeDetectorRef.markForCheck() } get thumbLabel() { return this._thumbLabel } set thumbLabel(t) { this._thumbLabel = Vv(t) } get tickInterval() { return this._tickInterval } set tickInterval(t) { this._tickInterval = "auto" === t ? "auto" : "number" == typeof t || "string" == typeof t ? zv(t, this._tickInterval) : 0 } get value() { return null === this._value && (this.value = this._min), this._value } set value(t) { if (t !== this._value) { let e = zv(t);
                    this._roundToDecimal && (e = parseFloat(e.toFixed(this._roundToDecimal))), this._value = e, this._percent = this._calculatePercentage(this._value), this._changeDetectorRef.markForCheck() } } get vertical() { return this._vertical } set vertical(t) { this._vertical = Vv(t) } get displayValue() { return this.displayWith ? this.displayWith(this.value) : this._roundToDecimal && this.value && this.value % 1 != 0 ? this.value.toFixed(this._roundToDecimal) : this.value || 0 } focus(t) { this._focusHostElement(t) } blur() { this._blurHostElement() } get percent() { return this._clamp(this._percent) } get _invertAxis() { return this.vertical ? !this.invert : this.invert } get _isMinValue() { return 0 === this.percent } get _thumbGap() { return this.disabled ? 7 : this._isMinValue && !this.thumbLabel ? this._isActive ? 10 : 7 : 0 } get _trackBackgroundStyles() { const t = this.vertical ? `1, ${1-this.percent}, 1` : `${1-this.percent}, 1, 1`; return { transform: `translate${this.vertical?"Y":"X"}(${this._shouldInvertMouseCoords()?"-":""}${this._thumbGap}px) scale3d(${t})` } } get _trackFillStyles() { const t = this.percent,
                    e = this.vertical ? `1, ${t}, 1` : `${t}, 1, 1`; return { transform: `translate${this.vertical?"Y":"X"}(${this._shouldInvertMouseCoords()?"":"-"}${this._thumbGap}px) scale3d(${e})`, display: 0 === t ? "none" : "" } } get _ticksContainerStyles() { return { transform: `translate${this.vertical?"Y":"X"}(${this.vertical||"rtl"!=this._getDirection()?"-":""}${this._tickIntervalPercent/2*100}%)` } } get _ticksStyles() { let t = 100 * this._tickIntervalPercent,
                    e = { backgroundSize: this.vertical ? `2px ${t}%` : `${t}% 2px`, transform: `translateZ(0) translate${this.vertical?"Y":"X"}(${this.vertical||"rtl"!=this._getDirection()?"":"-"}${t/2}%)${this.vertical||"rtl"!=this._getDirection()?"":" rotate(180deg)"}` }; if (this._isMinValue && this._thumbGap) { let t;
                    t = this.vertical ? this._invertAxis ? "Bottom" : "Top" : this._invertAxis ? "Right" : "Left", e[`padding${t}`] = `${this._thumbGap}px` } return e } get _thumbContainerStyles() { return { transform: `translate${this.vertical?"Y":"X"}(-${100*(("rtl"!=this._getDirection()||this.vertical?this._invertAxis:!this._invertAxis)?this.percent:1-this.percent)}%)` } } _shouldInvertMouseCoords() { return "rtl" != this._getDirection() || this.vertical ? this._invertAxis : !this._invertAxis } _getDirection() { return this._dir && "rtl" == this._dir.value ? "rtl" : "ltr" } ngOnInit() { this._focusMonitor.monitor(this._elementRef, !0).subscribe(t => { this._isActive = !!t && "keyboard" !== t, this._changeDetectorRef.detectChanges() }), this._dir && (this._dirChangeSubscription = this._dir.change.subscribe(() => { this._changeDetectorRef.markForCheck() })) } ngOnDestroy() { const t = this._elementRef.nativeElement;
                t.removeEventListener("mousedown", this._pointerDown, uT), t.removeEventListener("touchstart", this._pointerDown, uT), this._lastPointerEvent = null, this._removeGlobalEvents(), this._focusMonitor.stopMonitoring(this._elementRef), this._dirChangeSubscription.unsubscribe() } _onMouseenter() { this.disabled || (this._sliderDimensions = this._getSliderDimensions(), this._updateTickIntervalPercent()) } _onFocus() { this._sliderDimensions = this._getSliderDimensions(), this._updateTickIntervalPercent() } _onBlur() { this.onTouched() } _onKeydown(t) { if (this.disabled || Iv(t)) return; const e = this.value; switch (t.keyCode) {
                    case 33:
                        this._increment(10); break;
                    case 34:
                        this._increment(-10); break;
                    case 35:
                        this.value = this.max; break;
                    case 36:
                        this.value = this.min; break;
                    case 37:
                        this._increment("rtl" == this._getDirection() ? 1 : -1); break;
                    case 38:
                        this._increment(1); break;
                    case 39:
                        this._increment("rtl" == this._getDirection() ? -1 : 1); break;
                    case 40:
                        this._increment(-1); break;
                    default:
                        return } e != this.value && (this._emitInputEvent(), this._emitChangeEvent()), this._isSliding = !0, t.preventDefault() } _onKeyup() { this._isSliding = !1 } _getWindow() { var t; return (null === (t = this._document) || void 0 === t ? void 0 : t.defaultView) || window } _bindGlobalEvents(t) { if (void 0 !== this._document && this._document) { const e = this._document.body,
                        i = bT(t),
                        n = i ? "touchend" : "mouseup";
                    e.addEventListener(i ? "touchmove" : "mousemove", this._pointerMove, uT), e.addEventListener(n, this._pointerUp, uT), i && e.addEventListener("touchcancel", this._pointerUp, uT) } const e = this._getWindow();
                void 0 !== e && e && e.addEventListener("blur", this._windowBlur) } _removeGlobalEvents() { if (void 0 !== this._document && this._document) { const t = this._document.body;
                    t.removeEventListener("mousemove", this._pointerMove, uT), t.removeEventListener("mouseup", this._pointerUp, uT), t.removeEventListener("touchmove", this._pointerMove, uT), t.removeEventListener("touchend", this._pointerUp, uT), t.removeEventListener("touchcancel", this._pointerUp, uT) } const t = this._getWindow();
                void 0 !== t && t && t.removeEventListener("blur", this._windowBlur) } _increment(t) { this.value = this._clamp((this.value || 0) + this.step * t, this.min, this.max) } _updateValueFromPosition(t) { if (!this._sliderDimensions) return; let e = this._clamp(((this.vertical ? t.y : t.x) - (this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left)) / (this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width)); if (this._shouldInvertMouseCoords() && (e = 1 - e), 0 === e) this.value = this.min;
                else if (1 === e) this.value = this.max;
                else { const t = this._calculateValue(e),
                        i = Math.round((t - this.min) / this.step) * this.step + this.min;
                    this.value = this._clamp(i, this.min, this.max) } } _emitChangeEvent() { this._controlValueAccessorChangeFn(this.value), this.valueChange.emit(this.value), this.change.emit(this._createChangeEvent()) } _emitInputEvent() { this.input.emit(this._createChangeEvent()) } _updateTickIntervalPercent() { if (this.tickInterval && this._sliderDimensions)
                    if ("auto" == this.tickInterval) { let t = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width,
                            e = Math.ceil(30 / (t * this.step / (this.max - this.min)));
                        this._tickIntervalPercent = e * this.step / t } else this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min) } _createChangeEvent(t = this.value) { let e = new pT; return e.source = this, e.value = t, e } _calculatePercentage(t) { return ((t || 0) - this.min) / (this.max - this.min) } _calculateValue(t) { return this.min + t * (this.max - this.min) } _clamp(t, e = 0, i = 1) { return Math.max(e, Math.min(t, i)) } _getSliderDimensions() { return this._sliderWrapper ? this._sliderWrapper.nativeElement.getBoundingClientRect() : null } _focusHostElement(t) { this._elementRef.nativeElement.focus(t) } _blurHostElement() { this._elementRef.nativeElement.blur() } _runInsideZone(t) { this._ngZone ? this._ngZone.run(t) : t() } _runOutsizeZone(t) { this._ngZone ? this._ngZone.runOutsideAngular(t) : t() } writeValue(t) { this.value = t } registerOnChange(t) { this._controlValueAccessorChangeFn = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this.disabled = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Ew), Sa(jr), Sa(Rw, 8), ka("tabindex"), Sa(aS, 8), Sa(Pc), Sa(uh, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-slider"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(dT, !0), 2 & t && tc(i = oc()) && (e._sliderWrapper = i.first) }, hostAttrs: ["role", "slider", 1, "mat-slider", "mat-focus-indicator"], hostVars: 28, hostBindings: function(t, e) { 1 & t && Ba("focus", (function() { return e._onFocus() }))("blur", (function() { return e._onBlur() }))("keydown", (function(t) { return e._onKeydown(t) }))("keyup", (function() { return e._onKeyup() }))("mouseenter", (function() { return e._onMouseenter() }))("selectstart", (function(t) { return t.preventDefault() })), 2 & t && (xo("tabIndex", e.tabIndex), va("aria-disabled", e.disabled)("aria-valuemax", e.max)("aria-valuemin", e.min)("aria-valuenow", e.value)("aria-orientation", e.vertical ? "vertical" : "horizontal"), no("mat-slider-disabled", e.disabled)("mat-slider-has-ticks", e.tickInterval)("mat-slider-horizontal", !e.vertical)("mat-slider-axis-inverted", e._invertAxis)("mat-slider-invert-mouse-coords", e._shouldInvertMouseCoords())("mat-slider-sliding", e._isSliding)("mat-slider-thumb-label-showing", e.thumbLabel)("mat-slider-vertical", e.vertical)("mat-slider-min-value", e._isMinValue)("mat-slider-hide-last-tick", e.disabled || e._isMinValue && e._thumbGap && e._invertAxis)("_mat-animation-noopable", "NoopAnimations" === e._animationMode)) }, inputs: { disabled: "disabled", color: "color", tabIndex: "tabIndex", invert: "invert", max: "max", min: "min", value: "value", step: "step", thumbLabel: "thumbLabel", tickInterval: "tickInterval", vertical: "vertical", displayWith: "displayWith" }, outputs: { change: "change", input: "input", valueChange: "valueChange" }, exportAs: ["matSlider"], features: [Ho([mT]), Eo], decls: 13, vars: 6, consts: [
                [1, "mat-slider-wrapper"],
                ["sliderWrapper", ""],
                [1, "mat-slider-track-wrapper"],
                [1, "mat-slider-track-background", 3, "ngStyle"],
                [1, "mat-slider-track-fill", 3, "ngStyle"],
                [1, "mat-slider-ticks-container", 3, "ngStyle"],
                [1, "mat-slider-ticks", 3, "ngStyle"],
                [1, "mat-slider-thumb-container", 3, "ngStyle"],
                [1, "mat-slider-focus-ring"],
                [1, "mat-slider-thumb"],
                [1, "mat-slider-thumb-label"],
                [1, "mat-slider-thumb-label-text"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div", 0, 1), Ia(2, "div", 2), Oa(3, "div", 3), Oa(4, "div", 4), Ta(), Ia(5, "div", 5), Oa(6, "div", 6), Ta(), Ia(7, "div", 7), Oa(8, "div", 8), Oa(9, "div", 9), Ia(10, "div", 10), Ia(11, "span", 11), _o(12), Ta(), Ta(), Ta(), Ta()), 2 & t && (ps(3), Da("ngStyle", e._trackBackgroundStyles), ps(1), Da("ngStyle", e._trackFillStyles), ps(1), Da("ngStyle", e._ticksContainerStyles), ps(1), Da("ngStyle", e._ticksStyles), ps(1), Da("ngStyle", e._thumbContainerStyles), ps(5), bo(e.displayValue)) }, directives: [Ad], styles: ['.mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:none;vertical-align:middle}.mat-slider:not(.mat-slider-disabled):active,.mat-slider.mat-slider-sliding:not(.mat-slider-disabled){cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-wrapper{position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{background-repeat:repeat;background-clip:content-box;box-sizing:border-box;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb{cursor:-webkit-grab;cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(0.7);transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-radius 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.cdk-high-contrast-active .mat-slider-thumb-label{outline:solid 1px}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-sliding .mat-slider-track-fill,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-thumb-container{transition-duration:0ms}.mat-slider-has-ticks .mat-slider-wrapper::after{content:"";position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(0.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.cdk-high-contrast-active .mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(0.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.cdk-high-contrast-active .mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(0.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-track-fill,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after{transition:none}\n'], encapsulation: 2, changeDetection: 0 }), t })();

    function bT(t) { return "t" === t.type[0] }

    function yT(t) { const e = bT(t) ? t.touches[0] || t.changedTouches[0] : t; return { x: e.clientX, y: e.clientY } }
    let vT = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [Jd, _S], _S
            ] }), t })();
    const wT = ["thumbContainer"], CT = ["toggleBar"], xT = ["input"], ST = function() { return { enterDuration: 150 } }, kT = ["*"], ET = new Vt("mat-slide-toggle-default-options", { providedIn: "root", factory: () => ({ disableToggleValue: !1 }) });
    let DT = 0;
    const AT = { provide: vg, useExisting: St(() => RT), multi: !0 }; class IT { constructor(t, e) { this.source = t, this.checked = e } } class TT { constructor(t) { this._elementRef = t } }
    const OT = wS(yS(vS(bS(TT)), "accent"));
    let RT = (() => { class t extends OT { constructor(t, e, i, n, s, r, a, o) { super(t), this._focusMonitor = e, this._changeDetectorRef = i, this.defaults = r, this._animationMode = a, this._onChange = t => {}, this._onTouched = () => {}, this._uniqueId = `mat-slide-toggle-${++DT}`, this._required = !1, this._checked = !1, this.name = null, this.id = this._uniqueId, this.labelPosition = "after", this.ariaLabel = null, this.ariaLabelledby = null, this.change = new jl, this.toggleChange = new jl, this.dragChange = new jl, this.tabIndex = parseInt(n) || 0 } get required() { return this._required } set required(t) { this._required = Vv(t) } get checked() { return this._checked } set checked(t) { this._checked = Vv(t), this._changeDetectorRef.markForCheck() } get inputId() { return `${this.id||this._uniqueId}-input` } ngAfterContentInit() { this._focusMonitor.monitor(this._elementRef, !0).subscribe(t => { "keyboard" === t || "program" === t ? this._inputElement.nativeElement.focus() : t || Promise.resolve().then(() => this._onTouched()) }) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } _onChangeEvent(t) { t.stopPropagation(), this.toggleChange.emit(), this.defaults.disableToggleValue ? this._inputElement.nativeElement.checked = this.checked : (this.checked = this._inputElement.nativeElement.checked, this._emitChangeEvent()) } _onInputClick(t) { t.stopPropagation() } writeValue(t) { this.checked = !!t } registerOnChange(t) { this._onChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t, this._changeDetectorRef.markForCheck() } focus(t) { this._focusMonitor.focusVia(this._inputElement, "keyboard", t) } toggle() { this.checked = !this.checked, this._onChange(this.checked) } _emitChangeEvent() { this._onChange(this.checked), this.change.emit(new IT(this, this.checked)) } _onLabelTextChange() { this._changeDetectorRef.detectChanges() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Ew), Sa(jr), ka("tabindex"), Sa(Pc), Sa(ET), Sa(aS, 8), Sa(Rw, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-slide-toggle"]
            ], viewQuery: function(t, e) { var i;
                1 & t && (ic(wT, !0), ic(CT, !0), ic(xT, !0)), 2 & t && (tc(i = oc()) && (e._thumbEl = i.first), tc(i = oc()) && (e._thumbBarEl = i.first), tc(i = oc()) && (e._inputElement = i.first)) }, hostAttrs: [1, "mat-slide-toggle"], hostVars: 12, hostBindings: function(t, e) { 2 & t && (xo("id", e.id), va("tabindex", e.disabled ? null : -1)("aria-label", null)("aria-labelledby", null), no("mat-checked", e.checked)("mat-disabled", e.disabled)("mat-slide-toggle-label-before", "before" == e.labelPosition)("_mat-animation-noopable", "NoopAnimations" === e._animationMode)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color", tabIndex: "tabIndex", name: "name", id: "id", labelPosition: "labelPosition", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], required: "required", checked: "checked" }, outputs: { change: "change", toggleChange: "toggleChange", dragChange: "dragChange" }, exportAs: ["matSlideToggle"], features: [Ho([AT]), Eo], ngContentSelectors: kT, decls: 16, vars: 18, consts: [
                [1, "mat-slide-toggle-label"],
                ["label", ""],
                [1, "mat-slide-toggle-bar"],
                ["toggleBar", ""],
                ["type", "checkbox", "role", "switch", 1, "mat-slide-toggle-input", "cdk-visually-hidden", 3, "id", "required", "tabIndex", "checked", "disabled", "change", "click"],
                ["input", ""],
                [1, "mat-slide-toggle-thumb-container"],
                ["thumbContainer", ""],
                [1, "mat-slide-toggle-thumb"],
                ["mat-ripple", "", 1, "mat-slide-toggle-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered", "matRippleRadius", "matRippleAnimation"],
                [1, "mat-ripple-element", "mat-slide-toggle-persistent-ripple"],
                [1, "mat-slide-toggle-content", 3, "cdkObserveContent"],
                ["labelContent", ""],
                [2, "display", "none"]
            ], template: function(t, e) { if (1 & t && ($a(), Ia(0, "label", 0, 1), Ia(2, "div", 2, 3), Ia(4, "input", 4, 5), Ba("change", (function(t) { return e._onChangeEvent(t) }))("click", (function(t) { return e._onInputClick(t) })), Ta(), Ia(6, "div", 6, 7), Oa(8, "div", 8), Ia(9, "div", 9), Oa(10, "div", 10), Ta(), Ta(), Ta(), Ia(11, "span", 11, 12), Ba("cdkObserveContent", (function() { return e._onLabelTextChange() })), Ia(13, "span", 13), _o(14, "\xa0"), Ta(), Wa(15), Ta(), Ta()), 2 & t) { const t = xa(1),
                        i = xa(12);
                    va("for", e.inputId), ps(2), no("mat-slide-toggle-bar-no-side-margin", !i.textContent || !i.textContent.trim()), ps(2), Da("id", e.inputId)("required", e.required)("tabIndex", e.tabIndex)("checked", e.checked)("disabled", e.disabled), va("name", e.name)("aria-checked", e.checked.toString())("aria-label", e.ariaLabel)("aria-labelledby", e.ariaLabelledby), ps(5), Da("matRippleTrigger", t)("matRippleDisabled", e.disableRipple || e.disabled)("matRippleCentered", !0)("matRippleRadius", 20)("matRippleAnimation", Ll(17, ST)) } }, directives: [qS, sw], styles: [".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px, 0, 0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px, 0, 0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar,.mat-slide-toggle-bar{margin-right:8px;margin-left:0}[dir=rtl] .mat-slide-toggle-bar,.mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0, 0, 0);transition:all 80ms linear;transition-property:transform}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-keyboard-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media(hover: none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}.cdk-high-contrast-active .mat-slide-toggle-thumb,.cdk-high-contrast-active .mat-slide-toggle-bar{border:1px solid}.cdk-high-contrast-active .mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:2px dotted;outline-offset:5px}\n"], encapsulation: 2, changeDetection: 0 }), t })();
    const MT = { provide: Fg, useExisting: St(() => PT), multi: !0 };
    let PT = (() => { class t extends nb {} return t.\u0275fac = function(e) { return FT(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-slide-toggle", "required", "", "formControlName", ""],
                ["mat-slide-toggle", "required", "", "formControl", ""],
                ["mat-slide-toggle", "required", "", "ngModel", ""]
            ], features: [Ho([MT]), Eo] }), t })();
    const FT = ln(PT);
    let NT = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })(), LT = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [NT, YS, _S, rw], NT, _S
            ] }), t })();
    const BT = ["mat-menu-item", ""], VT = ["*"];

    function zT(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 0), Ba("keydown", (function(e) { return Qe(t), ja()._handleKeydown(e) }))("click", (function() { return Qe(t), ja().closed.emit("click") }))("@transformMenu.start", (function(e) { return Qe(t), ja()._onAnimationStart(e) }))("@transformMenu.done", (function(e) { return Qe(t), ja()._onAnimationDone(e) })), Ia(1, "div", 1), Wa(2), Ta(), Ta() } if (2 & t) { const t = ja();
            Da("id", t.panelId)("ngClass", t._classList)("@transformMenu", t._panelAnimationState), va("aria-label", t.ariaLabel || null)("aria-labelledby", t.ariaLabelledby || null)("aria-describedby", t.ariaDescribedby || null) } }
    const UT = { transformMenu: Lw("transformMenu", [Hw("void", Uw({ opacity: 0, transform: "scale(0.8)" })), Gw("void => enter", Vw([Yw(".mat-menu-content, .mat-mdc-menu-content", Bw("100ms linear", Uw({ opacity: 1 }))), Bw("120ms cubic-bezier(0, 0, 0.2, 1)", Uw({ transform: "scale(1)" }))])), Gw("* => void", Bw("100ms 25ms linear", Uw({ opacity: 0 })))]), fadeInItems: Lw("fadeInItems", [Hw("showing", Uw({ opacity: 1 })), Gw("void => *", [Uw({ opacity: 0 }), Bw("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) };
    let HT = (() => { class t { constructor(t, e, i, n, s, r, a) { this._template = t, this._componentFactoryResolver = e, this._appRef = i, this._injector = n, this._viewContainerRef = s, this._document = r, this._changeDetectorRef = a, this._attached = new k } attach(t = {}) { this._portal || (this._portal = new bD(this._template, this._viewContainerRef)), this.detach(), this._outlet || (this._outlet = new wD(this._document.createElement("div"), this._componentFactoryResolver, this._appRef, this._injector)); const e = this._template.elementRef.nativeElement;
                e.parentNode.insertBefore(this._outlet.outletElement, e), this._changeDetectorRef && this._changeDetectorRef.markForCheck(), this._portal.attach(this._outlet, t), this._attached.next() } detach() { this._portal.isAttached && this._portal.detach() } ngOnDestroy() { this._outlet && this._outlet.dispose() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl), Sa($o), Sa(th), Sa(ra), Sa(bl), Sa(uh), Sa(jr)) }, t.\u0275dir = we({ type: t, selectors: [
                ["ng-template", "matMenuContent", ""]
            ] }), t })();
    const jT = new Vt("MAT_MENU_PANEL"); class GT {}
    const $T = vS(bS(GT));
    let WT = (() => { class t extends $T { constructor(t, e, i, n) { super(), this._elementRef = t, this._focusMonitor = i, this._parentMenu = n, this.role = "menuitem", this._hovered = new k, this._focused = new k, this._highlighted = !1, this._triggersSubmenu = !1, i && i.monitor(this._elementRef, !1), n && n.addItem && n.addItem(this), this._document = e } focus(t = "program", e) { this._focusMonitor ? this._focusMonitor.focusVia(this._getHostElement(), t, e) : this._getHostElement().focus(e), this._focused.next(this) } ngOnDestroy() { this._focusMonitor && this._focusMonitor.stopMonitoring(this._elementRef), this._parentMenu && this._parentMenu.removeItem && this._parentMenu.removeItem(this), this._hovered.complete(), this._focused.complete() } _getTabIndex() { return this.disabled ? "-1" : "0" } _getHostElement() { return this._elementRef.nativeElement } _checkDisabled(t) { this.disabled && (t.preventDefault(), t.stopPropagation()) } _handleMouseEnter() { this._hovered.next(this) } getLabel() { const t = this._elementRef.nativeElement,
                    e = this._document ? this._document.TEXT_NODE : 3; let i = ""; if (t.childNodes) { const n = t.childNodes.length; for (let s = 0; s < n; s++) t.childNodes[s].nodeType === e && (i += t.childNodes[s].textContent) } return i.trim() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(uh), Sa(Ew), Sa(jT, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["", "mat-menu-item", ""]
            ], hostAttrs: [1, "mat-focus-indicator"], hostVars: 10, hostBindings: function(t, e) { 1 & t && Ba("click", (function(t) { return e._checkDisabled(t) }))("mouseenter", (function() { return e._handleMouseEnter() })), 2 & t && (va("role", e.role)("tabindex", e._getTabIndex())("aria-disabled", e.disabled.toString())("disabled", e.disabled || null), no("mat-menu-item", !0)("mat-menu-item-highlighted", e._highlighted)("mat-menu-item-submenu-trigger", e._triggersSubmenu)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", role: "role" }, exportAs: ["matMenuItem"], features: [Eo], attrs: BT, ngContentSelectors: VT, decls: 2, vars: 2, consts: [
                ["matRipple", "", 1, "mat-menu-ripple", 3, "matRippleDisabled", "matRippleTrigger"]
            ], template: function(t, e) { 1 & t && ($a(), Wa(0), Oa(1, "div", 0)), 2 & t && (ps(1), Da("matRippleDisabled", e.disableRipple || e.disabled)("matRippleTrigger", e._getHostElement())) }, directives: [qS], encapsulation: 2, changeDetection: 0 }), t })();
    const qT = new Vt("mat-menu-default-options", { providedIn: "root", factory: function() { return { overlapTrigger: !1, xPosition: "after", yPosition: "below", backdropClass: "cdk-overlay-transparent-backdrop" } } });
    let YT = 0, XT = (() => { class t { constructor(t, e, i) { this._elementRef = t, this._ngZone = e, this._defaultOptions = i, this._xPosition = this._defaultOptions.xPosition, this._yPosition = this._defaultOptions.yPosition, this._directDescendantItems = new $l, this._tabSubscription = d.EMPTY, this._classList = {}, this._panelAnimationState = "void", this._animationDone = new k, this.backdropClass = this._defaultOptions.backdropClass, this._overlapTrigger = this._defaultOptions.overlapTrigger, this._hasBackdrop = this._defaultOptions.hasBackdrop, this.closed = new jl, this.close = this.closed, this.panelId = `mat-menu-panel-${YT++}` } get xPosition() { return this._xPosition } set xPosition(t) { "before" !== t && "after" !== t && function() { throw Error('xPosition value must be either \'before\' or after\'.\n      Example: <mat-menu xPosition="before" #menu="matMenu"></mat-menu>') }(), this._xPosition = t, this.setPositionClasses() } get yPosition() { return this._yPosition } set yPosition(t) { "above" !== t && "below" !== t && function() { throw Error('yPosition value must be either \'above\' or below\'.\n      Example: <mat-menu yPosition="above" #menu="matMenu"></mat-menu>') }(), this._yPosition = t, this.setPositionClasses() } get overlapTrigger() { return this._overlapTrigger } set overlapTrigger(t) { this._overlapTrigger = Vv(t) } get hasBackdrop() { return this._hasBackdrop } set hasBackdrop(t) { this._hasBackdrop = Vv(t) } set panelClass(t) { const e = this._previousPanelClass;
                e && e.length && e.split(" ").forEach(t => { this._classList[t] = !1 }), this._previousPanelClass = t, t && t.length && (t.split(" ").forEach(t => { this._classList[t] = !0 }), this._elementRef.nativeElement.className = "") } get classList() { return this.panelClass } set classList(t) { this.panelClass = t } ngOnInit() { this.setPositionClasses() } ngAfterContentInit() { this._updateDirectDescendants(), this._keyManager = new mw(this._directDescendantItems).withWrap().withTypeAhead(), this._tabSubscription = this._keyManager.tabOut.subscribe(() => this.closed.emit("tab")), this._directDescendantItems.changes.pipe(bm(this._directDescendantItems), pm(t => q(...t.map(t => t._focused)))).subscribe(t => this._keyManager.updateActiveItem(t)) } ngOnDestroy() { this._directDescendantItems.destroy(), this._tabSubscription.unsubscribe(), this.closed.complete() } _hovered() { return this._directDescendantItems.changes.pipe(bm(this._directDescendantItems), pm(t => q(...t.map(t => t._hovered)))) } addItem(t) {} removeItem(t) {} _handleKeydown(t) { const e = t.keyCode,
                    i = this._keyManager; switch (e) {
                    case 27:
                        Iv(t) || (t.preventDefault(), this.closed.emit("keydown")); break;
                    case 37:
                        this.parentMenu && "ltr" === this.direction && this.closed.emit("keydown"); break;
                    case 39:
                        this.parentMenu && "rtl" === this.direction && this.closed.emit("keydown"); break;
                    case 36:
                    case 35:
                        Iv(t) || (36 === e ? i.setFirstItemActive() : i.setLastItemActive(), t.preventDefault()); break;
                    default:
                        38 !== e && 40 !== e || i.setFocusOrigin("keyboard"), i.onKeydown(t) } } focusFirstItem(t = "program") { this.lazyContent ? this._ngZone.onStable.asObservable().pipe(lm(1)).subscribe(() => this._focusFirstItem(t)) : this._focusFirstItem(t) } _focusFirstItem(t) { const e = this._keyManager; if (e.setFocusOrigin(t).setFirstItemActive(), !e.activeItem && this._directDescendantItems.length) { let t = this._directDescendantItems.first._getHostElement().parentElement; for (; t;) { if ("menu" === t.getAttribute("role")) { t.focus(); break } t = t.parentElement } } } resetActiveItem() { this._keyManager.setActiveItem(-1) } setElevation(t) { const e = `mat-elevation-z${Math.min(4+t,24)}`,
                    i = Object.keys(this._classList).find(t => t.startsWith("mat-elevation-z"));
                i && i !== this._previousElevation || (this._previousElevation && (this._classList[this._previousElevation] = !1), this._classList[e] = !0, this._previousElevation = e) } setPositionClasses(t = this.xPosition, e = this.yPosition) { const i = this._classList;
                i["mat-menu-before"] = "before" === t, i["mat-menu-after"] = "after" === t, i["mat-menu-above"] = "above" === e, i["mat-menu-below"] = "below" === e } _startAnimation() { this._panelAnimationState = "enter" } _resetAnimation() { this._panelAnimationState = "void" } _onAnimationDone(t) { this._animationDone.next(t), this._isAnimating = !1 } _onAnimationStart(t) { this._isAnimating = !0, "enter" === t.toState && 0 === this._keyManager.activeItemIndex && (t.element.scrollTop = 0) } _updateDirectDescendants() { this._allItems.changes.pipe(bm(this._allItems)).subscribe(t => { this._directDescendantItems.reset(t.filter(t => t._parentMenu === this)), this._directDescendantItems.notifyOnChanges() }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Pc), Sa(qT)) }, t.\u0275dir = we({ type: t, contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, HT, !0), sc(i, WT, !0), sc(i, WT, !1)), 2 & t && (tc(n = oc()) && (e.lazyContent = n.first), tc(n = oc()) && (e._allItems = n), tc(n = oc()) && (e.items = n)) }, viewQuery: function(t, e) { var i;
                1 & t && ic(gl, !0), 2 & t && tc(i = oc()) && (e.templateRef = i.first) }, inputs: { backdropClass: "backdropClass", xPosition: "xPosition", yPosition: "yPosition", overlapTrigger: "overlapTrigger", hasBackdrop: "hasBackdrop", panelClass: ["class", "panelClass"], classList: "classList", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"] }, outputs: { closed: "closed", close: "close" } }), t })(), KT = (() => { class t extends XT {} return t.\u0275fac = function(e) { return ZT(e || t) }, t.\u0275dir = we({ type: t, features: [Eo] }), t })();
    const ZT = ln(KT);
    let QT = (() => { class t extends KT { constructor(t, e, i) { super(t, e, i) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Pc), Sa(qT)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-menu"]
            ], exportAs: ["matMenu"], features: [Ho([{ provide: jT, useExisting: KT }, { provide: KT, useExisting: t }]), Eo], ngContentSelectors: VT, decls: 1, vars: 0, consts: [
                ["tabindex", "-1", "role", "menu", 1, "mat-menu-panel", 3, "id", "ngClass", "keydown", "click"],
                [1, "mat-menu-content"]
            ], template: function(t, e) { 1 & t && ($a(), Ca(0, zT, 3, 6, "ng-template")) }, directives: [pd], styles: ['.mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-menu-panel{outline:solid 1px}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}.cdk-high-contrast-active .mat-menu-item.cdk-program-focused,.cdk-high-contrast-active .mat-menu-item.cdk-keyboard-focused,.cdk-high-contrast-active .mat-menu-item-highlighted{outline:dotted 1px}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:"";display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\n'], encapsulation: 2, data: { animation: [UT.transformMenu, UT.fadeInItems] }, changeDetection: 0 }), t })();
    const JT = new Vt("mat-menu-scroll-strategy"), tO = { provide: JT, deps: [JD], useFactory: function(t) { return () => t.scrollStrategies.reposition() } }, eO = Jv({ passive: !0 });
    let iO = (() => { class t { constructor(t, e, i, n, s, r, a, o) { this._overlay = t, this._element = e, this._viewContainerRef = i, this._parentMenu = s, this._menuItemInstance = r, this._dir = a, this._focusMonitor = o, this._overlayRef = null, this._menuOpen = !1, this._closingActionsSubscription = d.EMPTY, this._hoverSubscription = d.EMPTY, this._menuCloseSubscription = d.EMPTY, this._handleTouchStart = () => this._openedBy = "touch", this._openedBy = null, this.restoreFocus = !0, this.menuOpened = new jl, this.onMenuOpen = this.menuOpened, this.menuClosed = new jl, this.onMenuClose = this.menuClosed, e.nativeElement.addEventListener("touchstart", this._handleTouchStart, eO), r && (r._triggersSubmenu = this.triggersSubmenu()), this._scrollStrategy = n } get _deprecatedMatMenuTriggerFor() { return this.menu } set _deprecatedMatMenuTriggerFor(t) { this.menu = t } get menu() { return this._menu } set menu(t) { t !== this._menu && (this._menu = t, this._menuCloseSubscription.unsubscribe(), t && (this._menuCloseSubscription = t.close.asObservable().subscribe(t => { this._destroyMenu(), "click" !== t && "tab" !== t || !this._parentMenu || this._parentMenu.closed.emit(t) }))) } ngAfterContentInit() { this._checkMenu(), this._handleHover() } ngOnDestroy() { this._overlayRef && (this._overlayRef.dispose(), this._overlayRef = null), this._element.nativeElement.removeEventListener("touchstart", this._handleTouchStart, eO), this._menuCloseSubscription.unsubscribe(), this._closingActionsSubscription.unsubscribe(), this._hoverSubscription.unsubscribe() } get menuOpen() { return this._menuOpen } get dir() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } triggersSubmenu() { return !(!this._menuItemInstance || !this._parentMenu) } toggleMenu() { return this._menuOpen ? this.closeMenu() : this.openMenu() } openMenu() { if (this._menuOpen) return;
                this._checkMenu(); const t = this._createOverlay(),
                    e = t.getConfig();
                this._setPosition(e.positionStrategy), e.hasBackdrop = null == this.menu.hasBackdrop ? !this.triggersSubmenu() : this.menu.hasBackdrop, t.attach(this._getPortal()), this.menu.lazyContent && this.menu.lazyContent.attach(this.menuData), this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu()), this._initMenu(), this.menu instanceof KT && this.menu._startAnimation() } closeMenu() { this.menu.close.emit() } focus(t = "program", e) { this._focusMonitor ? this._focusMonitor.focusVia(this._element, t, e) : this._element.nativeElement.focus(e) } _destroyMenu() { if (!this._overlayRef || !this.menuOpen) return; const t = this.menu;
                this._closingActionsSubscription.unsubscribe(), this._overlayRef.detach(), this._restoreFocus(), t instanceof KT ? (t._resetAnimation(), t.lazyContent ? t._animationDone.pipe(Gu(t => "void" === t.toState), lm(1), jk(t.lazyContent._attached)).subscribe({ next: () => t.lazyContent.detach(), complete: () => this._setIsMenuOpen(!1) }) : this._setIsMenuOpen(!1)) : (this._setIsMenuOpen(!1), t.lazyContent && t.lazyContent.detach()) } _initMenu() { this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : void 0, this.menu.direction = this.dir, this._setMenuElevation(), this._setIsMenuOpen(!0), this.menu.focusFirstItem(this._openedBy || "program") } _setMenuElevation() { if (this.menu.setElevation) { let t = 0,
                        e = this.menu.parentMenu; for (; e;) t++, e = e.parentMenu;
                    this.menu.setElevation(t) } } _restoreFocus() { this.restoreFocus && (this._openedBy ? this.triggersSubmenu() || this.focus(this._openedBy) : this.focus()), this._openedBy = null } _setIsMenuOpen(t) { this._menuOpen = t, this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit(), this.triggersSubmenu() && (this._menuItemInstance._highlighted = t) } _checkMenu() { this.menu || function() { throw Error('matMenuTriggerFor: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu="matMenu"></mat-menu>\n      <button [matMenuTriggerFor]="menu"></button>') }() } _createOverlay() { if (!this._overlayRef) { const t = this._getOverlayConfig();
                    this._subscribeToPositions(t.positionStrategy), this._overlayRef = this._overlay.create(t), this._overlayRef.keydownEvents().subscribe() } return this._overlayRef } _getOverlayConfig() { return new ND({ positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"), backdropClass: this.menu.backdropClass || "cdk-overlay-transparent-backdrop", scrollStrategy: this._scrollStrategy(), direction: this._dir }) } _subscribeToPositions(t) { this.menu.setPositionClasses && t.positionChanges.subscribe(t => { this.menu.setPositionClasses("start" === t.connectionPair.overlayX ? "after" : "before", "top" === t.connectionPair.overlayY ? "below" : "above") }) } _setPosition(t) { let [e, i] = "before" === this.menu.xPosition ? ["end", "start"] : ["start", "end"], [n, s] = "above" === this.menu.yPosition ? ["bottom", "top"] : ["top", "bottom"], [r, a] = [n, s], [o, l] = [e, i], c = 0;
                this.triggersSubmenu() ? (l = e = "before" === this.menu.xPosition ? "start" : "end", i = o = "end" === e ? "start" : "end", c = "bottom" === n ? 8 : -8) : this.menu.overlapTrigger || (r = "top" === n ? "bottom" : "top", a = "top" === s ? "bottom" : "top"), t.withPositions([{ originX: e, originY: r, overlayX: o, overlayY: n, offsetY: c }, { originX: i, originY: r, overlayX: l, overlayY: n, offsetY: c }, { originX: e, originY: a, overlayX: o, overlayY: s, offsetY: -c }, { originX: i, originY: a, overlayX: l, overlayY: s, offsetY: -c }]) } _menuClosingActions() { const t = this._overlayRef.backdropClick(),
                    e = this._overlayRef.detachments(); return q(t, this._parentMenu ? this._parentMenu.closed : Mu(), this._parentMenu ? this._parentMenu._hovered().pipe(Gu(t => t !== this._menuItemInstance), Gu(() => this._menuOpen)) : Mu(), e) } _handleMousedown(t) { Aw(t) || (this._openedBy = 0 === t.button ? "mouse" : null, this.triggersSubmenu() && t.preventDefault()) } _handleKeydown(t) { const e = t.keyCode;
                this.triggersSubmenu() && (39 === e && "ltr" === this.dir || 37 === e && "rtl" === this.dir) && this.openMenu() } _handleClick(t) { this.triggersSubmenu() ? (t.stopPropagation(), this.openMenu()) : this.toggleMenu() } _handleHover() { this.triggersSubmenu() && (this._hoverSubscription = this._parentMenu._hovered().pipe(Gu(t => t === this._menuItemInstance && !t.disabled), oA(0, YE)).subscribe(() => { this._openedBy = "mouse", this.menu instanceof KT && this.menu._isAnimating ? this.menu._animationDone.pipe(lm(1), oA(0, YE), jk(this._parentMenu._hovered())).subscribe(() => this.openMenu()) : this.openMenu() })) } _getPortal() { return this._portal && this._portal.templateRef === this.menu.templateRef || (this._portal = new bD(this.menu.templateRef, this._viewContainerRef)), this._portal } } return t.\u0275fac = function(e) { return new(e || t)(Sa(JD), Sa(Wo), Sa(bl), Sa(JT), Sa(KT, 8), Sa(WT, 10), Sa(Rw, 8), Sa(Ew)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-menu-trigger-for", ""],
                ["", "matMenuTriggerFor", ""]
            ], hostAttrs: ["aria-haspopup", "true", 1, "mat-menu-trigger"], hostVars: 2, hostBindings: function(t, e) { 1 & t && Ba("mousedown", (function(t) { return e._handleMousedown(t) }))("keydown", (function(t) { return e._handleKeydown(t) }))("click", (function(t) { return e._handleClick(t) })), 2 & t && va("aria-expanded", e.menuOpen || null)("aria-controls", e.menuOpen ? e.menu.panelId : null) }, inputs: { restoreFocus: ["matMenuTriggerRestoreFocus", "restoreFocus"], _deprecatedMatMenuTriggerFor: ["mat-menu-trigger-for", "_deprecatedMatMenuTriggerFor"], menu: ["matMenuTriggerFor", "menu"], menuData: ["matMenuTriggerData", "menuData"] }, outputs: { menuOpened: "menuOpened", onMenuOpen: "onMenuOpen", menuClosed: "menuClosed", onMenuClose: "onMenuClose" }, exportAs: ["matMenuTrigger"] }), t })(), nO = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [tO], imports: [_S] }), t })(), sO = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [tO], imports: [
                [Jd, _S, YS, rA, nO], nO
            ] }), t })();
    const rO = ["*"];

    function aO(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 2), Ba("click", (function() { return Qe(t), ja()._onBackdropClicked() })), Ta() } 2 & t && no("mat-drawer-shown", ja()._isShowingBackdrop()) }

    function oO(t, e) { 1 & t && (Ia(0, "mat-drawer-content"), Wa(1, 2), Ta()) }
    const lO = [
        [
            ["mat-drawer"]
        ],
        [
            ["mat-drawer-content"]
        ], "*"
    ], cO = ["mat-drawer", "mat-drawer-content", "*"];

    function hO(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 2), Ba("click", (function() { return Qe(t), ja()._onBackdropClicked() })), Ta() } 2 & t && no("mat-drawer-shown", ja()._isShowingBackdrop()) }

    function dO(t, e) { 1 & t && (Ia(0, "mat-sidenav-content", 3), Wa(1, 2), Ta()) }
    const uO = [
        [
            ["mat-sidenav"]
        ],
        [
            ["mat-sidenav-content"]
        ], "*"
    ], mO = ["mat-sidenav", "mat-sidenav-content", "*"], pO = { transformDrawer: Lw("transform", [Hw("open, open-instant", Uw({ transform: "none", visibility: "visible" })), Hw("void", Uw({ "box-shadow": "none", visibility: "hidden" })), Gw("void => open-instant", Bw("0ms")), Gw("void <=> open, open-instant => void", Bw("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))]) };

    function fO(t) { throw Error(`A drawer was already declared for 'position="${t}"'`) }
    const gO = new Vt("MAT_DRAWER_DEFAULT_AUTOSIZE", { providedIn: "root", factory: function() { return !1 } }), _O = new Vt("MAT_DRAWER_CONTAINER");
    let bO = (() => { class t extends uD { constructor(t, e, i, n, s) { super(i, n, s), this._changeDetectorRef = t, this._container = e } ngAfterContentInit() { this._container._contentMarginChanges.subscribe(() => { this._changeDetectorRef.markForCheck() }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jr), Sa(St(() => vO)), Sa(Wo), Sa(dD), Sa(Pc)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-drawer-content"]
            ], hostAttrs: [1, "mat-drawer-content"], hostVars: 4, hostBindings: function(t, e) { 2 & t && io("margin-left", e._container._contentMargins.left, "px")("margin-right", e._container._contentMargins.right, "px") }, features: [Eo], ngContentSelectors: rO, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(), Wa(0)) }, encapsulation: 2, changeDetection: 0 }), t })(), yO = (() => { class t { constructor(t, e, i, n, s, r, a) { this._elementRef = t, this._focusTrapFactory = e, this._focusMonitor = i, this._platform = n, this._ngZone = s, this._doc = r, this._container = a, this._elementFocusedBeforeDrawerWasOpened = null, this._enableAnimations = !1, this._position = "start", this._mode = "over", this._disableClose = !1, this._opened = !1, this._animationStarted = new k, this._animationEnd = new k, this._animationState = "void", this.openedChange = new jl(!0), this._destroyed = new k, this.onPositionChanged = new jl, this._modeChanged = new k, this.openedChange.subscribe(t => { t ? (this._doc && (this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement), this._takeFocus()) : this._restoreFocus() }), this._ngZone.runOutsideAngular(() => { Nk(this._elementRef.nativeElement, "keydown").pipe(Gu(t => 27 === t.keyCode && !this.disableClose && !Iv(t)), jk(this._destroyed)).subscribe(t => this._ngZone.run(() => { this.close(), t.stopPropagation(), t.preventDefault() })) }), this._animationEnd.pipe(XE((t, e) => t.fromState === e.fromState && t.toState === e.toState)).subscribe(t => { const { fromState: e, toState: i } = t;
                    (0 === i.indexOf("open") && "void" === e || "void" === i && 0 === e.indexOf("open")) && this.openedChange.emit(this._opened) }) } get position() { return this._position } set position(t) {
                (t = "end" === t ? "end" : "start") != this._position && (this._position = t, this.onPositionChanged.emit()) } get mode() { return this._mode } set mode(t) { this._mode = t, this._updateFocusTrapState(), this._modeChanged.next() } get disableClose() { return this._disableClose } set disableClose(t) { this._disableClose = Vv(t) } get autoFocus() { const t = this._autoFocus; return null == t ? "side" !== this.mode : t } set autoFocus(t) { this._autoFocus = Vv(t) } get opened() { return this._opened } set opened(t) { this.toggle(Vv(t)) } get _openedStream() { return this.openedChange.pipe(Gu(t => t), L(() => {})) } get openedStart() { return this._animationStarted.pipe(Gu(t => t.fromState !== t.toState && 0 === t.toState.indexOf("open")), L(() => {})) } get _closedStream() { return this.openedChange.pipe(Gu(t => !t), L(() => {})) } get closedStart() { return this._animationStarted.pipe(Gu(t => t.fromState !== t.toState && "void" === t.toState), L(() => {})) } _takeFocus() { this.autoFocus && this._focusTrap && this._focusTrap.focusInitialElementWhenReady().then(t => { t || "function" != typeof this._elementRef.nativeElement.focus || this._elementRef.nativeElement.focus() }) } _restoreFocus() { if (!this.autoFocus) return; const t = this._doc && this._doc.activeElement;
                t && this._elementRef.nativeElement.contains(t) && (this._elementFocusedBeforeDrawerWasOpened ? this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia) : this._elementRef.nativeElement.blur()), this._elementFocusedBeforeDrawerWasOpened = null, this._openedVia = null } ngAfterContentInit() { this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement), this._updateFocusTrapState() } ngAfterContentChecked() { this._platform.isBrowser && (this._enableAnimations = !0) } ngOnDestroy() { this._focusTrap && this._focusTrap.destroy(), this._animationStarted.complete(), this._animationEnd.complete(), this._modeChanged.complete(), this._destroyed.next(), this._destroyed.complete() } open(t) { return this.toggle(!0, t) } close() { return this.toggle(!1) } toggle(t = !this.opened, e = "program") { return this._opened = t, t ? (this._animationState = this._enableAnimations ? "open" : "open-instant", this._openedVia = e) : (this._animationState = "void", this._restoreFocus()), this._updateFocusTrapState(), new Promise(t => { this.openedChange.pipe(lm(1)).subscribe(e => t(e ? "open" : "close")) }) } get _width() { return this._elementRef.nativeElement && this._elementRef.nativeElement.offsetWidth || 0 } _updateFocusTrapState() { this._focusTrap && (this._focusTrap.enabled = this.opened && "side" !== this.mode) } _animationStartListener(t) { this._animationStarted.next(t) } _animationDoneListener(t) { this._animationEnd.next(t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(bw), Sa(Ew), Sa(Wv), Sa(Pc), Sa(uh, 8), Sa(_O, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-drawer"]
            ], hostAttrs: ["tabIndex", "-1", 1, "mat-drawer"], hostVars: 12, hostBindings: function(t, e) { 1 & t && Va("@transform.start", (function(t) { return e._animationStartListener(t) }))("@transform.done", (function(t) { return e._animationDoneListener(t) })), 2 & t && (va("align", null), So("@transform", e._animationState), no("mat-drawer-end", "end" === e.position)("mat-drawer-over", "over" === e.mode)("mat-drawer-push", "push" === e.mode)("mat-drawer-side", "side" === e.mode)("mat-drawer-opened", e.opened)) }, inputs: { position: "position", mode: "mode", disableClose: "disableClose", autoFocus: "autoFocus", opened: "opened" }, outputs: { openedChange: "openedChange", onPositionChanged: "positionChanged", _openedStream: "opened", openedStart: "openedStart", _closedStream: "closed", closedStart: "closedStart" }, exportAs: ["matDrawer"], ngContentSelectors: rO, decls: 2, vars: 0, consts: [
                [1, "mat-drawer-inner-container"]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "div", 0), Wa(1), Ta()) }, encapsulation: 2, data: { animation: [pO.transformDrawer] }, changeDetection: 0 }), t })(), vO = (() => { class t { constructor(t, e, i, n, s, r = !1, a) { this._dir = t, this._element = e, this._ngZone = i, this._changeDetectorRef = n, this._animationMode = a, this._drawers = new $l, this.backdropClick = new jl, this._destroyed = new k, this._doCheckSubject = new k, this._contentMargins = { left: null, right: null }, this._contentMarginChanges = new k, t && t.change.pipe(jk(this._destroyed)).subscribe(() => { this._validateDrawers(), this.updateContentMargins() }), s.change().pipe(jk(this._destroyed)).subscribe(() => this.updateContentMargins()), this._autosize = r } get start() { return this._start } get end() { return this._end } get autosize() { return this._autosize } set autosize(t) { this._autosize = Vv(t) } get hasBackdrop() { return null == this._backdropOverride ? !this._start || "side" !== this._start.mode || !this._end || "side" !== this._end.mode : this._backdropOverride } set hasBackdrop(t) { this._backdropOverride = null == t ? null : Vv(t) } get scrollable() { return this._userContent || this._content } ngAfterContentInit() { this._allDrawers.changes.pipe(bm(this._allDrawers), jk(this._destroyed)).subscribe(t => { this._drawers.reset(t.filter(t => !t._container || t._container === this)), this._drawers.notifyOnChanges() }), this._drawers.changes.pipe(bm(null)).subscribe(() => { this._validateDrawers(), this._drawers.forEach(t => { this._watchDrawerToggle(t), this._watchDrawerPosition(t), this._watchDrawerMode(t) }), (!this._drawers.length || this._isDrawerOpen(this._start) || this._isDrawerOpen(this._end)) && this.updateContentMargins(), this._changeDetectorRef.markForCheck() }), this._doCheckSubject.pipe(Fv(10), jk(this._destroyed)).subscribe(() => this.updateContentMargins()) } ngOnDestroy() { this._contentMarginChanges.complete(), this._doCheckSubject.complete(), this._drawers.destroy(), this._destroyed.next(), this._destroyed.complete() } open() { this._drawers.forEach(t => t.open()) } close() { this._drawers.forEach(t => t.close()) } updateContentMargins() { let t = 0,
                    e = 0; if (this._left && this._left.opened)
                    if ("side" == this._left.mode) t += this._left._width;
                    else if ("push" == this._left.mode) { const i = this._left._width;
                    t += i, e -= i } if (this._right && this._right.opened)
                    if ("side" == this._right.mode) e += this._right._width;
                    else if ("push" == this._right.mode) { const i = this._right._width;
                    e += i, t -= i } t = t || null, e = e || null, t === this._contentMargins.left && e === this._contentMargins.right || (this._contentMargins = { left: t, right: e }, this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins))) } ngDoCheck() { this._autosize && this._isPushed() && this._ngZone.runOutsideAngular(() => this._doCheckSubject.next()) } _watchDrawerToggle(t) { t._animationStarted.pipe(Gu(t => t.fromState !== t.toState), jk(this._drawers.changes)).subscribe(t => { "open-instant" !== t.toState && "NoopAnimations" !== this._animationMode && this._element.nativeElement.classList.add("mat-drawer-transition"), this.updateContentMargins(), this._changeDetectorRef.markForCheck() }), "side" !== t.mode && t.openedChange.pipe(jk(this._drawers.changes)).subscribe(() => this._setContainerClass(t.opened)) } _watchDrawerPosition(t) { t && t.onPositionChanged.pipe(jk(this._drawers.changes)).subscribe(() => { this._ngZone.onMicrotaskEmpty.asObservable().pipe(lm(1)).subscribe(() => { this._validateDrawers() }) }) } _watchDrawerMode(t) { t && t._modeChanged.pipe(jk(q(this._drawers.changes, this._destroyed))).subscribe(() => { this.updateContentMargins(), this._changeDetectorRef.markForCheck() }) } _setContainerClass(t) { const e = this._element.nativeElement.classList,
                    i = "mat-drawer-container-has-open";
                t ? e.add(i) : e.remove(i) } _validateDrawers() { this._start = this._end = null, this._drawers.forEach(t => { "end" == t.position ? (null != this._end && fO("end"), this._end = t) : (null != this._start && fO("start"), this._start = t) }), this._right = this._left = null, this._dir && "rtl" === this._dir.value ? (this._left = this._end, this._right = this._start) : (this._left = this._start, this._right = this._end) } _isPushed() { return this._isDrawerOpen(this._start) && "over" != this._start.mode || this._isDrawerOpen(this._end) && "over" != this._end.mode } _onBackdropClicked() { this.backdropClick.emit(), this._closeModalDrawer() } _closeModalDrawer() {
                [this._start, this._end].filter(t => t && !t.disableClose && this._canHaveBackdrop(t)).forEach(t => t.close()) } _isShowingBackdrop() { return this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start) || this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end) } _canHaveBackdrop(t) { return "side" !== t.mode || !!this._backdropOverride } _isDrawerOpen(t) { return null != t && t.opened } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Rw, 8), Sa(Wo), Sa(Pc), Sa(jr), Sa(mD), Sa(gO), Sa(aS, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-drawer-container"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, bO, !0), sc(i, yO, !0)), 2 & t && (tc(n = oc()) && (e._content = n.first), tc(n = oc()) && (e._allDrawers = n)) }, viewQuery: function(t, e) { var i;
                1 & t && ic(bO, !0), 2 & t && tc(i = oc()) && (e._userContent = i.first) }, hostAttrs: [1, "mat-drawer-container"], hostVars: 2, hostBindings: function(t, e) { 2 & t && no("mat-drawer-container-explicit-backdrop", e._backdropOverride) }, inputs: { autosize: "autosize", hasBackdrop: "hasBackdrop" }, outputs: { backdropClick: "backdropClick" }, exportAs: ["matDrawerContainer"], features: [Ho([{ provide: _O, useExisting: t }])], ngContentSelectors: cO, decls: 4, vars: 2, consts: [
                ["class", "mat-drawer-backdrop", 3, "mat-drawer-shown", "click", 4, "ngIf"],
                [4, "ngIf"],
                [1, "mat-drawer-backdrop", 3, "click"]
            ], template: function(t, e) { 1 & t && ($a(lO), Ca(0, aO, 1, 2, "div", 0), Wa(1), Wa(2, 1), Ca(3, oO, 2, 0, "mat-drawer-content", 1)), 2 & t && (Da("ngIf", e.hasBackdrop), ps(3), Da("ngIf", !e._content)) }, directives: [yd, bO], styles: [".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\n"], encapsulation: 2, changeDetection: 0 }), t })(), wO = (() => { class t extends bO { constructor(t, e, i, n, s) { super(t, e, i, n, s) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jr), Sa(St(() => SO)), Sa(Wo), Sa(dD), Sa(Pc)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-sidenav-content"]
            ], hostAttrs: [1, "mat-drawer-content", "mat-sidenav-content"], hostVars: 4, hostBindings: function(t, e) { 2 & t && io("margin-left", e._container._contentMargins.left, "px")("margin-right", e._container._contentMargins.right, "px") }, features: [Eo], ngContentSelectors: rO, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(), Wa(0)) }, encapsulation: 2, changeDetection: 0 }), t })(), CO = (() => { class t extends yO { constructor() { super(...arguments), this._fixedInViewport = !1, this._fixedTopGap = 0, this._fixedBottomGap = 0 } get fixedInViewport() { return this._fixedInViewport } set fixedInViewport(t) { this._fixedInViewport = Vv(t) } get fixedTopGap() { return this._fixedTopGap } set fixedTopGap(t) { this._fixedTopGap = zv(t) } get fixedBottomGap() { return this._fixedBottomGap } set fixedBottomGap(t) { this._fixedBottomGap = zv(t) } } return t.\u0275fac = function(e) { return xO(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-sidenav"]
            ], hostAttrs: ["tabIndex", "-1", 1, "mat-drawer", "mat-sidenav"], hostVars: 17, hostBindings: function(t, e) { 2 & t && (va("align", null), io("top", e.fixedInViewport ? e.fixedTopGap : null, "px")("bottom", e.fixedInViewport ? e.fixedBottomGap : null, "px"), no("mat-drawer-end", "end" === e.position)("mat-drawer-over", "over" === e.mode)("mat-drawer-push", "push" === e.mode)("mat-drawer-side", "side" === e.mode)("mat-drawer-opened", e.opened)("mat-sidenav-fixed", e.fixedInViewport)) }, inputs: { fixedInViewport: "fixedInViewport", fixedTopGap: "fixedTopGap", fixedBottomGap: "fixedBottomGap" }, exportAs: ["matSidenav"], features: [Eo], ngContentSelectors: rO, decls: 2, vars: 0, consts: [
                [1, "mat-drawer-inner-container"]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "div", 0), Wa(1), Ta()) }, encapsulation: 2, data: { animation: [pO.transformDrawer] }, changeDetection: 0 }), t })();
    const xO = ln(CO);
    let SO = (() => { class t extends vO {} return t.\u0275fac = function(e) { return kO(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-sidenav-container"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, wO, !0), sc(i, CO, !0)), 2 & t && (tc(n = oc()) && (e._content = n.first), tc(n = oc()) && (e._allDrawers = n)) }, hostAttrs: [1, "mat-drawer-container", "mat-sidenav-container"], hostVars: 2, hostBindings: function(t, e) { 2 & t && no("mat-drawer-container-explicit-backdrop", e._backdropOverride) }, exportAs: ["matSidenavContainer"], features: [Ho([{ provide: _O, useExisting: t }]), Eo], ngContentSelectors: mO, decls: 4, vars: 2, consts: [
                ["class", "mat-drawer-backdrop", 3, "mat-drawer-shown", "click", 4, "ngIf"],
                ["cdkScrollable", "", 4, "ngIf"],
                [1, "mat-drawer-backdrop", 3, "click"],
                ["cdkScrollable", ""]
            ], template: function(t, e) { 1 & t && ($a(uO), Ca(0, hO, 1, 2, "div", 0), Wa(1), Wa(2, 1), Ca(3, dO, 2, 0, "mat-sidenav-content", 1)), 2 & t && (Da("ngIf", e.hasBackdrop), ps(3), Da("ngIf", !e._content)) }, directives: [yd, wO, uD], styles: [".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\n"], encapsulation: 2, changeDetection: 0 }), t })();
    const kO = ln(SO);
    let EO = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [Jd, _S, pD, qv], _S
            ] }), t })();
    const DO = ["*", [
        ["mat-toolbar-row"]
    ]], AO = ["*", "mat-toolbar-row"]; class IO { constructor(t) { this._elementRef = t } }
    const TO = yS(IO);
    let OO = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-toolbar-row"]
            ], hostAttrs: [1, "mat-toolbar-row"], exportAs: ["matToolbarRow"] }), t })(), RO = (() => { class t extends TO { constructor(t, e, i) { super(t), this._platform = e, this._document = i } ngAfterViewInit() { Sn() && this._platform.isBrowser && (this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes())) } _checkToolbarMixedModes() { this._toolbarRows.length && Array.from(this._elementRef.nativeElement.childNodes).filter(t => !(t.classList && t.classList.contains("mat-toolbar-row"))).filter(t => t.nodeType !== (this._document ? this._document.COMMENT_NODE : 8)).some(t => !(!t.textContent || !t.textContent.trim())) && function() { throw Error("MatToolbar: Attempting to combine different toolbar modes. Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content inside of a `<mat-toolbar>` for a single row.") }() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Wv), Sa(uh)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-toolbar"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, OO, !0), 2 & t && tc(n = oc()) && (e._toolbarRows = n) }, hostAttrs: [1, "mat-toolbar"], hostVars: 4, hostBindings: function(t, e) { 2 & t && no("mat-toolbar-multiple-rows", e._toolbarRows.length > 0)("mat-toolbar-single-row", 0 === e._toolbarRows.length) }, inputs: { color: "color" }, exportAs: ["matToolbar"], features: [Eo], ngContentSelectors: AO, decls: 2, vars: 0, template: function(t, e) { 1 & t && ($a(DO), Wa(0), Wa(1, 1)) }, styles: [".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}\n"], encapsulation: 2, changeDetection: 0 }), t })(), MO = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [_S], _S
            ] }), t })();
    const PO = ["*"], FO = [
        [
            ["", "mat-list-avatar", ""],
            ["", "mat-list-icon", ""],
            ["", "matListAvatar", ""],
            ["", "matListIcon", ""]
        ],
        [
            ["", "mat-line", ""],
            ["", "matLine", ""]
        ], "*"
    ], NO = ["[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]", "[mat-line], [matLine]", "*"], LO = ["text"];

    function BO(t, e) { if (1 & t && Oa(0, "mat-pseudo-checkbox", 5), 2 & t) { const t = ja();
            Da("state", t.selected ? "checked" : "unchecked")("disabled", t.disabled) } }
    const VO = ["*", [
        ["", "mat-list-avatar", ""],
        ["", "mat-list-icon", ""],
        ["", "matListAvatar", ""],
        ["", "matListIcon", ""]
    ]], zO = ["*", "[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]"]; class UO {}
    const HO = bS(vS(UO)); class jO {}
    const GO = vS(jO);
    let $O = (() => { class t extends HO { constructor() { super(...arguments), this._stateChanges = new k } ngOnChanges() { this._stateChanges.next() } ngOnDestroy() { this._stateChanges.complete() } } return t.\u0275fac = function(e) { return WO(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-nav-list"]
            ], hostAttrs: ["role", "navigation", 1, "mat-nav-list", "mat-list-base"], inputs: { disableRipple: "disableRipple", disabled: "disabled" }, exportAs: ["matNavList"], features: [Eo, Ro], ngContentSelectors: PO, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(), Wa(0)) }, styles: ['.mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0;position:relative}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0;position:relative}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:none}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:none}.mat-list-item-disabled{pointer-events:none}.cdk-high-contrast-active .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active :host .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active .mat-selection-list:focus{outline-style:dotted}.cdk-high-contrast-active .mat-list-option:hover,.cdk-high-contrast-active .mat-list-option:focus,.cdk-high-contrast-active .mat-nav-list .mat-list-item:hover,.cdk-high-contrast-active .mat-nav-list .mat-list-item:focus,.cdk-high-contrast-active mat-action-list .mat-list-item:hover,.cdk-high-contrast-active mat-action-list .mat-list-item:focus{outline:dotted 1px}.cdk-high-contrast-active .mat-list-single-selected-option::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active [dir=rtl] .mat-list-single-selected-option::after{right:auto;left:16px}@media(hover: none){.mat-list-option:not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover{background:none}}\n'], encapsulation: 2, changeDetection: 0 }), t })();
    const WO = ln($O);
    let qO = (() => { class t extends HO { constructor(t) { super(), this._elementRef = t, this._stateChanges = new k, "action-list" === this._getListType() && t.nativeElement.classList.add("mat-action-list") } _getListType() { const t = this._elementRef.nativeElement.nodeName.toLowerCase(); return "mat-list" === t ? "list" : "mat-action-list" === t ? "action-list" : null } ngOnChanges() { this._stateChanges.next() } ngOnDestroy() { this._stateChanges.complete() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-list"],
                ["mat-action-list"]
            ], hostAttrs: [1, "mat-list", "mat-list-base"], inputs: { disableRipple: "disableRipple", disabled: "disabled" }, exportAs: ["matList"], features: [Eo, Ro], ngContentSelectors: PO, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(), Wa(0)) }, styles: ['.mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0;position:relative}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0;position:relative}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:none}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:none}.mat-list-item-disabled{pointer-events:none}.cdk-high-contrast-active .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active :host .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active .mat-selection-list:focus{outline-style:dotted}.cdk-high-contrast-active .mat-list-option:hover,.cdk-high-contrast-active .mat-list-option:focus,.cdk-high-contrast-active .mat-nav-list .mat-list-item:hover,.cdk-high-contrast-active .mat-nav-list .mat-list-item:focus,.cdk-high-contrast-active mat-action-list .mat-list-item:hover,.cdk-high-contrast-active mat-action-list .mat-list-item:focus{outline:dotted 1px}.cdk-high-contrast-active .mat-list-single-selected-option::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active [dir=rtl] .mat-list-single-selected-option::after{right:auto;left:16px}@media(hover: none){.mat-list-option:not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover{background:none}}\n'], encapsulation: 2, changeDetection: 0 }), t })(), YO = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-list-avatar", ""],
                ["", "matListAvatar", ""]
            ], hostAttrs: [1, "mat-list-avatar"] }), t })(), XO = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-list-icon", ""],
                ["", "matListIcon", ""]
            ], hostAttrs: [1, "mat-list-icon"] }), t })(), KO = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-subheader", ""],
                ["", "matSubheader", ""]
            ], hostAttrs: [1, "mat-subheader"] }), t })(), ZO = (() => { class t extends GO { constructor(t, e, i, n) { super(), this._element = t, this._isInteractiveList = !1, this._destroyed = new k, this._disabled = !1, this._isInteractiveList = !!(i || n && "action-list" === n._getListType()), this._list = i || n; const s = this._getHostElement(); "button" !== s.nodeName.toLowerCase() || s.hasAttribute("type") || s.setAttribute("type", "button"), this._list && this._list._stateChanges.pipe(jk(this._destroyed)).subscribe(() => { e.markForCheck() }) } get disabled() { return this._disabled || !(!this._list || !this._list.disabled) } set disabled(t) { this._disabled = Vv(t) } ngAfterContentInit() { VS(this._lines, this._element) } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _isRippleDisabled() { return !this._isInteractiveList || this.disableRipple || !(!this._list || !this._list.disableRipple) } _getHostElement() { return this._element.nativeElement } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa($O, 8), Sa(qO, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-list-item"],
                ["a", "mat-list-item", ""],
                ["button", "mat-list-item", ""]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, YO, !0), sc(i, XO, !0), sc(i, BS, !0)), 2 & t && (tc(n = oc()) && (e._avatar = n.first), tc(n = oc()) && (e._icon = n.first), tc(n = oc()) && (e._lines = n)) }, hostAttrs: [1, "mat-list-item", "mat-focus-indicator"], hostVars: 6, hostBindings: function(t, e) { 2 & t && no("mat-list-item-disabled", e.disabled)("mat-list-item-avatar", e._avatar || e._icon)("mat-list-item-with-avatar", e._avatar || e._icon) }, inputs: { disableRipple: "disableRipple", disabled: "disabled" }, exportAs: ["matListItem"], features: [Eo], ngContentSelectors: NO, decls: 6, vars: 2, consts: [
                [1, "mat-list-item-content"],
                ["mat-ripple", "", 1, "mat-list-item-ripple", 3, "matRippleTrigger", "matRippleDisabled"],
                [1, "mat-list-text"]
            ], template: function(t, e) { 1 & t && ($a(FO), Ia(0, "div", 0), Oa(1, "div", 1), Wa(2), Ia(3, "div", 2), Wa(4, 1), Ta(), Wa(5, 2), Ta()), 2 & t && (ps(1), Da("matRippleTrigger", e._getHostElement())("matRippleDisabled", e._isRippleDisabled())) }, directives: [qS], encapsulation: 2, changeDetection: 0 }), t })(); class QO {}
    const JO = vS(QO); class tR {}
    const eR = vS(tR), iR = { provide: vg, useExisting: St(() => rR), multi: !0 }; class nR { constructor(t, e) { this.source = t, this.option = e } }
    let sR = (() => { class t extends eR { constructor(t, e, i) { super(), this._element = t, this._changeDetector = e, this.selectionList = i, this._selected = !1, this._disabled = !1, this._hasFocus = !1, this.checkboxPosition = "after", this._inputsInitialized = !1 } get color() { return this._color || this.selectionList.color } set color(t) { this._color = t } get value() { return this._value } set value(t) { this.selected && t !== this.value && this._inputsInitialized && (this.selected = !1), this._value = t } get disabled() { return this._disabled || this.selectionList && this.selectionList.disabled } set disabled(t) { const e = Vv(t);
                e !== this._disabled && (this._disabled = e, this._changeDetector.markForCheck()) } get selected() { return this.selectionList.selectedOptions.isSelected(this) } set selected(t) { const e = Vv(t);
                e !== this._selected && (this._setSelected(e), this.selectionList._reportValueChange()) } ngOnInit() { const t = this.selectionList;
                t._value && t._value.some(e => t.compareWith(e, this._value)) && this._setSelected(!0); const e = this._selected;
                Promise.resolve().then(() => {
                    (this._selected || e) && (this.selected = !0, this._changeDetector.markForCheck()) }), this._inputsInitialized = !0 } ngAfterContentInit() { VS(this._lines, this._element) } ngOnDestroy() { this.selected && Promise.resolve().then(() => { this.selected = !1 }); const t = this._hasFocus,
                    e = this.selectionList._removeOptionFromList(this);
                t && e && e.focus() } toggle() { this.selected = !this.selected } focus() { this._element.nativeElement.focus() } getLabel() { return this._text && this._text.nativeElement.textContent || "" } _isRippleDisabled() { return this.disabled || this.disableRipple || this.selectionList.disableRipple } _handleClick() { this.disabled || !this.selectionList.multiple && this.selected || (this.toggle(), this.selectionList._emitChangeEvent(this)) } _handleFocus() { this.selectionList._setFocusedOption(this), this._hasFocus = !0 } _handleBlur() { this.selectionList._onTouched(), this._hasFocus = !1 } _getHostElement() { return this._element.nativeElement } _setSelected(t) { return t !== this._selected && (this._selected = t, t ? this.selectionList.selectedOptions.select(this) : this.selectionList.selectedOptions.deselect(this), this._changeDetector.markForCheck(), !0) } _markForCheck() { this._changeDetector.markForCheck() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(St(() => rR))) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-list-option"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, YO, !0), sc(i, XO, !0), sc(i, BS, !0)), 2 & t && (tc(n = oc()) && (e._avatar = n.first), tc(n = oc()) && (e._icon = n.first), tc(n = oc()) && (e._lines = n)) }, viewQuery: function(t, e) { var i;
                1 & t && ic(LO, !0), 2 & t && tc(i = oc()) && (e._text = i.first) }, hostAttrs: ["role", "option", 1, "mat-list-item", "mat-list-option", "mat-focus-indicator"], hostVars: 15, hostBindings: function(t, e) { 1 & t && Ba("focus", (function() { return e._handleFocus() }))("blur", (function() { return e._handleBlur() }))("click", (function() { return e._handleClick() })), 2 & t && (va("aria-selected", e.selected)("aria-disabled", e.disabled)("tabindex", -1), no("mat-list-item-disabled", e.disabled)("mat-list-item-with-avatar", e._avatar || e._icon)("mat-primary", "primary" === e.color)("mat-accent", "primary" !== e.color && "warn" !== e.color)("mat-warn", "warn" === e.color)("mat-list-single-selected-option", e.selected && !e.selectionList.multiple)) }, inputs: { disableRipple: "disableRipple", checkboxPosition: "checkboxPosition", color: "color", value: "value", selected: "selected", disabled: "disabled" }, exportAs: ["matListOption"], features: [Eo], ngContentSelectors: zO, decls: 7, vars: 5, consts: [
                [1, "mat-list-item-content"],
                ["mat-ripple", "", 1, "mat-list-item-ripple", 3, "matRippleTrigger", "matRippleDisabled"],
                [3, "state", "disabled", 4, "ngIf"],
                [1, "mat-list-text"],
                ["text", ""],
                [3, "state", "disabled"]
            ], template: function(t, e) { 1 & t && ($a(VO), Ia(0, "div", 0), Oa(1, "div", 1), Ca(2, BO, 1, 2, "mat-pseudo-checkbox", 2), Ia(3, "div", 3, 4), Wa(5), Ta(), Wa(6, 1), Ta()), 2 & t && (no("mat-list-item-content-reverse", "after" == e.checkboxPosition), ps(1), Da("matRippleTrigger", e._getHostElement())("matRippleDisabled", e._isRippleDisabled()), ps(1), Da("ngIf", e.selectionList.multiple)) }, directives: [qS, yd, XS], encapsulation: 2, changeDetection: 0 }), t })(), rR = (() => { class t extends JO { constructor(t, e, i) { super(), this._element = t, this._changeDetector = i, this._multiple = !0, this._contentInitialized = !1, this.selectionChange = new jl, this.tabIndex = 0, this.color = "accent", this.compareWith = (t, e) => t === e, this._disabled = !1, this.selectedOptions = new cD(this._multiple), this._tabIndex = -1, this._onChange = t => {}, this._destroyed = new k, this._onTouched = () => {} } get disabled() { return this._disabled } set disabled(t) { this._disabled = Vv(t), this._markOptionsForCheck() } get multiple() { return this._multiple } set multiple(t) { const e = Vv(t); if (e !== this._multiple) { if (Sn() && this._contentInitialized) throw new Error("Cannot change `multiple` mode of mat-selection-list after initialization.");
                    this._multiple = e, this.selectedOptions = new cD(this._multiple, this.selectedOptions.selected) } } ngAfterContentInit() { this._contentInitialized = !0, this._keyManager = new mw(this.options).withWrap().withTypeAhead().skipPredicate(() => !1).withAllowedModifierKeys(["shiftKey"]), this._value && this._setOptionsFromValues(this._value), this._keyManager.tabOut.pipe(jk(this._destroyed)).subscribe(() => { this._allowFocusEscape() }), this.options.changes.pipe(bm(null), jk(this._destroyed)).subscribe(() => { this._updateTabIndex() }), this.selectedOptions.changed.pipe(jk(this._destroyed)).subscribe(t => { if (t.added)
                        for (let e of t.added) e.selected = !0; if (t.removed)
                        for (let e of t.removed) e.selected = !1 }) } ngOnChanges(t) { const e = t.disableRipple,
                    i = t.color;
                (e && !e.firstChange || i && !i.firstChange) && this._markOptionsForCheck() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete(), this._isDestroyed = !0 } focus(t) { this._element.nativeElement.focus(t) } selectAll() { this._setAllOptionsSelected(!0) } deselectAll() { this._setAllOptionsSelected(!1) } _setFocusedOption(t) { this._keyManager.updateActiveItem(t) } _removeOptionFromList(t) { const e = this._getOptionIndex(t); return e > -1 && this._keyManager.activeItemIndex === e && (e > 0 ? this._keyManager.updateActiveItem(e - 1) : 0 === e && this.options.length > 1 && this._keyManager.updateActiveItem(Math.min(e + 1, this.options.length - 1))), this._keyManager.activeItem } _keydown(t) { const e = t.keyCode,
                    i = this._keyManager,
                    n = i.activeItemIndex,
                    s = Iv(t); switch (e) {
                    case 32:
                    case 13:
                        s || i.isTyping() || (this._toggleFocusedOption(), t.preventDefault()); break;
                    case 36:
                    case 35:
                        s || (36 === e ? i.setFirstItemActive() : i.setLastItemActive(), t.preventDefault()); break;
                    default:
                        65 === e && this.multiple && Iv(t, "ctrlKey") && !i.isTyping() ? (this.options.find(t => !t.selected) ? this.selectAll() : this.deselectAll(), t.preventDefault()) : i.onKeydown(t) } this.multiple && (38 === e || 40 === e) && t.shiftKey && i.activeItemIndex !== n && this._toggleFocusedOption() } _reportValueChange() { if (this.options && !this._isDestroyed) { const t = this._getSelectedOptionValues();
                    this._onChange(t), this._value = t } } _emitChangeEvent(t) { this.selectionChange.emit(new nR(this, t)) } _onFocus() { const t = this._keyManager.activeItemIndex;
                t && -1 !== t ? this._keyManager.setActiveItem(t) : this._keyManager.setFirstItemActive() } writeValue(t) { this._value = t, this.options && this._setOptionsFromValues(t || []) } setDisabledState(t) { this.disabled = t } registerOnChange(t) { this._onChange = t } registerOnTouched(t) { this._onTouched = t } _setOptionsFromValues(t) { this.options.forEach(t => t._setSelected(!1)), t.forEach(t => { const e = this.options.find(e => !e.selected && this.compareWith(e.value, t));
                    e && e._setSelected(!0) }) } _getSelectedOptionValues() { return this.options.filter(t => t.selected).map(t => t.value) } _toggleFocusedOption() { let t = this._keyManager.activeItemIndex; if (null != t && this._isValidIndex(t)) { let e = this.options.toArray()[t];!e || e.disabled || !this._multiple && e.selected || (e.toggle(), this._emitChangeEvent(e)) } } _setAllOptionsSelected(t) { let e = !1;
                this.options.forEach(i => { i._setSelected(t) && (e = !0) }), e && this._reportValueChange() } _isValidIndex(t) { return t >= 0 && t < this.options.length } _getOptionIndex(t) { return this.options.toArray().indexOf(t) } _markOptionsForCheck() { this.options && this.options.forEach(t => t._markForCheck()) } _allowFocusEscape() { this._tabIndex = -1, setTimeout(() => { this._tabIndex = 0, this._changeDetector.markForCheck() }) } _updateTabIndex() { this._tabIndex = 0 === this.options.length ? -1 : 0 } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), ka("tabindex"), Sa(jr)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-selection-list"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, sR, !0), 2 & t && tc(n = oc()) && (e.options = n) }, hostAttrs: ["role", "listbox", 1, "mat-selection-list", "mat-list-base"], hostVars: 3, hostBindings: function(t, e) { 1 & t && Ba("focus", (function() { return e._onFocus() }))("blur", (function() { return e._onTouched() }))("keydown", (function(t) { return e._keydown(t) })), 2 & t && va("aria-multiselectable", e.multiple)("aria-disabled", e.disabled.toString())("tabindex", e._tabIndex) }, inputs: { disableRipple: "disableRipple", tabIndex: "tabIndex", color: "color", compareWith: "compareWith", disabled: "disabled", multiple: "multiple" }, outputs: { selectionChange: "selectionChange" }, exportAs: ["matSelectionList"], features: [Ho([iR]), Eo, Ro], ngContentSelectors: PO, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(), Wa(0)) }, styles: ['.mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0;position:relative}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0;position:relative}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:none}mat-action-list button{background:none;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:none}.mat-list-item-disabled{pointer-events:none}.cdk-high-contrast-active .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active :host .mat-list-item-disabled{opacity:.5}.cdk-high-contrast-active .mat-selection-list:focus{outline-style:dotted}.cdk-high-contrast-active .mat-list-option:hover,.cdk-high-contrast-active .mat-list-option:focus,.cdk-high-contrast-active .mat-nav-list .mat-list-item:hover,.cdk-high-contrast-active .mat-nav-list .mat-list-item:focus,.cdk-high-contrast-active mat-action-list .mat-list-item:hover,.cdk-high-contrast-active mat-action-list .mat-list-item:focus{outline:dotted 1px}.cdk-high-contrast-active .mat-list-single-selected-option::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}.cdk-high-contrast-active [dir=rtl] .mat-list-single-selected-option::after{right:auto;left:16px}@media(hover: none){.mat-list-option:not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover{background:none}}\n'], encapsulation: 2, changeDetection: 0 }), t })(), aR = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [US, YS, _S, KS, Jd], US, _S, KS, Fk
            ] }), t })();
    const oR = ["*"], lR = [
        [
            ["", "mat-grid-avatar", ""],
            ["", "matGridAvatar", ""]
        ],
        [
            ["", "mat-line", ""],
            ["", "matLine", ""]
        ], "*"
    ], cR = ["[mat-grid-avatar], [matGridAvatar]", "[mat-line], [matLine]", "*"], hR = new Vt("MAT_GRID_LIST");
    let dR = (() => { class t { constructor(t, e) { this._element = t, this._gridList = e, this._rowspan = 1, this._colspan = 1 } get rowspan() { return this._rowspan } set rowspan(t) { this._rowspan = Math.round(zv(t)) } get colspan() { return this._colspan } set colspan(t) { this._colspan = Math.round(zv(t)) } _setStyle(t, e) { this._element.nativeElement.style[t] = e } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(hR, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-grid-tile"]
            ], hostAttrs: [1, "mat-grid-tile"], hostVars: 2, hostBindings: function(t, e) { 2 & t && va("rowspan", e.rowspan)("colspan", e.colspan) }, inputs: { rowspan: "rowspan", colspan: "colspan" }, exportAs: ["matGridTile"], ngContentSelectors: oR, decls: 2, vars: 0, consts: [
                [1, "mat-figure"]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "figure", 0), Wa(1), Ta()) }, styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}\n"], encapsulation: 2, changeDetection: 0 }), t })(), uR = (() => { class t { constructor(t) { this._element = t } ngAfterContentInit() { VS(this._lines, this._element) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-grid-tile-header"],
                ["mat-grid-tile-footer"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, BS, !0), 2 & t && tc(n = oc()) && (e._lines = n) }, ngContentSelectors: cR, decls: 4, vars: 0, consts: [
                [1, "mat-grid-list-text"]
            ], template: function(t, e) { 1 & t && ($a(lR), Wa(0), Ia(1, "div", 0), Wa(2, 1), Ta(), Wa(3, 2)) }, encapsulation: 2, changeDetection: 0 }), t })(), mR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-grid-avatar", ""],
                ["", "matGridAvatar", ""]
            ], hostAttrs: [1, "mat-grid-avatar"] }), t })(), pR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-grid-tile-header"]
            ], hostAttrs: [1, "mat-grid-tile-header"] }), t })(), fR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-grid-tile-footer"]
            ], hostAttrs: [1, "mat-grid-tile-footer"] }), t })(); class gR { constructor() { this.columnIndex = 0, this.rowIndex = 0 } get rowCount() { return this.rowIndex + 1 } get rowspan() { const t = Math.max(...this.tracker); return t > 1 ? this.rowCount + t - 1 : this.rowCount } update(t, e) { this.columnIndex = 0, this.rowIndex = 0, this.tracker = new Array(t), this.tracker.fill(0, 0, this.tracker.length), this.positions = e.map(t => this._trackTile(t)) } _trackTile(t) { const e = this._findMatchingGap(t.colspan); return this._markTilePosition(e, t), this.columnIndex = e + t.colspan, new _R(this.rowIndex, e) } _findMatchingGap(t) { if (t > this.tracker.length) throw Error(`mat-grid-list: tile with colspan ${t} is wider than ` + `grid with cols="${this.tracker.length}".`); let e = -1,
                i = -1;
            do { this.columnIndex + t > this.tracker.length ? (this._nextRow(), e = this.tracker.indexOf(0, this.columnIndex), i = this._findGapEndIndex(e)) : (e = this.tracker.indexOf(0, this.columnIndex), -1 != e ? (i = this._findGapEndIndex(e), this.columnIndex = e + 1) : (this._nextRow(), e = this.tracker.indexOf(0, this.columnIndex), i = this._findGapEndIndex(e))) } while (i - e < t || 0 == i); return Math.max(e, 0) } _nextRow() { this.columnIndex = 0, this.rowIndex++; for (let t = 0; t < this.tracker.length; t++) this.tracker[t] = Math.max(0, this.tracker[t] - 1) } _findGapEndIndex(t) { for (let e = t + 1; e < this.tracker.length; e++)
                if (0 != this.tracker[e]) return e; return this.tracker.length } _markTilePosition(t, e) { for (let i = 0; i < e.colspan; i++) this.tracker[t + i] = e.rowspan } } class _R { constructor(t, e) { this.row = t, this.col = e } }
    const bR = /^-?\d+((\.\d+)?[A-Za-z%$]?)+$/; class yR { constructor() { this._rows = 0, this._rowspan = 0 } init(t, e, i, n) { this._gutterSize = SR(t), this._rows = e.rowCount, this._rowspan = e.rowspan, this._cols = i, this._direction = n } getBaseTileSize(t, e) { return `(${t}% - (${this._gutterSize} * ${e}))` } getTilePosition(t, e) { return 0 === e ? "0" : xR(`(${t} + ${this._gutterSize}) * ${e}`) } getTileSize(t, e) { return `(${t} * ${e}) + (${e-1} * ${this._gutterSize})` } setStyle(t, e, i) { let n = 100 / this._cols,
                s = (this._cols - 1) / this._cols;
            this.setColStyles(t, i, n, s), this.setRowStyles(t, e, n, s) } setColStyles(t, e, i, n) { let s = this.getBaseTileSize(i, n);
            t._setStyle("rtl" === this._direction ? "right" : "left", this.getTilePosition(s, e)), t._setStyle("width", xR(this.getTileSize(s, t.colspan))) } getGutterSpan() { return `${this._gutterSize} * (${this._rowspan} - 1)` } getTileSpan(t) { return `${this._rowspan} * ${this.getTileSize(t,1)}` } getComputedHeight() { return null } } class vR extends yR { constructor(t) { super(), this.fixedRowHeight = t } init(t, e, i, n) { if (super.init(t, e, i, n), this.fixedRowHeight = SR(this.fixedRowHeight), !bR.test(this.fixedRowHeight)) throw Error(`Invalid value "${this.fixedRowHeight}" set as rowHeight.`) } setRowStyles(t, e) { t._setStyle("top", this.getTilePosition(this.fixedRowHeight, e)), t._setStyle("height", xR(this.getTileSize(this.fixedRowHeight, t.rowspan))) } getComputedHeight() { return ["height", xR(`${this.getTileSpan(this.fixedRowHeight)} + ${this.getGutterSpan()}`)] } reset(t) { t._setListStyle(["height", null]), t._tiles && t._tiles.forEach(t => { t._setStyle("top", null), t._setStyle("height", null) }) } } class wR extends yR { constructor(t) { super(), this._parseRatio(t) } setRowStyles(t, e, i, n) { this.baseTileHeight = this.getBaseTileSize(i / this.rowHeightRatio, n), t._setStyle("marginTop", this.getTilePosition(this.baseTileHeight, e)), t._setStyle("paddingTop", xR(this.getTileSize(this.baseTileHeight, t.rowspan))) } getComputedHeight() { return ["paddingBottom", xR(`${this.getTileSpan(this.baseTileHeight)} + ${this.getGutterSpan()}`)] } reset(t) { t._setListStyle(["paddingBottom", null]), t._tiles.forEach(t => { t._setStyle("marginTop", null), t._setStyle("paddingTop", null) }) } _parseRatio(t) { const e = t.split(":"); if (2 !== e.length) throw Error(`mat-grid-list: invalid ratio given for row-height: "${t}"`);
            this.rowHeightRatio = parseFloat(e[0]) / parseFloat(e[1]) } } class CR extends yR { setRowStyles(t, e) { let i = this.getBaseTileSize(100 / this._rowspan, (this._rows - 1) / this._rows);
            t._setStyle("top", this.getTilePosition(i, e)), t._setStyle("height", xR(this.getTileSize(i, t.rowspan))) } reset(t) { t._tiles && t._tiles.forEach(t => { t._setStyle("top", null), t._setStyle("height", null) }) } }

    function xR(t) { return `calc(${t})` }

    function SR(t) { return t.match(/([A-Za-z%]+)$/) ? t : `${t}px` }
    let kR = (() => { class t { constructor(t, e) { this._element = t, this._dir = e, this._gutter = "1px" } get cols() { return this._cols } set cols(t) { this._cols = Math.max(1, Math.round(zv(t))) } get gutterSize() { return this._gutter } set gutterSize(t) { this._gutter = `${null==t?"":t}` } get rowHeight() { return this._rowHeight } set rowHeight(t) { const e = `${null==t?"":t}`;
                e !== this._rowHeight && (this._rowHeight = e, this._setTileStyler(this._rowHeight)) } ngOnInit() { this._checkCols(), this._checkRowHeight() } ngAfterContentChecked() { this._layoutTiles() } _checkCols() { if (!this.cols) throw Error('mat-grid-list: must pass in number of columns. Example: <mat-grid-list cols="3">') } _checkRowHeight() { this._rowHeight || this._setTileStyler("1:1") } _setTileStyler(t) { this._tileStyler && this._tileStyler.reset(this), this._tileStyler = "fit" === t ? new CR : t && t.indexOf(":") > -1 ? new wR(t) : new vR(t) } _layoutTiles() { this._tileCoordinator || (this._tileCoordinator = new gR); const t = this._tileCoordinator,
                    e = this._tiles.filter(t => !t._gridList || t._gridList === this),
                    i = this._dir ? this._dir.value : "ltr";
                this._tileCoordinator.update(this.cols, e), this._tileStyler.init(this.gutterSize, t, this.cols, i), e.forEach((e, i) => { const n = t.positions[i];
                    this._tileStyler.setStyle(e, n.row, n.col) }), this._setListStyle(this._tileStyler.getComputedHeight()) } _setListStyle(t) { t && (this._element.nativeElement.style[t[0]] = t[1]) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Rw, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-grid-list"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, dR, !0), 2 & t && tc(n = oc()) && (e._tiles = n) }, hostAttrs: [1, "mat-grid-list"], hostVars: 1, hostBindings: function(t, e) { 2 & t && va("cols", e.cols) }, inputs: { cols: "cols", gutterSize: "gutterSize", rowHeight: "rowHeight" }, exportAs: ["matGridList"], features: [Ho([{ provide: hR, useExisting: t }])], ngContentSelectors: oR, decls: 2, vars: 0, template: function(t, e) { 1 & t && ($a(), Ia(0, "div"), Wa(1), Ta()) }, styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}\n"], encapsulation: 2, changeDetection: 0 }), t })(), ER = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [US, _S], US, _S
            ] }), t })();
    const DR = ["*", [
        ["mat-card-footer"]
    ]], AR = ["*", "mat-card-footer"], IR = [
        [
            ["", "mat-card-avatar", ""],
            ["", "matCardAvatar", ""]
        ],
        [
            ["mat-card-title"],
            ["mat-card-subtitle"],
            ["", "mat-card-title", ""],
            ["", "mat-card-subtitle", ""],
            ["", "matCardTitle", ""],
            ["", "matCardSubtitle", ""]
        ], "*"
    ], TR = ["[mat-card-avatar], [matCardAvatar]", "mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]", "*"], OR = [
        [
            ["mat-card-title"],
            ["mat-card-subtitle"],
            ["", "mat-card-title", ""],
            ["", "mat-card-subtitle", ""],
            ["", "matCardTitle", ""],
            ["", "matCardSubtitle", ""]
        ],
        [
            ["img"]
        ], "*"
    ], RR = ["mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]", "img", "*"];
    let MR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-card-content"],
                ["", "mat-card-content", ""],
                ["", "matCardContent", ""]
            ], hostAttrs: [1, "mat-card-content"] }), t })(), PR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-card-title"],
                ["", "mat-card-title", ""],
                ["", "matCardTitle", ""]
            ], hostAttrs: [1, "mat-card-title"] }), t })(), FR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-card-subtitle"],
                ["", "mat-card-subtitle", ""],
                ["", "matCardSubtitle", ""]
            ], hostAttrs: [1, "mat-card-subtitle"] }), t })(), NR = (() => { class t { constructor() { this.align = "start" } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-card-actions"]
            ], hostAttrs: [1, "mat-card-actions"], hostVars: 2, hostBindings: function(t, e) { 2 & t && no("mat-card-actions-align-end", "end" === e.align) }, inputs: { align: "align" }, exportAs: ["matCardActions"] }), t })(), LR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-card-footer"]
            ], hostAttrs: [1, "mat-card-footer"] }), t })(), BR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-card-image", ""],
                ["", "matCardImage", ""]
            ], hostAttrs: [1, "mat-card-image"] }), t })(), VR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-card-sm-image", ""],
                ["", "matCardImageSmall", ""]
            ], hostAttrs: [1, "mat-card-sm-image"] }), t })(), zR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-card-md-image", ""],
                ["", "matCardImageMedium", ""]
            ], hostAttrs: [1, "mat-card-md-image"] }), t })(), UR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-card-lg-image", ""],
                ["", "matCardImageLarge", ""]
            ], hostAttrs: [1, "mat-card-lg-image"] }), t })(), HR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-card-xl-image", ""],
                ["", "matCardImageXLarge", ""]
            ], hostAttrs: [1, "mat-card-xl-image"] }), t })(), jR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-card-avatar", ""],
                ["", "matCardAvatar", ""]
            ], hostAttrs: [1, "mat-card-avatar"] }), t })(), GR = (() => { class t { constructor(t) { this._animationMode = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(aS, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-card"]
            ], hostAttrs: [1, "mat-card", "mat-focus-indicator"], hostVars: 2, hostBindings: function(t, e) { 2 & t && no("_mat-animation-noopable", "NoopAnimations" === e._animationMode) }, exportAs: ["matCard"], ngContentSelectors: AR, decls: 2, vars: 0, template: function(t, e) { 1 & t && ($a(DR), Wa(0), Wa(1, 1)) }, styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child,.mat-card-actions .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), $R = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-card-header"]
            ], hostAttrs: [1, "mat-card-header"], ngContentSelectors: TR, decls: 4, vars: 0, consts: [
                [1, "mat-card-header-text"]
            ], template: function(t, e) { 1 & t && ($a(IR), Wa(0), Ia(1, "div", 0), Wa(2, 1), Ta(), Wa(3, 2)) }, encapsulation: 2, changeDetection: 0 }), t })(), WR = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-card-title-group"]
            ], hostAttrs: [1, "mat-card-title-group"], ngContentSelectors: RR, decls: 4, vars: 0, template: function(t, e) { 1 & t && ($a(OR), Ia(0, "div"), Wa(1), Ta(), Wa(2, 1), Wa(3, 2)) }, encapsulation: 2, changeDetection: 0 }), t })(), qR = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [_S], _S
            ] }), t })();

    function YR(t, e) { 1 & t && Wa(0) }
    const XR = ["*"];
    let KR = (() => { class t { constructor(t) { this._elementRef = t } focus() { this._elementRef.nativeElement.focus() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkStepHeader", ""]
            ], hostAttrs: ["role", "tab"] }), t })(), ZR = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkStepLabel", ""]
            ] }), t })(), QR = 0;
    const JR = new Vt("STEPPER_GLOBAL_OPTIONS");
    let tM = (() => { class t { constructor(t, e) { this._stepper = t, this.interacted = !1, this._editable = !0, this._optional = !1, this._completedOverride = null, this._customError = null, this._stepperOptions = e || {}, this._displayDefaultIndicatorType = !1 !== this._stepperOptions.displayDefaultIndicatorType, this._showError = !!this._stepperOptions.showError } get editable() { return this._editable } set editable(t) { this._editable = Vv(t) } get optional() { return this._optional } set optional(t) { this._optional = Vv(t) } get completed() { return null == this._completedOverride ? this._getDefaultCompleted() : this._completedOverride } set completed(t) { this._completedOverride = Vv(t) } _getDefaultCompleted() { return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted } get hasError() { return null == this._customError ? this._getDefaultError() : this._customError } set hasError(t) { this._customError = Vv(t) } _getDefaultError() { return this.stepControl && this.stepControl.invalid && this.interacted } select() { this._stepper.selected = this } reset() { this.interacted = !1, null != this._completedOverride && (this._completedOverride = !1), null != this._customError && (this._customError = !1), this.stepControl && this.stepControl.reset() } ngOnChanges() { this._stepper._stateChanged() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(St(() => eM)), Sa(JR, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["cdk-step"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, ZR, !0), 2 & t && tc(n = oc()) && (e.stepLabel = n.first) }, viewQuery: function(t, e) { var i;
                1 & t && ec(gl, !0), 2 & t && tc(i = oc()) && (e.content = i.first) }, inputs: { editable: "editable", optional: "optional", completed: "completed", hasError: "hasError", stepControl: "stepControl", label: "label", errorMessage: "errorMessage", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], state: "state" }, exportAs: ["cdkStep"], features: [Ro], ngContentSelectors: XR, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(), Ca(0, YR, 1, 0, "ng-template")) }, encapsulation: 2, changeDetection: 0 }), t })(), eM = (() => { class t { constructor(t, e, i, n) { this._dir = t, this._changeDetectorRef = e, this._elementRef = i, this._destroyed = new k, this._linear = !1, this._selectedIndex = 0, this.selectionChange = new jl, this._orientation = "horizontal", this._groupId = QR++, this._document = n } get steps() { return this._steps } get linear() { return this._linear } set linear(t) { this._linear = Vv(t) } get selectedIndex() { return this._selectedIndex } set selectedIndex(t) { const e = zv(t); if (this.steps) { if (e < 0 || e > this.steps.length - 1) throw Error("cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.");
                    this._selectedIndex != e && !this._anyControlsInvalidOrPending(e) && (e >= this._selectedIndex || this.steps.toArray()[e].editable) && this._updateSelectedItemIndex(t) } else this._selectedIndex = e } get selected() { return this.steps ? this.steps.toArray()[this.selectedIndex] : void 0 } set selected(t) { this.selectedIndex = this.steps ? this.steps.toArray().indexOf(t) : -1 } ngAfterViewInit() { this._keyManager = new mw(this._stepHeader).withWrap().withVerticalOrientation("vertical" === this._orientation), (this._dir ? this._dir.change : Mu()).pipe(bm(this._layoutDirection()), jk(this._destroyed)).subscribe(t => this._keyManager.withHorizontalOrientation(t)), this._keyManager.updateActiveItem(this._selectedIndex), this.steps.changes.pipe(jk(this._destroyed)).subscribe(() => { this.selected || (this._selectedIndex = Math.max(this._selectedIndex - 1, 0)) }) } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } next() { this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1) } previous() { this.selectedIndex = Math.max(this._selectedIndex - 1, 0) } reset() { this._updateSelectedItemIndex(0), this.steps.forEach(t => t.reset()), this._stateChanged() } _getStepLabelId(t) { return `cdk-step-label-${this._groupId}-${t}` } _getStepContentId(t) { return `cdk-step-content-${this._groupId}-${t}` } _stateChanged() { this._changeDetectorRef.markForCheck() } _getAnimationDirection(t) { const e = t - this._selectedIndex; return e < 0 ? "rtl" === this._layoutDirection() ? "next" : "previous" : e > 0 ? "rtl" === this._layoutDirection() ? "previous" : "next" : "current" } _getIndicatorType(t, e = "number") { const i = this.steps.toArray()[t],
                    n = this._isCurrentStep(t); return i._displayDefaultIndicatorType ? this._getDefaultIndicatorLogic(i, n) : this._getGuidelineLogic(i, n, e) } _getDefaultIndicatorLogic(t, e) { return t._showError && t.hasError && !e ? "error" : !t.completed || e ? "number" : t.editable ? "edit" : "done" } _getGuidelineLogic(t, e, i = "number") { return t._showError && t.hasError && !e ? "error" : t.completed && !e ? "done" : t.completed && e ? i : t.editable && e ? "edit" : i } _isCurrentStep(t) { return this._selectedIndex === t } _getFocusIndex() { return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex } _updateSelectedItemIndex(t) { const e = this.steps.toArray();
                this.selectionChange.emit({ selectedIndex: t, previouslySelectedIndex: this._selectedIndex, selectedStep: e[t], previouslySelectedStep: e[this._selectedIndex] }), this._containsFocus() ? this._keyManager.setActiveItem(t) : this._keyManager.updateActiveItem(t), this._selectedIndex = t, this._stateChanged() } _onKeydown(t) { const e = Iv(t),
                    i = t.keyCode,
                    n = this._keyManager;
                null == n.activeItemIndex || e || 32 !== i && 13 !== i ? 36 === i ? (n.setFirstItemActive(), t.preventDefault()) : 35 === i ? (n.setLastItemActive(), t.preventDefault()) : n.onKeydown(t) : (this.selectedIndex = n.activeItemIndex, t.preventDefault()) } _anyControlsInvalidOrPending(t) { const e = this.steps.toArray(); return e[this._selectedIndex].interacted = !0, !!(this._linear && t >= 0) && e.slice(0, t).some(t => { const e = t.stepControl; return (e ? e.invalid || e.pending || !t.interacted : !t.completed) && !t.optional && !t._completedOverride }) } _layoutDirection() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } _containsFocus() { if (!this._document || !this._elementRef) return !1; const t = this._elementRef.nativeElement,
                    e = this._document.activeElement; return t === e || t.contains(e) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Rw, 8), Sa(jr), Sa(Wo), Sa(uh)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkStepper", ""]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, tM, !0), sc(i, KR, !0)), 2 & t && (tc(n = oc()) && (e._steps = n), tc(n = oc()) && (e._stepHeader = n)) }, inputs: { linear: "linear", selectedIndex: "selectedIndex", selected: "selected" }, outputs: { selectionChange: "selectionChange" }, exportAs: ["cdkStepper"] }), t })(), iM = (() => { class t { constructor(t) { this._stepper = t, this.type = "submit" } _handleClick() { this._stepper.next() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(eM)) }, t.\u0275dir = we({ type: t, selectors: [
                ["button", "cdkStepperNext", ""]
            ], hostVars: 1, hostBindings: function(t, e) { 1 & t && Ba("click", (function() { return e._handleClick() })), 2 & t && xo("type", e.type) }, inputs: { type: "type" } }), t })(), nM = (() => { class t { constructor(t) { this._stepper = t, this.type = "button" } _handleClick() { this._stepper.previous() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(eM)) }, t.\u0275dir = we({ type: t, selectors: [
                ["button", "cdkStepperPrevious", ""]
            ], hostVars: 1, hostBindings: function(t, e) { 1 & t && Ba("click", (function() { return e._handleClick() })), 2 & t && xo("type", e.type) }, inputs: { type: "type" } }), t })(), sM = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [Pw]
            ] }), t })();
    const rM = ["*"];

    function aM(t) { return Error(`Unable to find icon with the name "${t}"`) }

    function oM(t) { return Error("The URL provided to MatIconRegistry was not trusted as a resource URL " + `via Angular's DomSanitizer. Attempted URL was "${t}".`) }

    function lM(t) { return Error("The literal provided to MatIconRegistry was not trusted as safe HTML by " + `Angular's DomSanitizer. Attempted literal was "${t}".`) } class cM { constructor(t, e) { this.options = e, t.nodeName ? this.svgElement = t : this.url = t } }
    let hM = (() => { class t { constructor(t, e, i, n) { this._httpClient = t, this._sanitizer = e, this._errorHandler = n, this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._defaultFontSetClass = "material-icons", this._document = i } addSvgIcon(t, e, i) { return this.addSvgIconInNamespace("", t, e, i) } addSvgIconLiteral(t, e, i) { return this.addSvgIconLiteralInNamespace("", t, e, i) } addSvgIconInNamespace(t, e, i, n) { return this._addSvgIconConfig(t, e, new cM(i, n)) } addSvgIconLiteralInNamespace(t, e, i, n) { const s = this._sanitizer.sanitize(qn.HTML, i); if (!s) throw lM(i); const r = this._createSvgElementForSingleIcon(s, n); return this._addSvgIconConfig(t, e, new cM(r, n)) } addSvgIconSet(t, e) { return this.addSvgIconSetInNamespace("", t, e) } addSvgIconSetLiteral(t, e) { return this.addSvgIconSetLiteralInNamespace("", t, e) } addSvgIconSetInNamespace(t, e, i) { return this._addSvgIconSetConfig(t, new cM(e, i)) } addSvgIconSetLiteralInNamespace(t, e, i) { const n = this._sanitizer.sanitize(qn.HTML, e); if (!n) throw lM(e); const s = this._svgElementFromString(n); return this._addSvgIconSetConfig(t, new cM(s, i)) } registerFontClassAlias(t, e = t) { return this._fontCssClassesByAlias.set(t, e), this } classNameForFontAlias(t) { return this._fontCssClassesByAlias.get(t) || t } setDefaultFontSetClass(t) { return this._defaultFontSetClass = t, this } getDefaultFontSetClass() { return this._defaultFontSetClass } getSvgIconFromUrl(t) { const e = this._sanitizer.sanitize(qn.RESOURCE_URL, t); if (!e) throw oM(t); const i = this._cachedIconsByUrl.get(e); return i ? Mu(dM(i)) : this._loadSvgIconFromConfig(new cM(t)).pipe(Sm(t => this._cachedIconsByUrl.set(e, t)), L(t => dM(t))) } getNamedSvgIcon(t, e = "") { const i = uM(e, t),
                    n = this._svgIconConfigs.get(i); if (n) return this._getSvgFromConfig(n); const s = this._iconSetConfigs.get(e); return s ? this._getSvgFromIconSetConfigs(t, s) : eD(aM(i)) } ngOnDestroy() { this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear() } _getSvgFromConfig(t) { return t.svgElement ? Mu(dM(t.svgElement)) : this._loadSvgIconFromConfig(t).pipe(Sm(e => t.svgElement = e), L(t => dM(t))) } _getSvgFromIconSetConfigs(t, e) { const i = this._extractIconWithNameFromAnySet(t, e); return i ? Mu(i) : bg(e.filter(t => !t.svgElement).map(t => this._loadSvgIconSetFromConfig(t).pipe(rm(e => { const i = `Loading icon set URL: ${this._sanitizer.sanitize(qn.RESOURCE_URL,t.url)} failed: ${e.message}`; return this._errorHandler ? this._errorHandler.handleError(new Error(i)) : console.error(i), Mu(null) })))).pipe(L(() => { const i = this._extractIconWithNameFromAnySet(t, e); if (!i) throw aM(t); return i })) } _extractIconWithNameFromAnySet(t, e) { for (let i = e.length - 1; i >= 0; i--) { const n = e[i]; if (n.svgElement) { const e = this._extractSvgIconFromSet(n.svgElement, t, n.options); if (e) return e } } return null } _loadSvgIconFromConfig(t) { return this._fetchUrl(t.url).pipe(L(e => this._createSvgElementForSingleIcon(e, t.options))) } _loadSvgIconSetFromConfig(t) { return t.svgElement ? Mu(t.svgElement) : this._fetchUrl(t.url).pipe(L(e => (t.svgElement || (t.svgElement = this._svgElementFromString(e)), t.svgElement))) } _createSvgElementForSingleIcon(t, e) { const i = this._svgElementFromString(t); return this._setSvgAttributes(i, e), i } _extractSvgIconFromSet(t, e, i) { const n = t.querySelector(`[id="${e}"]`); if (!n) return null; const s = n.cloneNode(!0); if (s.removeAttribute("id"), "svg" === s.nodeName.toLowerCase()) return this._setSvgAttributes(s, i); if ("symbol" === s.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(s), i); const r = this._svgElementFromString("<svg></svg>"); return r.appendChild(s), this._setSvgAttributes(r, i) } _svgElementFromString(t) { const e = this._document.createElement("DIV");
                e.innerHTML = t; const i = e.querySelector("svg"); if (!i) throw Error("<svg> tag not found"); return i } _toSvgElement(t) { const e = this._svgElementFromString("<svg></svg>"),
                    i = t.attributes; for (let n = 0; n < i.length; n++) { const { name: t, value: s } = i[n]; "id" !== t && e.setAttribute(t, s) } for (let n = 0; n < t.childNodes.length; n++) t.childNodes[n].nodeType === this._document.ELEMENT_NODE && e.appendChild(t.childNodes[n].cloneNode(!0)); return e } _setSvgAttributes(t, e) { return t.setAttribute("fit", ""), t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.setAttribute("preserveAspectRatio", "xMidYMid meet"), t.setAttribute("focusable", "false"), e && e.viewBox && t.setAttribute("viewBox", e.viewBox), t } _fetchUrl(t) { if (!this._httpClient) throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports."); if (null == t) throw Error(`Cannot fetch icon from URL "${t}".`); const e = this._sanitizer.sanitize(qn.RESOURCE_URL, t); if (!e) throw oM(t); const i = this._inProgressUrlFetches.get(e); if (i) return i; const n = this._httpClient.get(e, { responseType: "text" }).pipe(Dm(() => this._inProgressUrlFetches.delete(e)), et()); return this._inProgressUrlFetches.set(e, n), n } _addSvgIconConfig(t, e, i) { return this._svgIconConfigs.set(uM(t, e), i), this } _addSvgIconSetConfig(t, e) { const i = this._iconSetConfigs.get(t); return i ? i.push(e) : this._iconSetConfigs.set(t, [e]), this } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Mb, 8), Xt(Au), Xt(uh, 8), Xt(un, 8)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(Mb, 8), Xt(Au), Xt(uh, 8), Xt(un, 8)) }, token: t, providedIn: "root" }), t })();

    function dM(t) { return t.cloneNode(!0) }

    function uM(t, e) { return t + ":" + e } class mM { constructor(t) { this._elementRef = t } }
    const pM = yS(mM), fM = new Vt("mat-icon-location", { providedIn: "root", factory: function() { const t = Kt(uh),
                e = t ? t.location : null; return { getPathname: () => e ? e.pathname + e.search : "" } } }), gM = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"], _M = gM.map(t => `[${t}]`).join(", "), bM = /^url\(['"]?#(.*?)['"]?\)$/;
    let yM = (() => { class t extends pM { constructor(t, e, i, n, s) { super(t), this._iconRegistry = e, this._location = n, this._errorHandler = s, this._inline = !1, i || t.nativeElement.setAttribute("aria-hidden", "true") } get inline() { return this._inline } set inline(t) { this._inline = Vv(t) } get fontSet() { return this._fontSet } set fontSet(t) { this._fontSet = this._cleanupFontValue(t) } get fontIcon() { return this._fontIcon } set fontIcon(t) { this._fontIcon = this._cleanupFontValue(t) } _splitIconName(t) { if (!t) return ["", ""]; const e = t.split(":"); switch (e.length) {
                    case 1:
                        return ["", e[0]];
                    case 2:
                        return e;
                    default:
                        throw Error(`Invalid icon name: "${t}"`) } } ngOnChanges(t) { const e = t.svgIcon; if (e)
                    if (this.svgIcon) { const [t, e] = this._splitIconName(this.svgIcon);
                        this._iconRegistry.getNamedSvgIcon(e, t).pipe(lm(1)).subscribe(t => this._setSvgElement(t), i => { const n = `Error retrieving icon ${t}:${e}! ${i.message}`;
                            this._errorHandler ? this._errorHandler.handleError(new Error(n)) : console.error(n) }) } else e.previousValue && this._clearSvgElement();
                this._usingFontIcon() && this._updateFontIconClasses() } ngOnInit() { this._usingFontIcon() && this._updateFontIconClasses() } ngAfterViewChecked() { const t = this._elementsWithExternalReferences; if (t && this._location && t.size) { const t = this._location.getPathname();
                    t !== this._previousPath && (this._previousPath = t, this._prependPathToReferences(t)) } } ngOnDestroy() { this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear() } _usingFontIcon() { return !this.svgIcon } _setSvgElement(t) { this._clearSvgElement(); const e = t.querySelectorAll("style"); for (let i = 0; i < e.length; i++) e[i].textContent += " "; if (this._location) { const e = this._location.getPathname();
                    this._previousPath = e, this._cacheChildrenWithExternalReferences(t), this._prependPathToReferences(e) } this._elementRef.nativeElement.appendChild(t) } _clearSvgElement() { const t = this._elementRef.nativeElement; let e = t.childNodes.length; for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); e--;) { const i = t.childNodes[e];
                    1 === i.nodeType && "svg" !== i.nodeName.toLowerCase() || t.removeChild(i) } } _updateFontIconClasses() { if (!this._usingFontIcon()) return; const t = this._elementRef.nativeElement,
                    e = this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet) : this._iconRegistry.getDefaultFontSetClass();
                e != this._previousFontSetClass && (this._previousFontSetClass && t.classList.remove(this._previousFontSetClass), e && t.classList.add(e), this._previousFontSetClass = e), this.fontIcon != this._previousFontIconClass && (this._previousFontIconClass && t.classList.remove(this._previousFontIconClass), this.fontIcon && t.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon) } _cleanupFontValue(t) { return "string" == typeof t ? t.trim().split(" ")[0] : t } _prependPathToReferences(t) { const e = this._elementsWithExternalReferences;
                e && e.forEach((e, i) => { e.forEach(e => { i.setAttribute(e.name, `url('${t}#${e.value}')`) }) }) } _cacheChildrenWithExternalReferences(t) { const e = t.querySelectorAll(_M),
                    i = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map; for (let n = 0; n < e.length; n++) gM.forEach(t => { const s = e[n],
                        r = s.getAttribute(t),
                        a = r ? r.match(bM) : null; if (a) { let e = i.get(s);
                        e || (e = [], i.set(s, e)), e.push({ name: t, value: a[1] }) } }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(hM), ka("aria-hidden"), Sa(fM, 8), Sa(un, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-icon"]
            ], hostAttrs: ["role", "img", 1, "mat-icon", "notranslate"], hostVars: 4, hostBindings: function(t, e) { 2 & t && no("mat-icon-inline", e.inline)("mat-icon-no-color", "primary" !== e.color && "accent" !== e.color && "warn" !== e.color) }, inputs: { color: "color", inline: "inline", fontSet: "fontSet", fontIcon: "fontIcon", svgIcon: "svgIcon" }, exportAs: ["matIcon"], features: [Eo, Ro], ngContentSelectors: rM, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(), Wa(0)) }, styles: [".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"], encapsulation: 2, changeDetection: 0 }), t })(), vM = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [_S], _S
            ] }), t })();

    function wM(t, e) { if (1 & t && Pa(0, 9), 2 & t) { const t = ja();
            Da("ngTemplateOutlet", t.iconOverrides[t.state])("ngTemplateOutletContext", t._getIconContext()) } }

    function CM(t, e) { if (1 & t && (Ia(0, "span"), _o(1), Ta()), 2 & t) { const t = ja(2);
            ps(1), bo(t._getDefaultTextForState(t.state)) } }

    function xM(t, e) { if (1 & t && (Ia(0, "mat-icon"), _o(1), Ta()), 2 & t) { const t = ja(2);
            ps(1), bo(t._getDefaultTextForState(t.state)) } }

    function SM(t, e) { 1 & t && (Ra(0, 10), Ca(1, CM, 2, 1, "span", 11), Ca(2, xM, 2, 1, "mat-icon", 12), Ma()), 2 & t && (Da("ngSwitch", ja().state), ps(1), Da("ngSwitchCase", "number")) }

    function kM(t, e) { 1 & t && Pa(0, 13), 2 & t && Da("ngTemplateOutlet", ja()._templateLabel().template) }

    function EM(t, e) { if (1 & t && (Ia(0, "div", 14), _o(1), Ta()), 2 & t) { const t = ja();
            ps(1), bo(t.label) } }

    function DM(t, e) { if (1 & t && (Ia(0, "div", 15), _o(1), Ta()), 2 & t) { const t = ja();
            ps(1), bo(t._intl.optionalLabel) } }

    function AM(t, e) { if (1 & t && (Ia(0, "div", 16), _o(1), Ta()), 2 & t) { const t = ja();
            ps(1), bo(t.errorMessage) } }

    function IM(t, e) { 1 & t && Wa(0) }
    const TM = ["*"];

    function OM(t, e) { 1 & t && Oa(0, "div", 6) }

    function RM(t, e) { if (1 & t) { const t = Fa();
            Ra(0), Ia(1, "mat-step-header", 4), Ba("click", (function() { return e.$implicit.select() }))("keydown", (function(e) { return Qe(t), ja()._onKeydown(e) })), Ta(), Ca(2, OM, 1, 0, "div", 5), Ma() } if (2 & t) { const t = e.$implicit,
                i = e.index,
                n = e.last,
                s = ja();
            ps(1), Da("tabIndex", s._getFocusIndex() === i ? 0 : -1)("id", s._getStepLabelId(i))("index", i)("state", s._getIndicatorType(i, t.state))("label", t.stepLabel || t.label)("selected", s.selectedIndex === i)("active", t.completed || s.selectedIndex === i || !s.linear)("optional", t.optional)("errorMessage", t.errorMessage)("iconOverrides", s._iconOverrides)("disableRipple", s.disableRipple), va("aria-posinset", i + 1)("aria-setsize", s.steps.length)("aria-controls", s._getStepContentId(i))("aria-selected", s.selectedIndex == i)("aria-label", t.ariaLabel || null)("aria-labelledby", !t.ariaLabel && t.ariaLabelledby ? t.ariaLabelledby : null), ps(1), Da("ngIf", !n) } }

    function MM(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 7), Ba("@stepTransition.done", (function(e) { return Qe(t), ja()._animationDone.next(e) })), Pa(1, 8), Ta() } if (2 & t) { const t = e.$implicit,
                i = e.index,
                n = ja();
            Da("@stepTransition", n._getAnimationDirection(i))("id", n._getStepContentId(i)), va("tabindex", n.selectedIndex === i ? 0 : null)("aria-labelledby", n._getStepLabelId(i))("aria-expanded", n.selectedIndex === i), ps(1), Da("ngTemplateOutlet", t.content) } }

    function PM(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 1), Ia(1, "mat-step-header", 2), Ba("click", (function() { return e.$implicit.select() }))("keydown", (function(e) { return Qe(t), ja()._onKeydown(e) })), Ta(), Ia(2, "div", 3), Ia(3, "div", 4), Ba("@stepTransition.done", (function(e) { return Qe(t), ja()._animationDone.next(e) })), Ia(4, "div", 5), Pa(5, 6), Ta(), Ta(), Ta(), Ta() } if (2 & t) { const t = e.$implicit,
                i = e.index,
                n = e.last,
                s = ja();
            ps(1), Da("tabIndex", s._getFocusIndex() == i ? 0 : -1)("id", s._getStepLabelId(i))("index", i)("state", s._getIndicatorType(i, t.state))("label", t.stepLabel || t.label)("selected", s.selectedIndex === i)("active", t.completed || s.selectedIndex === i || !s.linear)("optional", t.optional)("errorMessage", t.errorMessage)("iconOverrides", s._iconOverrides)("disableRipple", s.disableRipple), va("aria-posinset", i + 1)("aria-setsize", s.steps.length)("aria-controls", s._getStepContentId(i))("aria-selected", s.selectedIndex === i)("aria-label", t.ariaLabel || null)("aria-labelledby", !t.ariaLabel && t.ariaLabelledby ? t.ariaLabelledby : null), ps(1), no("mat-stepper-vertical-line", !n), ps(1), Da("@stepTransition", s._getAnimationDirection(i))("id", s._getStepContentId(i)), va("tabindex", s.selectedIndex === i ? 0 : null)("aria-labelledby", s._getStepLabelId(i))("aria-expanded", s.selectedIndex === i), ps(2), Da("ngTemplateOutlet", t.content) } }
    let FM = (() => { class t extends ZR {} return t.\u0275fac = function(e) { return NM(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matStepLabel", ""]
            ], features: [Eo] }), t })();
    const NM = ln(FM);
    let LM = (() => { class t { constructor() { this.changes = new k, this.optionalLabel = "Optional" } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return new t }, token: t, providedIn: "root" }), t })();
    const BM = { provide: LM, deps: [
            [new rt, new ot, LM]
        ], useFactory: function(t) { return t || new LM } };
    let VM = (() => { class t extends KR { constructor(t, e, i, n) { super(i), this._intl = t, this._focusMonitor = e, e.monitor(i, !0), this._intlSubscription = t.changes.subscribe(() => n.markForCheck()) } ngOnDestroy() { this._intlSubscription.unsubscribe(), this._focusMonitor.stopMonitoring(this._elementRef) } focus() { this._focusMonitor.focusVia(this._elementRef, "program") } _stringLabel() { return this.label instanceof FM ? null : this.label } _templateLabel() { return this.label instanceof FM ? this.label : null } _getHostElement() { return this._elementRef.nativeElement } _getIconContext() { return { index: this.index, active: this.active, optional: this.optional } } _getDefaultTextForState(t) { return "number" == t ? `${this.index+1}` : "edit" == t ? "create" : "error" == t ? "warning" : t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(LM), Sa(Ew), Sa(Wo), Sa(jr)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-step-header"]
            ], hostAttrs: ["role", "tab", 1, "mat-step-header", "mat-focus-indicator"], inputs: { state: "state", label: "label", errorMessage: "errorMessage", iconOverrides: "iconOverrides", index: "index", selected: "selected", active: "active", optional: "optional", disableRipple: "disableRipple" }, features: [Eo], decls: 10, vars: 19, consts: [
                ["matRipple", "", 1, "mat-step-header-ripple", 3, "matRippleTrigger", "matRippleDisabled"],
                [1, "mat-step-icon-content", 3, "ngSwitch"],
                [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngSwitchCase"],
                [3, "ngSwitch", 4, "ngSwitchDefault"],
                [1, "mat-step-label"],
                [3, "ngTemplateOutlet", 4, "ngIf"],
                ["class", "mat-step-text-label", 4, "ngIf"],
                ["class", "mat-step-optional", 4, "ngIf"],
                ["class", "mat-step-sub-label-error", 4, "ngIf"],
                [3, "ngTemplateOutlet", "ngTemplateOutletContext"],
                [3, "ngSwitch"],
                [4, "ngSwitchCase"],
                [4, "ngSwitchDefault"],
                [3, "ngTemplateOutlet"],
                [1, "mat-step-text-label"],
                [1, "mat-step-optional"],
                [1, "mat-step-sub-label-error"]
            ], template: function(t, e) { 1 & t && (Oa(0, "div", 0), Ia(1, "div"), Ia(2, "div", 1), Ca(3, wM, 1, 2, "ng-container", 2), Ca(4, SM, 3, 2, "ng-container", 3), Ta(), Ta(), Ia(5, "div", 4), Ca(6, kM, 1, 1, "ng-container", 5), Ca(7, EM, 2, 1, "div", 6), Ca(8, DM, 2, 1, "div", 7), Ca(9, AM, 2, 1, "div", 8), Ta()), 2 & t && (Da("matRippleTrigger", e._getHostElement())("matRippleDisabled", e.disableRipple), ps(1), Co("mat-step-icon-state-", e.state, " mat-step-icon"), no("mat-step-icon-selected", e.selected), ps(1), Da("ngSwitch", !(!e.iconOverrides || !e.iconOverrides[e.state])), ps(1), Da("ngSwitchCase", !0), ps(2), no("mat-step-label-active", e.active)("mat-step-label-selected", e.selected)("mat-step-label-error", "error" == e.state), ps(1), Da("ngIf", e._templateLabel()), ps(1), Da("ngIf", e._stringLabel()), ps(1), Da("ngIf", e.optional && "error" != e.state), ps(1), Da("ngIf", "error" == e.state)) }, directives: [qS, xd, Sd, kd, yd, Id, yM], styles: [".mat-step-header{overflow:hidden;outline:none;cursor:pointer;position:relative;box-sizing:content-box;-webkit-tap-highlight-color:transparent}.mat-step-optional,.mat-step-sub-label-error{font-size:12px}.mat-step-icon{border-radius:50%;height:24px;width:24px;flex-shrink:0;position:relative}.mat-step-icon-content,.mat-step-icon .mat-icon{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.mat-step-icon .mat-icon{font-size:16px;height:16px;width:16px}.mat-step-icon-state-error .mat-icon{font-size:24px;height:24px;width:24px}.mat-step-label{display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:50px;vertical-align:middle}.mat-step-text-label{text-overflow:ellipsis;overflow:hidden}.mat-step-header .mat-step-header-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\n"], encapsulation: 2, changeDetection: 0 }), t })();
    const zM = { horizontalStepTransition: Lw("stepTransition", [Hw("previous", Uw({ transform: "translate3d(-100%, 0, 0)", visibility: "hidden" })), Hw("current", Uw({ transform: "none", visibility: "visible" })), Hw("next", Uw({ transform: "translate3d(100%, 0, 0)", visibility: "hidden" })), Gw("* => *", Bw("500ms cubic-bezier(0.35, 0, 0.25, 1)"))]), verticalStepTransition: Lw("stepTransition", [Hw("previous", Uw({ height: "0px", visibility: "hidden" })), Hw("next", Uw({ height: "0px", visibility: "hidden" })), Hw("current", Uw({ height: "*", visibility: "visible" })), Gw("* <=> current", Bw("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))]) };
    let UM = (() => { class t { constructor(t) { this.templateRef = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl)) }, t.\u0275dir = we({ type: t, selectors: [
                ["ng-template", "matStepperIcon", ""]
            ], inputs: { name: ["matStepperIcon", "name"] } }), t })(), HM = (() => { class t extends tM { constructor(t, e, i) { super(t, i), this._errorStateMatcher = e } isErrorState(t, e) { return this._errorStateMatcher.isErrorState(t, e) || !!(t && t.invalid && this.interacted) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(St(() => jM)), Sa(LS, 4), Sa(JR, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-step"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, FM, !0), 2 & t && tc(n = oc()) && (e.stepLabel = n.first) }, exportAs: ["matStep"], features: [Ho([{ provide: LS, useExisting: t }, { provide: tM, useExisting: t }]), Eo], ngContentSelectors: TM, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(), Ca(0, IM, 1, 0, "ng-template")) }, encapsulation: 2, changeDetection: 0 }), t })(), jM = (() => { class t extends eM { constructor() { super(...arguments), this.animationDone = new jl, this._iconOverrides = {}, this._animationDone = new k } ngAfterContentInit() { this._icons.forEach(({ name: t, templateRef: e }) => this._iconOverrides[t] = e), this._steps.changes.pipe(jk(this._destroyed)).subscribe(() => { this._stateChanged() }), this._animationDone.pipe(XE((t, e) => t.fromState === e.fromState && t.toState === e.toState), jk(this._destroyed)).subscribe(t => { "current" === t.toState && this.animationDone.emit() }) } } return t.\u0275fac = function(e) { return GM(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matStepper", ""]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, HM, !0), sc(i, UM, !0)), 2 & t && (tc(n = oc()) && (e._steps = n), tc(n = oc()) && (e._icons = n)) }, viewQuery: function(t, e) { var i;
                1 & t && ic(VM, !0), 2 & t && tc(i = oc()) && (e._stepHeader = i) }, inputs: { disableRipple: "disableRipple" }, outputs: { animationDone: "animationDone" }, features: [Ho([{ provide: eM, useExisting: t }]), Eo] }), t })();
    const GM = ln(jM);
    let $M = (() => { class t extends jM { constructor() { super(...arguments), this.labelPosition = "end" } } return t.\u0275fac = function(e) { return WM(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-horizontal-stepper"]
            ], hostAttrs: ["aria-orientation", "horizontal", "role", "tablist", 1, "mat-stepper-horizontal"], hostVars: 4, hostBindings: function(t, e) { 2 & t && no("mat-stepper-label-position-end", "end" == e.labelPosition)("mat-stepper-label-position-bottom", "bottom" == e.labelPosition) }, inputs: { selectedIndex: "selectedIndex", labelPosition: "labelPosition" }, exportAs: ["matHorizontalStepper"], features: [Ho([{ provide: jM, useExisting: t }, { provide: eM, useExisting: t }]), Eo], decls: 4, vars: 2, consts: [
                [1, "mat-horizontal-stepper-header-container"],
                [4, "ngFor", "ngForOf"],
                [1, "mat-horizontal-content-container"],
                ["class", "mat-horizontal-stepper-content", "role", "tabpanel", 3, "id", 4, "ngFor", "ngForOf"],
                [1, "mat-horizontal-stepper-header", 3, "tabIndex", "id", "index", "state", "label", "selected", "active", "optional", "errorMessage", "iconOverrides", "disableRipple", "click", "keydown"],
                ["class", "mat-stepper-horizontal-line", 4, "ngIf"],
                [1, "mat-stepper-horizontal-line"],
                ["role", "tabpanel", 1, "mat-horizontal-stepper-content", 3, "id"],
                [3, "ngTemplateOutlet"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div", 0), Ca(1, RM, 3, 18, "ng-container", 1), Ta(), Ia(2, "div", 2), Ca(3, MM, 2, 6, "div", 3), Ta()), 2 & t && (ps(1), Da("ngForOf", e.steps), ps(2), Da("ngForOf", e.steps)) }, directives: [_d, VM, yd, Id], styles: ['.mat-stepper-vertical,.mat-stepper-horizontal{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{border-top-width:1px;border-top-style:solid;content:"";display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:"";position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}\n'], encapsulation: 2, data: { animation: [zM.horizontalStepTransition] }, changeDetection: 0 }), t })();
    const WM = ln($M);
    let qM = (() => { class t extends jM { constructor(t, e, i, n) { super(t, e, i, n), this._orientation = "vertical" } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Rw, 8), Sa(jr), Sa(Wo), Sa(uh)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-vertical-stepper"]
            ], hostAttrs: ["aria-orientation", "vertical", "role", "tablist", 1, "mat-stepper-vertical"], inputs: { selectedIndex: "selectedIndex" }, exportAs: ["matVerticalStepper"], features: [Ho([{ provide: jM, useExisting: t }, { provide: eM, useExisting: t }]), Eo], decls: 1, vars: 1, consts: [
                ["class", "mat-step", 4, "ngFor", "ngForOf"],
                [1, "mat-step"],
                [1, "mat-vertical-stepper-header", 3, "tabIndex", "id", "index", "state", "label", "selected", "active", "optional", "errorMessage", "iconOverrides", "disableRipple", "click", "keydown"],
                [1, "mat-vertical-content-container"],
                ["role", "tabpanel", 1, "mat-vertical-stepper-content", 3, "id"],
                [1, "mat-vertical-content"],
                [3, "ngTemplateOutlet"]
            ], template: function(t, e) { 1 & t && Ca(0, PM, 6, 25, "div", 0), 2 & t && Da("ngForOf", e.steps) }, directives: [_d, VM, Id], styles: ['.mat-stepper-vertical,.mat-stepper-horizontal{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{border-top-width:1px;border-top-style:solid;content:"";display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:"";position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}\n'], encapsulation: 2, data: { animation: [zM.verticalStepTransition] }, changeDetection: 0 }), t })(), YM = (() => { class t extends iM {} return t.\u0275fac = function(e) { return XM(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["button", "matStepperNext", ""]
            ], hostVars: 1, hostBindings: function(t, e) { 2 & t && xo("type", e.type) }, inputs: { type: "type" }, features: [Eo] }), t })();
    const XM = ln(YM);
    let KM = (() => { class t extends nM {} return t.\u0275fac = function(e) { return ZM(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["button", "matStepperPrevious", ""]
            ], hostVars: 1, hostBindings: function(t, e) { 2 & t && xo("type", e.type) }, inputs: { type: "type" }, features: [Eo] }), t })();
    const ZM = ln(KM);
    let QM = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [BM, LS], imports: [
                [_S, Jd, ED, _k, sM, vM, YS], _S
            ] }), t })();

    function JM(t, e) { 1 & t && Wa(0) }
    const tP = ["*"];

    function eP(t, e) {}
    const iP = function(t) { return { animationDuration: t } }, nP = function(t, e) { return { value: t, params: e } }, sP = ["tabBodyWrapper"], rP = ["tabHeader"];

    function aP(t, e) {}

    function oP(t, e) { 1 & t && Ca(0, aP, 0, 0, "ng-template", 9), 2 & t && Da("cdkPortalOutlet", ja().$implicit.templateLabel) }

    function lP(t, e) { 1 & t && _o(0), 2 & t && bo(ja().$implicit.textLabel) }

    function cP(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 6), Ba("click", (function() { Qe(t); const i = e.$implicit,
                    n = e.index,
                    s = ja(),
                    r = xa(1); return s._handleClick(i, r, n) })), Ia(1, "div", 7), Ca(2, oP, 1, 1, "ng-template", 8), Ca(3, lP, 1, 1, "ng-template", 8), Ta(), Ta() } if (2 & t) { const t = e.$implicit,
                i = e.index,
                n = ja();
            no("mat-tab-label-active", n.selectedIndex == i), Da("id", n._getTabLabelId(i))("disabled", t.disabled)("matRippleDisabled", t.disabled || n.disableRipple), va("tabIndex", n._getTabIndex(t, i))("aria-posinset", i + 1)("aria-setsize", n._tabs.length)("aria-controls", n._getTabContentId(i))("aria-selected", n.selectedIndex == i)("aria-label", t.ariaLabel || null)("aria-labelledby", !t.ariaLabel && t.ariaLabelledby ? t.ariaLabelledby : null), ps(2), Da("ngIf", t.templateLabel), ps(1), Da("ngIf", !t.templateLabel) } }

    function hP(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "mat-tab-body", 10), Ba("_onCentered", (function() { return Qe(t), ja()._removeTabBodyWrapperHeight() }))("_onCentering", (function(e) { return Qe(t), ja()._setTabBodyWrapperHeight(e) })), Ta() } if (2 & t) { const t = e.$implicit,
                i = e.index,
                n = ja();
            no("mat-tab-body-active", n.selectedIndex == i), Da("id", n._getTabContentId(i))("content", t.content)("position", t.position)("origin", t.origin)("animationDuration", n.animationDuration), va("aria-labelledby", n._getTabLabelId(i)) } }
    const dP = ["tabListContainer"], uP = ["tabList"], mP = ["nextPaginator"], pP = ["previousPaginator"], fP = ["mat-tab-nav-bar", ""], gP = new Vt("MatInkBarPositioner", { providedIn: "root", factory: function() { return t => ({ left: t ? (t.offsetLeft || 0) + "px" : "0", width: t ? (t.offsetWidth || 0) + "px" : "0" }) } });
    let _P = (() => { class t { constructor(t, e, i, n) { this._elementRef = t, this._ngZone = e, this._inkBarPositioner = i, this._animationMode = n } alignToElement(t) { this.show(), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => this._setStyles(t)) }) : this._setStyles(t) } show() { this._elementRef.nativeElement.style.visibility = "visible" } hide() { this._elementRef.nativeElement.style.visibility = "hidden" } _setStyles(t) { const e = this._inkBarPositioner(t),
                    i = this._elementRef.nativeElement;
                i.style.left = e.left, i.style.width = e.width } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Pc), Sa(gP), Sa(aS, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-ink-bar"]
            ], hostAttrs: [1, "mat-ink-bar"], hostVars: 2, hostBindings: function(t, e) { 2 & t && no("_mat-animation-noopable", "NoopAnimations" === e._animationMode) } }), t })(), bP = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matTabContent", ""]
            ] }), t })(), yP = (() => { class t extends CD {} return t.\u0275fac = function(e) { return vP(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-tab-label", ""],
                ["", "matTabLabel", ""]
            ], features: [Eo] }), t })();
    const vP = ln(yP); class wP {}
    const CP = bS(wP), xP = new Vt("MAT_TAB_GROUP");
    let SP = (() => { class t extends CP { constructor(t, e) { super(), this._viewContainerRef = t, this._closestTabGroup = e, this.textLabel = "", this._contentPortal = null, this._stateChanges = new k, this.position = null, this.origin = null, this.isActive = !1 } get templateLabel() { return this._templateLabel } set templateLabel(t) { t && (this._templateLabel = t) } get content() { return this._contentPortal } ngOnChanges(t) {
                (t.hasOwnProperty("textLabel") || t.hasOwnProperty("disabled")) && this._stateChanges.next() } ngOnDestroy() { this._stateChanges.complete() } ngOnInit() { this._contentPortal = new bD(this._explicitContent || this._implicitContent, this._viewContainerRef) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl), Sa(xP, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-tab"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, yP, !0), rc(i, bP, !0, gl)), 2 & t && (tc(n = oc()) && (e.templateLabel = n.first), tc(n = oc()) && (e._explicitContent = n.first)) }, viewQuery: function(t, e) { var i;
                1 & t && ec(gl, !0), 2 & t && tc(i = oc()) && (e._implicitContent = i.first) }, inputs: { disabled: "disabled", textLabel: ["label", "textLabel"], ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"] }, exportAs: ["matTab"], features: [Eo, Ro], ngContentSelectors: tP, decls: 1, vars: 0, template: function(t, e) { 1 & t && ($a(), Ca(0, JM, 1, 0, "ng-template")) }, encapsulation: 2 }), t })();
    const kP = { translateTab: Lw("translateTab", [Hw("center, void, left-origin-center, right-origin-center", Uw({ transform: "none" })), Hw("left", Uw({ transform: "translate3d(-100%, 0, 0)", minHeight: "1px" })), Hw("right", Uw({ transform: "translate3d(100%, 0, 0)", minHeight: "1px" })), Gw("* => left, * => right, left => center, right => center", Bw("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")), Gw("void => left-origin-center", [Uw({ transform: "translate3d(-100%, 0, 0)" }), Bw("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")]), Gw("void => right-origin-center", [Uw({ transform: "translate3d(100%, 0, 0)" }), Bw("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")])]) };
    let EP = (() => { class t extends xD { constructor(t, e, i, n) { super(t, e, n), this._host = i, this._centeringSub = d.EMPTY, this._leavingSub = d.EMPTY } ngOnInit() { super.ngOnInit(), this._centeringSub = this._host._beforeCentering.pipe(bm(this._host._isCenterPosition(this._host._position))).subscribe(t => { t && !this.hasAttached() && this.attach(this._host._content) }), this._leavingSub = this._host._afterLeavingCenter.subscribe(() => { this.detach() }) } ngOnDestroy() { super.ngOnDestroy(), this._centeringSub.unsubscribe(), this._leavingSub.unsubscribe() } } return t.\u0275fac = function(e) { return new(e || t)(Sa($o), Sa(bl), Sa(St(() => AP)), Sa(uh)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matTabBodyHost", ""]
            ], features: [Eo] }), t })(), DP = (() => { class t { constructor(t, e, i) { this._elementRef = t, this._dir = e, this._dirChangeSubscription = d.EMPTY, this._translateTabComplete = new k, this._onCentering = new jl, this._beforeCentering = new jl, this._afterLeavingCenter = new jl, this._onCentered = new jl(!0), this.animationDuration = "500ms", e && (this._dirChangeSubscription = e.change.subscribe(t => { this._computePositionAnimationState(t), i.markForCheck() })), this._translateTabComplete.pipe(XE((t, e) => t.fromState === e.fromState && t.toState === e.toState)).subscribe(t => { this._isCenterPosition(t.toState) && this._isCenterPosition(this._position) && this._onCentered.emit(), this._isCenterPosition(t.fromState) && !this._isCenterPosition(this._position) && this._afterLeavingCenter.emit() }) } set position(t) { this._positionIndex = t, this._computePositionAnimationState() } ngOnInit() { "center" == this._position && null != this.origin && (this._position = this._computePositionFromOrigin(this.origin)) } ngOnDestroy() { this._dirChangeSubscription.unsubscribe(), this._translateTabComplete.complete() } _onTranslateTabStarted(t) { const e = this._isCenterPosition(t.toState);
                this._beforeCentering.emit(e), e && this._onCentering.emit(this._elementRef.nativeElement.clientHeight) } _getLayoutDirection() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } _isCenterPosition(t) { return "center" == t || "left-origin-center" == t || "right-origin-center" == t } _computePositionAnimationState(t = this._getLayoutDirection()) { this._position = this._positionIndex < 0 ? "ltr" == t ? "left" : "right" : this._positionIndex > 0 ? "ltr" == t ? "right" : "left" : "center" } _computePositionFromOrigin(t) { const e = this._getLayoutDirection(); return "ltr" == e && t <= 0 || "rtl" == e && t > 0 ? "left-origin-center" : "right-origin-center" } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Rw, 8), Sa(jr)) }, t.\u0275dir = we({ type: t, inputs: { animationDuration: "animationDuration", position: "position", _content: ["content", "_content"], origin: "origin" }, outputs: { _onCentering: "_onCentering", _beforeCentering: "_beforeCentering", _afterLeavingCenter: "_afterLeavingCenter", _onCentered: "_onCentered" } }), t })(), AP = (() => { class t extends DP { constructor(t, e, i) { super(t, e, i) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Rw, 8), Sa(jr)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-tab-body"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(SD, !0), 2 & t && tc(i = oc()) && (e._portalHost = i.first) }, hostAttrs: [1, "mat-tab-body"], features: [Eo], decls: 3, vars: 6, consts: [
                [1, "mat-tab-body-content"],
                ["content", ""],
                ["matTabBodyHost", ""]
            ], template: function(t, e) { var i, n;
                1 & t && (Ia(0, "div", 0, 1), Ba("@translateTab.start", (function(t) { return e._onTranslateTabStarted(t) }))("@translateTab.done", (function(t) { return e._translateTabComplete.next(t) })), Ca(2, eP, 0, 0, "ng-template", 2), Ta()), 2 & t && Da("@translateTab", Bl(3, nP, e._position, (1, i = iP, n = e.animationDuration, zl(Ke(), ri(), 1, i, n, void 0)))) }, directives: [EP], styles: [".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\n"], encapsulation: 2, data: { animation: [kP.translateTab] } }), t })();
    const IP = new Vt("MAT_TABS_CONFIG");
    let TP = 0; class OP {} class RP { constructor(t) { this._elementRef = t } }
    const MP = yS(vS(RP), "primary");
    let PP = (() => { class t extends MP { constructor(t, e, i, n) { super(t), this._changeDetectorRef = e, this._animationMode = n, this._tabs = new $l, this._indexToSelect = 0, this._tabBodyWrapperHeight = 0, this._tabsSubscription = d.EMPTY, this._tabLabelSubscription = d.EMPTY, this._dynamicHeight = !1, this._selectedIndex = null, this.headerPosition = "above", this.selectedIndexChange = new jl, this.focusChange = new jl, this.animationDone = new jl, this.selectedTabChange = new jl(!0), this._groupId = TP++, this.animationDuration = i && i.animationDuration ? i.animationDuration : "500ms", this.disablePagination = !(!i || null == i.disablePagination) && i.disablePagination } get dynamicHeight() { return this._dynamicHeight } set dynamicHeight(t) { this._dynamicHeight = Vv(t) } get selectedIndex() { return this._selectedIndex } set selectedIndex(t) { this._indexToSelect = zv(t, null) } get animationDuration() { return this._animationDuration } set animationDuration(t) { this._animationDuration = /^\d+$/.test(t) ? t + "ms" : t } get backgroundColor() { return this._backgroundColor } set backgroundColor(t) { const e = this._elementRef.nativeElement;
                e.classList.remove(`mat-background-${this.backgroundColor}`), t && e.classList.add(`mat-background-${t}`), this._backgroundColor = t } ngAfterContentChecked() { const t = this._indexToSelect = this._clampTabIndex(this._indexToSelect); if (this._selectedIndex != t) { const e = null == this._selectedIndex;
                    e || this.selectedTabChange.emit(this._createChangeEvent(t)), Promise.resolve().then(() => { this._tabs.forEach((e, i) => e.isActive = i === t), e || this.selectedIndexChange.emit(t) }) } this._tabs.forEach((e, i) => { e.position = i - t, null == this._selectedIndex || 0 != e.position || e.origin || (e.origin = t - this._selectedIndex) }), this._selectedIndex !== t && (this._selectedIndex = t, this._changeDetectorRef.markForCheck()) } ngAfterContentInit() { this._subscribeToAllTabChanges(), this._subscribeToTabLabels(), this._tabsSubscription = this._tabs.changes.subscribe(() => { if (this._clampTabIndex(this._indexToSelect) === this._selectedIndex) { const t = this._tabs.toArray(); for (let e = 0; e < t.length; e++)
                            if (t[e].isActive) { this._indexToSelect = this._selectedIndex = e; break } } this._changeDetectorRef.markForCheck() }) } _subscribeToAllTabChanges() { this._allTabs.changes.pipe(bm(this._allTabs)).subscribe(t => { this._tabs.reset(t.filter(t => !t._closestTabGroup || t._closestTabGroup === this)), this._tabs.notifyOnChanges() }) } ngOnDestroy() { this._tabs.destroy(), this._tabsSubscription.unsubscribe(), this._tabLabelSubscription.unsubscribe() } realignInkBar() { this._tabHeader && this._tabHeader._alignInkBarToSelectedTab() } _focusChanged(t) { this.focusChange.emit(this._createChangeEvent(t)) } _createChangeEvent(t) { const e = new OP; return e.index = t, this._tabs && this._tabs.length && (e.tab = this._tabs.toArray()[t]), e } _subscribeToTabLabels() { this._tabLabelSubscription && this._tabLabelSubscription.unsubscribe(), this._tabLabelSubscription = q(...this._tabs.map(t => t._stateChanges)).subscribe(() => this._changeDetectorRef.markForCheck()) } _clampTabIndex(t) { return Math.min(this._tabs.length - 1, Math.max(t || 0, 0)) } _getTabLabelId(t) { return `mat-tab-label-${this._groupId}-${t}` } _getTabContentId(t) { return `mat-tab-content-${this._groupId}-${t}` } _setTabBodyWrapperHeight(t) { if (!this._dynamicHeight || !this._tabBodyWrapperHeight) return; const e = this._tabBodyWrapper.nativeElement;
                e.style.height = this._tabBodyWrapperHeight + "px", this._tabBodyWrapper.nativeElement.offsetHeight && (e.style.height = t + "px") } _removeTabBodyWrapperHeight() { const t = this._tabBodyWrapper.nativeElement;
                this._tabBodyWrapperHeight = t.clientHeight, t.style.height = "", this.animationDone.emit() } _handleClick(t, e, i) { t.disabled || (this.selectedIndex = e.focusIndex = i) } _getTabIndex(t, e) { return t.disabled ? null : this.selectedIndex === e ? 0 : -1 } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(IP, 8), Sa(aS, 8)) }, t.\u0275dir = we({ type: t, inputs: { headerPosition: "headerPosition", animationDuration: "animationDuration", disablePagination: "disablePagination", dynamicHeight: "dynamicHeight", selectedIndex: "selectedIndex", backgroundColor: "backgroundColor" }, outputs: { selectedIndexChange: "selectedIndexChange", focusChange: "focusChange", animationDone: "animationDone", selectedTabChange: "selectedTabChange" }, features: [Eo] }), t })(), FP = (() => { class t extends PP { constructor(t, e, i, n) { super(t, e, i, n) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(IP, 8), Sa(aS, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-tab-group"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, SP, !0), 2 & t && tc(n = oc()) && (e._allTabs = n) }, viewQuery: function(t, e) { var i;
                1 & t && (ic(sP, !0), ic(rP, !0)), 2 & t && (tc(i = oc()) && (e._tabBodyWrapper = i.first), tc(i = oc()) && (e._tabHeader = i.first)) }, hostAttrs: [1, "mat-tab-group"], hostVars: 4, hostBindings: function(t, e) { 2 & t && no("mat-tab-group-dynamic-height", e.dynamicHeight)("mat-tab-group-inverted-header", "below" === e.headerPosition) }, inputs: { color: "color", disableRipple: "disableRipple" }, exportAs: ["matTabGroup"], features: [Ho([{ provide: xP, useExisting: t }]), Eo], decls: 6, vars: 7, consts: [
                [3, "selectedIndex", "disableRipple", "disablePagination", "indexFocused", "selectFocusedIndex"],
                ["tabHeader", ""],
                ["class", "mat-tab-label mat-focus-indicator", "role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 3, "id", "mat-tab-label-active", "disabled", "matRippleDisabled", "click", 4, "ngFor", "ngForOf"],
                [1, "mat-tab-body-wrapper"],
                ["tabBodyWrapper", ""],
                ["role", "tabpanel", 3, "id", "mat-tab-body-active", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering", 4, "ngFor", "ngForOf"],
                ["role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 1, "mat-tab-label", "mat-focus-indicator", 3, "id", "disabled", "matRippleDisabled", "click"],
                [1, "mat-tab-label-content"],
                [3, "ngIf"],
                [3, "cdkPortalOutlet"],
                ["role", "tabpanel", 3, "id", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering"]
            ], template: function(t, e) { 1 & t && (Ia(0, "mat-tab-header", 0, 1), Ba("indexFocused", (function(t) { return e._focusChanged(t) }))("selectFocusedIndex", (function(t) { return e.selectedIndex = t })), Ca(2, cP, 4, 14, "div", 2), Ta(), Ia(3, "div", 3, 4), Ca(5, hP, 1, 8, "mat-tab-body", 5), Ta()), 2 & t && (Da("selectedIndex", e.selectedIndex || 0)("disableRipple", e.disableRipple)("disablePagination", e.disablePagination), ps(2), Da("ngForOf", e._tabs), ps(1), no("_mat-animation-noopable", "NoopAnimations" === e._animationMode), ps(2), Da("ngForOf", e._tabs)) }, directives: function() { return [HP, _d, BP, qS, Dw, yd, xD, AP] }, styles: [".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\n"], encapsulation: 2 }), t })(); class NP {}
    const LP = bS(NP);
    let BP = (() => { class t extends LP { constructor(t) { super(), this.elementRef = t } focus() { this.elementRef.nativeElement.focus() } getOffsetLeft() { return this.elementRef.nativeElement.offsetLeft } getOffsetWidth() { return this.elementRef.nativeElement.offsetWidth } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matTabLabelWrapper", ""]
            ], hostVars: 3, hostBindings: function(t, e) { 2 & t && (va("aria-disabled", !!e.disabled), no("mat-tab-disabled", e.disabled)) }, inputs: { disabled: "disabled" }, features: [Eo] }), t })();
    const VP = Jv({ passive: !0 });
    let zP = (() => { class t { constructor(t, e, i, n, s, r, a) { this._elementRef = t, this._changeDetectorRef = e, this._viewportRuler = i, this._dir = n, this._ngZone = s, this._platform = r, this._animationMode = a, this._scrollDistance = 0, this._selectedIndexChanged = !1, this._destroyed = new k, this._showPaginationControls = !1, this._disableScrollAfter = !0, this._disableScrollBefore = !0, this._stopScrolling = new k, this.disablePagination = !1, this._selectedIndex = 0, this.selectFocusedIndex = new jl, this.indexFocused = new jl, s.runOutsideAngular(() => { Nk(t.nativeElement, "mouseleave").pipe(jk(this._destroyed)).subscribe(() => { this._stopInterval() }) }) } get selectedIndex() { return this._selectedIndex } set selectedIndex(t) { t = zv(t), this._selectedIndex != t && (this._selectedIndexChanged = !0, this._selectedIndex = t, this._keyManager && this._keyManager.updateActiveItem(t)) } ngAfterViewInit() { Nk(this._previousPaginator.nativeElement, "touchstart", VP).pipe(jk(this._destroyed)).subscribe(() => { this._handlePaginatorPress("before") }), Nk(this._nextPaginator.nativeElement, "touchstart", VP).pipe(jk(this._destroyed)).subscribe(() => { this._handlePaginatorPress("after") }) } ngAfterContentInit() { const t = this._dir ? this._dir.change : Mu(null),
                    e = this._viewportRuler.change(150),
                    i = () => { this.updatePagination(), this._alignInkBarToSelectedTab() };
                this._keyManager = new mw(this._items).withHorizontalOrientation(this._getLayoutDirection()).withWrap(), this._keyManager.updateActiveItem(0), "undefined" != typeof requestAnimationFrame ? requestAnimationFrame(i) : i(), q(t, e, this._items.changes).pipe(jk(this._destroyed)).subscribe(() => { i(), this._keyManager.withHorizontalOrientation(this._getLayoutDirection()) }), this._keyManager.change.pipe(jk(this._destroyed)).subscribe(t => { this.indexFocused.emit(t), this._setTabFocus(t) }) } ngAfterContentChecked() { this._tabLabelCount != this._items.length && (this.updatePagination(), this._tabLabelCount = this._items.length, this._changeDetectorRef.markForCheck()), this._selectedIndexChanged && (this._scrollToLabel(this._selectedIndex), this._checkScrollingControls(), this._alignInkBarToSelectedTab(), this._selectedIndexChanged = !1, this._changeDetectorRef.markForCheck()), this._scrollDistanceChanged && (this._updateTabScrollPosition(), this._scrollDistanceChanged = !1, this._changeDetectorRef.markForCheck()) } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete(), this._stopScrolling.complete() } _handleKeydown(t) { if (!Iv(t)) switch (t.keyCode) {
                    case 36:
                        this._keyManager.setFirstItemActive(), t.preventDefault(); break;
                    case 35:
                        this._keyManager.setLastItemActive(), t.preventDefault(); break;
                    case 13:
                    case 32:
                        this.selectFocusedIndex.emit(this.focusIndex), this._itemSelected(t); break;
                    default:
                        this._keyManager.onKeydown(t) } } _onContentChanges() { const t = this._elementRef.nativeElement.textContent;
                t !== this._currentTextContent && (this._currentTextContent = t || "", this._ngZone.run(() => { this.updatePagination(), this._alignInkBarToSelectedTab(), this._changeDetectorRef.markForCheck() })) } updatePagination() { this._checkPaginationEnabled(), this._checkScrollingControls(), this._updateTabScrollPosition() } get focusIndex() { return this._keyManager ? this._keyManager.activeItemIndex : 0 } set focusIndex(t) { this._isValidIndex(t) && this.focusIndex !== t && this._keyManager && this._keyManager.setActiveItem(t) } _isValidIndex(t) { if (!this._items) return !0; const e = this._items ? this._items.toArray()[t] : null; return !!e && !e.disabled } _setTabFocus(t) { if (this._showPaginationControls && this._scrollToLabel(t), this._items && this._items.length) { this._items.toArray()[t].focus(); const e = this._tabListContainer.nativeElement,
                        i = this._getLayoutDirection();
                    e.scrollLeft = "ltr" == i ? 0 : e.scrollWidth - e.offsetWidth } } _getLayoutDirection() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } _updateTabScrollPosition() { if (this.disablePagination) return; const t = this.scrollDistance,
                    e = this._platform,
                    i = "ltr" === this._getLayoutDirection() ? -t : t;
                this._tabList.nativeElement.style.transform = `translateX(${Math.round(i)}px)`, e && (e.TRIDENT || e.EDGE) && (this._tabListContainer.nativeElement.scrollLeft = 0) } get scrollDistance() { return this._scrollDistance } set scrollDistance(t) { this._scrollTo(t) } _scrollHeader(t) { return this._scrollTo(this._scrollDistance + ("before" == t ? -1 : 1) * this._tabListContainer.nativeElement.offsetWidth / 3) } _handlePaginatorClick(t) { this._stopInterval(), this._scrollHeader(t) } _scrollToLabel(t) { if (this.disablePagination) return; const e = this._items ? this._items.toArray()[t] : null; if (!e) return; const i = this._tabListContainer.nativeElement.offsetWidth,
                    { offsetLeft: n, offsetWidth: s } = e.elementRef.nativeElement; let r, a; "ltr" == this._getLayoutDirection() ? (r = n, a = r + s) : (a = this._tabList.nativeElement.offsetWidth - n, r = a - s); const o = this.scrollDistance,
                    l = this.scrollDistance + i;
                r < o ? this.scrollDistance -= o - r + 60 : a > l && (this.scrollDistance += a - l + 60) } _checkPaginationEnabled() { if (this.disablePagination) this._showPaginationControls = !1;
                else { const t = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;
                    t || (this.scrollDistance = 0), t !== this._showPaginationControls && this._changeDetectorRef.markForCheck(), this._showPaginationControls = t } } _checkScrollingControls() { this.disablePagination ? this._disableScrollAfter = this._disableScrollBefore = !0 : (this._disableScrollBefore = 0 == this.scrollDistance, this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance(), this._changeDetectorRef.markForCheck()) } _getMaxScrollDistance() { return this._tabList.nativeElement.scrollWidth - this._tabListContainer.nativeElement.offsetWidth || 0 } _alignInkBarToSelectedTab() { const t = this._items && this._items.length ? this._items.toArray()[this.selectedIndex] : null,
                    e = t ? t.elementRef.nativeElement : null;
                e ? this._inkBar.alignToElement(e) : this._inkBar.hide() } _stopInterval() { this._stopScrolling.next() } _handlePaginatorPress(t, e) { e && null != e.button && 0 !== e.button || (this._stopInterval(), zk(650, 100).pipe(jk(q(this._stopScrolling, this._destroyed))).subscribe(() => { const { maxScrollDistance: e, distance: i } = this._scrollHeader(t);
                    (0 === i || i >= e) && this._stopInterval() })) } _scrollTo(t) { if (this.disablePagination) return { maxScrollDistance: 0, distance: 0 }; const e = this._getMaxScrollDistance(); return this._scrollDistance = Math.max(0, Math.min(e, t)), this._scrollDistanceChanged = !0, this._checkScrollingControls(), { maxScrollDistance: e, distance: this._scrollDistance } } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(mD), Sa(Rw, 8), Sa(Pc), Sa(Wv), Sa(aS, 8)) }, t.\u0275dir = we({ type: t, inputs: { disablePagination: "disablePagination" } }), t })(), UP = (() => { class t extends zP { constructor(t, e, i, n, s, r, a) { super(t, e, i, n, s, r, a), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = Vv(t) } _itemSelected(t) { t.preventDefault() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(mD), Sa(Rw, 8), Sa(Pc), Sa(Wv), Sa(aS, 8)) }, t.\u0275dir = we({ type: t, inputs: { disableRipple: "disableRipple" }, features: [Eo] }), t })(), HP = (() => { class t extends UP { constructor(t, e, i, n, s, r, a) { super(t, e, i, n, s, r, a) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(mD), Sa(Rw, 8), Sa(Pc), Sa(Wv), Sa(aS, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-tab-header"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, BP, !1), 2 & t && tc(n = oc()) && (e._items = n) }, viewQuery: function(t, e) { var i;
                1 & t && (ec(_P, !0), ec(dP, !0), ec(uP, !0), ic(mP, !0), ic(pP, !0)), 2 & t && (tc(i = oc()) && (e._inkBar = i.first), tc(i = oc()) && (e._tabListContainer = i.first), tc(i = oc()) && (e._tabList = i.first), tc(i = oc()) && (e._nextPaginator = i.first), tc(i = oc()) && (e._previousPaginator = i.first)) }, hostAttrs: [1, "mat-tab-header"], hostVars: 4, hostBindings: function(t, e) { 2 & t && no("mat-tab-header-pagination-controls-enabled", e._showPaginationControls)("mat-tab-header-rtl", "rtl" == e._getLayoutDirection()) }, inputs: { selectedIndex: "selectedIndex" }, outputs: { selectFocusedIndex: "selectFocusedIndex", indexFocused: "indexFocused" }, features: [Eo], ngContentSelectors: tP, decls: 13, vars: 8, consts: [
                ["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-before", "mat-elevation-z4", 3, "matRippleDisabled", "click", "mousedown", "touchend"],
                ["previousPaginator", ""],
                [1, "mat-tab-header-pagination-chevron"],
                [1, "mat-tab-label-container", 3, "keydown"],
                ["tabListContainer", ""],
                ["role", "tablist", 1, "mat-tab-list", 3, "cdkObserveContent"],
                ["tabList", ""],
                [1, "mat-tab-labels"],
                ["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-after", "mat-elevation-z4", 3, "matRippleDisabled", "mousedown", "click", "touchend"],
                ["nextPaginator", ""]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "div", 0, 1), Ba("click", (function() { return e._handlePaginatorClick("before") }))("mousedown", (function(t) { return e._handlePaginatorPress("before", t) }))("touchend", (function() { return e._stopInterval() })), Oa(2, "div", 2), Ta(), Ia(3, "div", 3, 4), Ba("keydown", (function(t) { return e._handleKeydown(t) })), Ia(5, "div", 5, 6), Ba("cdkObserveContent", (function() { return e._onContentChanges() })), Ia(7, "div", 7), Wa(8), Ta(), Oa(9, "mat-ink-bar"), Ta(), Ta(), Ia(10, "div", 8, 9), Ba("mousedown", (function(t) { return e._handlePaginatorPress("after", t) }))("click", (function() { return e._handlePaginatorClick("after") }))("touchend", (function() { return e._stopInterval() })), Oa(12, "div", 2), Ta()), 2 & t && (no("mat-tab-header-pagination-disabled", e._disableScrollBefore), Da("matRippleDisabled", e._disableScrollBefore || e.disableRipple), ps(5), no("_mat-animation-noopable", "NoopAnimations" === e._animationMode), ps(5), no("mat-tab-header-pagination-disabled", e._disableScrollAfter), Da("matRippleDisabled", e._disableScrollAfter || e.disableRipple)) }, directives: [qS, sw, _P], styles: ['.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:"";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\n'], encapsulation: 2 }), t })(), jP = (() => { class t extends zP { constructor(t, e, i, n, s, r, a) { super(t, n, s, e, i, r, a), this._disableRipple = !1, this.color = "primary" } get backgroundColor() { return this._backgroundColor } set backgroundColor(t) { const e = this._elementRef.nativeElement.classList;
                e.remove(`mat-background-${this.backgroundColor}`), t && e.add(`mat-background-${t}`), this._backgroundColor = t } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = Vv(t) } _itemSelected() {} ngAfterContentInit() { this._items.changes.pipe(bm(null), jk(this._destroyed)).subscribe(() => { this.updateActiveLink() }), super.ngAfterContentInit() } updateActiveLink(t) { if (!this._items) return; const e = this._items.toArray(); for (let i = 0; i < e.length; i++)
                    if (e[i].active) return this.selectedIndex = i, void this._changeDetectorRef.markForCheck();
                this.selectedIndex = -1, this._inkBar.hide() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Rw, 8), Sa(Pc), Sa(jr), Sa(mD), Sa(Wv, 8), Sa(aS, 8)) }, t.\u0275dir = we({ type: t, inputs: { color: "color", backgroundColor: "backgroundColor", disableRipple: "disableRipple" }, features: [Eo] }), t })(), GP = (() => { class t extends jP { constructor(t, e, i, n, s, r, a) { super(t, e, i, n, s, r, a) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Rw, 8), Sa(Pc), Sa(jr), Sa(mD), Sa(Wv, 8), Sa(aS, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["", "mat-tab-nav-bar", ""]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, YP, !0), 2 & t && tc(n = oc()) && (e._items = n) }, viewQuery: function(t, e) { var i;
                1 & t && (ec(_P, !0), ec(dP, !0), ec(uP, !0), ic(mP, !0), ic(pP, !0)), 2 & t && (tc(i = oc()) && (e._inkBar = i.first), tc(i = oc()) && (e._tabListContainer = i.first), tc(i = oc()) && (e._tabList = i.first), tc(i = oc()) && (e._nextPaginator = i.first), tc(i = oc()) && (e._previousPaginator = i.first)) }, hostAttrs: [1, "mat-tab-nav-bar", "mat-tab-header"], hostVars: 10, hostBindings: function(t, e) { 2 & t && no("mat-tab-header-pagination-controls-enabled", e._showPaginationControls)("mat-tab-header-rtl", "rtl" == e._getLayoutDirection())("mat-primary", "warn" !== e.color && "accent" !== e.color)("mat-accent", "accent" === e.color)("mat-warn", "warn" === e.color) }, inputs: { color: "color" }, exportAs: ["matTabNavBar", "matTabNav"], features: [Eo], attrs: fP, ngContentSelectors: tP, decls: 13, vars: 6, consts: [
                ["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-before", "mat-elevation-z4", 3, "matRippleDisabled", "click", "mousedown", "touchend"],
                ["previousPaginator", ""],
                [1, "mat-tab-header-pagination-chevron"],
                [1, "mat-tab-link-container", 3, "keydown"],
                ["tabListContainer", ""],
                [1, "mat-tab-list", 3, "cdkObserveContent"],
                ["tabList", ""],
                [1, "mat-tab-links"],
                ["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-after", "mat-elevation-z4", 3, "matRippleDisabled", "mousedown", "click", "touchend"],
                ["nextPaginator", ""]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "div", 0, 1), Ba("click", (function() { return e._handlePaginatorClick("before") }))("mousedown", (function(t) { return e._handlePaginatorPress("before", t) }))("touchend", (function() { return e._stopInterval() })), Oa(2, "div", 2), Ta(), Ia(3, "div", 3, 4), Ba("keydown", (function(t) { return e._handleKeydown(t) })), Ia(5, "div", 5, 6), Ba("cdkObserveContent", (function() { return e._onContentChanges() })), Ia(7, "div", 7), Wa(8), Ta(), Oa(9, "mat-ink-bar"), Ta(), Ta(), Ia(10, "div", 8, 9), Ba("mousedown", (function(t) { return e._handlePaginatorPress("after", t) }))("click", (function() { return e._handlePaginatorClick("after") }))("touchend", (function() { return e._stopInterval() })), Oa(12, "div", 2), Ta()), 2 & t && (no("mat-tab-header-pagination-disabled", e._disableScrollBefore), Da("matRippleDisabled", e._disableScrollBefore || e.disableRipple), ps(10), no("mat-tab-header-pagination-disabled", e._disableScrollAfter), Da("matRippleDisabled", e._disableScrollAfter || e.disableRipple)) }, directives: [qS, sw, _P], styles: ['.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:"";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center] .mat-tab-links{justify-content:center}[mat-align-tabs=end] .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\n'], encapsulation: 2 }), t })(); class $P {}
    const WP = wS(vS(bS($P)));
    let qP = (() => { class t extends WP { constructor(t, e, i, n, s, r) { super(), this._tabNavBar = t, this.elementRef = e, this._focusMonitor = s, this._isActive = !1, this.rippleConfig = i || {}, this.tabIndex = parseInt(n) || 0, "NoopAnimations" === r && (this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 }), s.monitor(e) } get active() { return this._isActive } set active(t) { t !== this._isActive && (this._isActive = t, this._tabNavBar.updateActiveLink(this.elementRef)) } get rippleDisabled() { return this.disabled || this.disableRipple || this._tabNavBar.disableRipple || !!this.rippleConfig.disabled } focus() { this.elementRef.nativeElement.focus() } ngOnDestroy() { this._focusMonitor.stopMonitoring(this.elementRef) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jP), Sa(Wo), Sa(WS, 8), ka("tabindex"), Sa(Ew), Sa(aS, 8)) }, t.\u0275dir = we({ type: t, inputs: { active: "active" }, features: [Eo] }), t })(), YP = (() => { class t extends qP { constructor(t, e, i, n, s, r, a, o) { super(t, e, s, r, a, o), this._tabLinkRipple = new $S(this, i, e, n), this._tabLinkRipple.setupTriggerEvents(e.nativeElement) } ngOnDestroy() { super.ngOnDestroy(), this._tabLinkRipple._removeTriggerEvents() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(GP), Sa(Wo), Sa(Pc), Sa(Wv), Sa(WS, 8), ka("tabindex"), Sa(Ew), Sa(aS, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "mat-tab-link", ""],
                ["", "matTabLink", ""]
            ], hostAttrs: [1, "mat-tab-link", "mat-focus-indicator"], hostVars: 7, hostBindings: function(t, e) { 2 & t && (va("aria-current", e.active ? "page" : null)("aria-disabled", e.disabled)("tabIndex", e.tabIndex), no("mat-tab-disabled", e.disabled)("mat-tab-label-active", e.active)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex" }, exportAs: ["matTabLink"], features: [Eo] }), t })(), XP = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [Jd, _S, ED, YS, rw, Tw], _S
            ] }), t })(), KP = 0, ZP = (() => { class t { constructor() { this._stateChanges = new k, this._openCloseAllActions = new k, this.id = `cdk-accordion-${KP++}`, this._multi = !1 } get multi() { return this._multi } set multi(t) { this._multi = Vv(t) } openAll() { this._openCloseAll(!0) } closeAll() { this._openCloseAll(!1) } ngOnChanges(t) { this._stateChanges.next(t) } ngOnDestroy() { this._stateChanges.complete() } _openCloseAll(t) { this.multi && this._openCloseAllActions.next(t) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["cdk-accordion"],
                ["", "cdkAccordion", ""]
            ], inputs: { multi: "multi" }, exportAs: ["cdkAccordion"], features: [Ro] }), t })(), QP = 0, JP = (() => { class t { constructor(t, e, i) { this.accordion = t, this._changeDetectorRef = e, this._expansionDispatcher = i, this._openCloseAllSubscription = d.EMPTY, this.closed = new jl, this.opened = new jl, this.destroyed = new jl, this.expandedChange = new jl, this.id = `cdk-accordion-child-${QP++}`, this._expanded = !1, this._disabled = !1, this._removeUniqueSelectionListener = () => {}, this._removeUniqueSelectionListener = i.listen((t, e) => { this.accordion && !this.accordion.multi && this.accordion.id === e && this.id !== t && (this.expanded = !1) }), this.accordion && (this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions()) } get expanded() { return this._expanded } set expanded(t) { t = Vv(t), this._expanded !== t && (this._expanded = t, this.expandedChange.emit(t), t ? (this.opened.emit(), this._expansionDispatcher.notify(this.id, this.accordion ? this.accordion.id : this.id)) : this.closed.emit(), this._changeDetectorRef.markForCheck()) } get disabled() { return this._disabled } set disabled(t) { this._disabled = Vv(t) } ngOnDestroy() { this.opened.complete(), this.closed.complete(), this.destroyed.emit(), this.destroyed.complete(), this._removeUniqueSelectionListener(), this._openCloseAllSubscription.unsubscribe() } toggle() { this.disabled || (this.expanded = !this.expanded) } close() { this.disabled || (this.expanded = !1) } open() { this.disabled || (this.expanded = !0) } _subscribeToOpenCloseAllActions() { return this.accordion._openCloseAllActions.subscribe(t => { this.disabled || (this.expanded = t) }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(ZP, 12), Sa(jr), Sa(hD)) }, t.\u0275dir = we({ type: t, selectors: [
                ["cdk-accordion-item"],
                ["", "cdkAccordionItem", ""]
            ], inputs: { expanded: "expanded", disabled: "disabled" }, outputs: { closed: "closed", opened: "opened", destroyed: "destroyed", expandedChange: "expandedChange" }, exportAs: ["cdkAccordionItem"], features: [Ho([{ provide: ZP, useValue: void 0 }])] }), t })(), tF = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })();
    const eF = ["body"];

    function iF(t, e) {}
    const nF = [
        [
            ["mat-expansion-panel-header"]
        ], "*", [
            ["mat-action-row"]
        ]
    ], sF = ["mat-expansion-panel-header", "*", "mat-action-row"], rF = function(t, e) { return { collapsedHeight: t, expandedHeight: e } }, aF = function(t, e) { return { value: t, params: e } };

    function oF(t, e) { 1 & t && Oa(0, "span", 2), 2 & t && Da("@indicatorRotate", ja()._getExpandedState()) }
    const lF = [
        [
            ["mat-panel-title"]
        ],
        [
            ["mat-panel-description"]
        ], "*"
    ], cF = ["mat-panel-title", "mat-panel-description", "*"], hF = new Vt("MAT_ACCORDION"), dF = { indicatorRotate: Lw("indicatorRotate", [Hw("collapsed, void", Uw({ transform: "rotate(0deg)" })), Hw("expanded", Uw({ transform: "rotate(180deg)" })), Gw("expanded <=> collapsed, void => collapsed", Bw("225ms cubic-bezier(0.4,0.0,0.2,1)"))]), expansionHeaderHeight: Lw("expansionHeight", [Hw("collapsed, void", Uw({ height: "{{collapsedHeight}}" }), { params: { collapsedHeight: "48px" } }), Hw("expanded", Uw({ height: "{{expandedHeight}}" }), { params: { expandedHeight: "64px" } }), Gw("expanded <=> collapsed, void => collapsed", Vw([Yw("@indicatorRotate", Ww(), { optional: !0 }), Bw("225ms cubic-bezier(0.4,0.0,0.2,1)")]))]), bodyExpansion: Lw("bodyExpansion", [Hw("collapsed, void", Uw({ height: "0px", visibility: "hidden" })), Hw("expanded", Uw({ height: "*", visibility: "visible" })), Gw("expanded <=> collapsed, void => collapsed", Bw("225ms cubic-bezier(0.4,0.0,0.2,1)"))]) };
    let uF = (() => { class t { constructor(t) { this._template = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl)) }, t.\u0275dir = we({ type: t, selectors: [
                ["ng-template", "matExpansionPanelContent", ""]
            ] }), t })(), mF = 0;
    const pF = new Vt("MAT_EXPANSION_PANEL_DEFAULT_OPTIONS");
    let fF = (() => { class t extends JP { constructor(t, e, i, n, s, r, a) { super(t, e, i), this._viewContainerRef = n, this._animationMode = r, this._hideToggle = !1, this.afterExpand = new jl, this.afterCollapse = new jl, this._inputChanges = new k, this._headerId = `mat-expansion-panel-header-${mF++}`, this._bodyAnimationDone = new k, this.accordion = t, this._document = s, this._bodyAnimationDone.pipe(XE((t, e) => t.fromState === e.fromState && t.toState === e.toState)).subscribe(t => { "void" !== t.fromState && ("expanded" === t.toState ? this.afterExpand.emit() : "collapsed" === t.toState && this.afterCollapse.emit()) }), a && (this.hideToggle = a.hideToggle) } get hideToggle() { return this._hideToggle || this.accordion && this.accordion.hideToggle } set hideToggle(t) { this._hideToggle = Vv(t) } get togglePosition() { return this._togglePosition || this.accordion && this.accordion.togglePosition } set togglePosition(t) { this._togglePosition = t } _hasSpacing() { return !!this.accordion && this.expanded && "default" === this.accordion.displayMode } _getExpandedState() { return this.expanded ? "expanded" : "collapsed" } toggle() { this.expanded = !this.expanded } close() { this.expanded = !1 } open() { this.expanded = !0 } ngAfterContentInit() { this._lazyContent && this.opened.pipe(bm(null), Gu(() => this.expanded && !this._portal), lm(1)).subscribe(() => { this._portal = new bD(this._lazyContent._template, this._viewContainerRef) }) } ngOnChanges(t) { this._inputChanges.next(t) } ngOnDestroy() { super.ngOnDestroy(), this._bodyAnimationDone.complete(), this._inputChanges.complete() } _containsFocus() { if (this._body) { const t = this._document.activeElement,
                        e = this._body.nativeElement; return t === e || e.contains(t) } return !1 } } return t.\u0275fac = function(e) { return new(e || t)(Sa(hF, 12), Sa(jr), Sa(hD), Sa(bl), Sa(uh), Sa(aS, 8), Sa(pF, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-expansion-panel"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, uF, !0), 2 & t && tc(n = oc()) && (e._lazyContent = n.first) }, viewQuery: function(t, e) { var i;
                1 & t && ic(eF, !0), 2 & t && tc(i = oc()) && (e._body = i.first) }, hostAttrs: [1, "mat-expansion-panel"], hostVars: 6, hostBindings: function(t, e) { 2 & t && no("mat-expanded", e.expanded)("_mat-animation-noopable", "NoopAnimations" === e._animationMode)("mat-expansion-panel-spacing", e._hasSpacing()) }, inputs: { disabled: "disabled", expanded: "expanded", hideToggle: "hideToggle", togglePosition: "togglePosition" }, outputs: { opened: "opened", closed: "closed", expandedChange: "expandedChange", afterExpand: "afterExpand", afterCollapse: "afterCollapse" }, exportAs: ["matExpansionPanel"], features: [Ho([{ provide: hF, useValue: void 0 }]), Eo, Ro], ngContentSelectors: sF, decls: 7, vars: 4, consts: [
                ["role", "region", 1, "mat-expansion-panel-content", 3, "id"],
                ["body", ""],
                [1, "mat-expansion-panel-body"],
                [3, "cdkPortalOutlet"]
            ], template: function(t, e) { 1 & t && ($a(nF), Wa(0), Ia(1, "div", 0, 1), Ba("@bodyExpansion.done", (function(t) { return e._bodyAnimationDone.next(t) })), Ia(3, "div", 2), Wa(4, 1), Ca(5, iF, 0, 0, "ng-template", 3), Ta(), Wa(6, 2), Ta()), 2 & t && (ps(1), Da("@bodyExpansion", e._getExpandedState())("id", e.id), va("aria-labelledby", e._headerId), ps(4), Da("cdkPortalOutlet", e._portal)) }, directives: [xD], styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}.cdk-high-contrast-active .mat-expansion-panel{outline:solid 1px}.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel,.mat-expansion-panel._mat-animation-noopable{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base,.mat-action-row button.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base,[dir=rtl] .mat-action-row button.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"], encapsulation: 2, data: { animation: [dF.bodyExpansion] }, changeDetection: 0 }), t })(), gF = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-action-row"]
            ], hostAttrs: [1, "mat-action-row"] }), t })(), _F = (() => { class t { constructor(t, e, i, n, s) { this.panel = t, this._element = e, this._focusMonitor = i, this._changeDetectorRef = n, this._parentChangeSubscription = d.EMPTY, this._animationsDisabled = !0; const r = t.accordion ? t.accordion._stateChanges.pipe(Gu(t => !(!t.hideToggle && !t.togglePosition))) : zu;
                this._parentChangeSubscription = q(t.opened, t.closed, r, t._inputChanges.pipe(Gu(t => !!(t.hideToggle || t.disabled || t.togglePosition)))).subscribe(() => this._changeDetectorRef.markForCheck()), t.closed.pipe(Gu(() => t._containsFocus())).subscribe(() => i.focusVia(e, "program")), i.monitor(e).subscribe(e => { e && t.accordion && t.accordion._handleHeaderFocus(this) }), s && (this.expandedHeight = s.expandedHeight, this.collapsedHeight = s.collapsedHeight) } _animationStarted() { this._animationsDisabled = !1 } get disabled() { return this.panel.disabled } _toggle() { this.disabled || this.panel.toggle() } _isExpanded() { return this.panel.expanded } _getExpandedState() { return this.panel._getExpandedState() } _getPanelId() { return this.panel.id } _getTogglePosition() { return this.panel.togglePosition } _showToggle() { return !this.panel.hideToggle && !this.panel.disabled } _keydown(t) { switch (t.keyCode) {
                    case 32:
                    case 13:
                        Iv(t) || (t.preventDefault(), this._toggle()); break;
                    default:
                        return void(this.panel.accordion && this.panel.accordion._handleHeaderKeydown(t)) } } focus(t = "program", e) { this._focusMonitor.focusVia(this._element, t, e) } ngOnDestroy() { this._parentChangeSubscription.unsubscribe(), this._focusMonitor.stopMonitoring(this._element) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(fF, 1), Sa(Wo), Sa(Ew), Sa(jr), Sa(pF, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-expansion-panel-header"]
            ], hostAttrs: ["role", "button", 1, "mat-expansion-panel-header"], hostVars: 19, hostBindings: function(t, e) { 1 & t && (Va("@expansionHeight.start", (function() { return e._animationStarted() })), Ba("click", (function() { return e._toggle() }))("keydown", (function(t) { return e._keydown(t) }))), 2 & t && (va("id", e.panel._headerId)("tabindex", e.disabled ? -1 : 0)("aria-controls", e._getPanelId())("aria-expanded", e._isExpanded())("aria-disabled", e.panel.disabled), So("@.disabled", e._animationsDisabled)("@expansionHeight", Bl(16, aF, e._getExpandedState(), Bl(13, rF, e.collapsedHeight, e.expandedHeight))), no("mat-expanded", e._isExpanded())("mat-expansion-toggle-indicator-after", "after" === e._getTogglePosition())("mat-expansion-toggle-indicator-before", "before" === e._getTogglePosition())) }, inputs: { expandedHeight: "expandedHeight", collapsedHeight: "collapsedHeight" }, ngContentSelectors: cF, decls: 5, vars: 1, consts: [
                [1, "mat-content"],
                ["class", "mat-expansion-indicator", 4, "ngIf"],
                [1, "mat-expansion-indicator"]
            ], template: function(t, e) { 1 & t && ($a(lF), Ia(0, "span", 0), Wa(1), Wa(2, 1), Wa(3, 2), Ta(), Ca(4, oF, 1, 1, "span", 1)), 2 & t && (ps(4), Da("ngIf", e._showToggle())) }, directives: [yd], styles: ['.mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:"";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}\n'], encapsulation: 2, data: { animation: [dF.indicatorRotate, dF.expansionHeaderHeight] }, changeDetection: 0 }), t })(), bF = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-panel-description"]
            ], hostAttrs: [1, "mat-expansion-panel-header-description"] }), t })(), yF = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-panel-title"]
            ], hostAttrs: [1, "mat-expansion-panel-header-title"] }), t })(), vF = (() => { class t extends ZP { constructor() { super(...arguments), this._ownHeaders = new $l, this._hideToggle = !1, this.displayMode = "default", this.togglePosition = "after" } get hideToggle() { return this._hideToggle } set hideToggle(t) { this._hideToggle = Vv(t) } ngAfterContentInit() { this._headers.changes.pipe(bm(this._headers)).subscribe(t => { this._ownHeaders.reset(t.filter(t => t.panel.accordion === this)), this._ownHeaders.notifyOnChanges() }), this._keyManager = new mw(this._ownHeaders).withWrap() } _handleHeaderKeydown(t) { const { keyCode: e } = t, i = this._keyManager;
                36 === e ? Iv(t) || (i.setFirstItemActive(), t.preventDefault()) : 35 === e ? Iv(t) || (i.setLastItemActive(), t.preventDefault()) : this._keyManager.onKeydown(t) } _handleHeaderFocus(t) { this._keyManager.updateActiveItem(t) } } return t.\u0275fac = function(e) { return wF(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-accordion"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, _F, !0), 2 & t && tc(n = oc()) && (e._headers = n) }, hostAttrs: [1, "mat-accordion"], hostVars: 2, hostBindings: function(t, e) { 2 & t && no("mat-accordion-multi", e.multi) }, inputs: { multi: "multi", displayMode: "displayMode", togglePosition: "togglePosition", hideToggle: "hideToggle" }, exportAs: ["matAccordion"], features: [Ho([{ provide: hF, useExisting: t }]), Eo] }), t })();
    const wF = ln(vF);
    let CF = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [Jd, tF, ED]
            ] }), t })();
    const xF = ["button"], SF = ["*"], kF = new Vt("MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS"), EF = { provide: vg, useExisting: St(() => TF), multi: !0 }; class DF {}
    let AF = 0; class IF { constructor(t, e) { this.source = t, this.value = e } }
    let TF = (() => { class t { constructor(t, e) { this._changeDetector = t, this._vertical = !1, this._multiple = !1, this._disabled = !1, this._controlValueAccessorChangeFn = () => {}, this._onTouched = () => {}, this._name = `mat-button-toggle-group-${AF++}`, this.valueChange = new jl, this.change = new jl, this.appearance = e && e.appearance ? e.appearance : "standard" } get name() { return this._name } set name(t) { this._name = t, this._buttonToggles && this._buttonToggles.forEach(t => { t.name = this._name, t._markForCheck() }) } get vertical() { return this._vertical } set vertical(t) { this._vertical = Vv(t) } get value() { const t = this._selectionModel ? this._selectionModel.selected : []; return this.multiple ? t.map(t => t.value) : t[0] ? t[0].value : void 0 } set value(t) { this._setSelectionByValue(t), this.valueChange.emit(this.value) } get selected() { const t = this._selectionModel ? this._selectionModel.selected : []; return this.multiple ? t : t[0] || null } get multiple() { return this._multiple } set multiple(t) { this._multiple = Vv(t) } get disabled() { return this._disabled } set disabled(t) { this._disabled = Vv(t), this._buttonToggles && this._buttonToggles.forEach(t => t._markForCheck()) } ngOnInit() { this._selectionModel = new cD(this.multiple, void 0, !1) } ngAfterContentInit() { this._selectionModel.select(...this._buttonToggles.filter(t => t.checked)) } writeValue(t) { this.value = t, this._changeDetector.markForCheck() } registerOnChange(t) { this._controlValueAccessorChangeFn = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t } _emitChangeEvent() { const t = this.selected,
                    e = Array.isArray(t) ? t[t.length - 1] : t,
                    i = new IF(e, this.value);
                this._controlValueAccessorChangeFn(i.value), this.change.emit(i) } _syncButtonToggle(t, e, i = !1, n = !1) { this.multiple || !this.selected || t.checked || (this.selected.checked = !1), this._selectionModel ? e ? this._selectionModel.select(t) : this._selectionModel.deselect(t) : n = !0, n ? Promise.resolve(() => this._updateModelValue(i)) : this._updateModelValue(i) } _isSelected(t) { return this._selectionModel && this._selectionModel.isSelected(t) } _isPrechecked(t) { return void 0 !== this._rawValue && (this.multiple && Array.isArray(this._rawValue) ? this._rawValue.some(e => null != t.value && e === t.value) : t.value === this._rawValue) } _setSelectionByValue(t) { if (this._rawValue = t, this._buttonToggles)
                    if (this.multiple && t) { if (!Array.isArray(t)) throw Error("Value must be an array in multiple-selection mode.");
                        this._clearSelection(), t.forEach(t => this._selectValue(t)) } else this._clearSelection(), this._selectValue(t) } _clearSelection() { this._selectionModel.clear(), this._buttonToggles.forEach(t => t.checked = !1) } _selectValue(t) { const e = this._buttonToggles.find(e => null != e.value && e.value === t);
                e && (e.checked = !0, this._selectionModel.select(e)) } _updateModelValue(t) { t && this._emitChangeEvent(), this.valueChange.emit(this.value) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jr), Sa(kF, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-button-toggle-group"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, MF, !0), 2 & t && tc(n = oc()) && (e._buttonToggles = n) }, hostAttrs: ["role", "group", 1, "mat-button-toggle-group"], hostVars: 5, hostBindings: function(t, e) { 2 & t && (va("aria-disabled", e.disabled), no("mat-button-toggle-vertical", e.vertical)("mat-button-toggle-group-appearance-standard", "standard" === e.appearance)) }, inputs: { appearance: "appearance", name: "name", vertical: "vertical", value: "value", multiple: "multiple", disabled: "disabled" }, outputs: { valueChange: "valueChange", change: "change" }, exportAs: ["matButtonToggleGroup"], features: [Ho([EF, { provide: DF, useExisting: t }])] }), t })(); class OF {}
    const RF = vS(OF);
    let MF = (() => { class t extends RF { constructor(t, e, i, n, s, r) { super(), this._changeDetectorRef = e, this._elementRef = i, this._focusMonitor = n, this._isSingleSelector = !1, this._checked = !1, this.ariaLabelledby = null, this._disabled = !1, this.change = new jl; const a = Number(s);
                this.tabIndex = a || 0 === a ? a : null, this.buttonToggleGroup = t, this.appearance = r && r.appearance ? r.appearance : "standard" } get buttonId() { return `${this.id}-button` } get appearance() { return this.buttonToggleGroup ? this.buttonToggleGroup.appearance : this._appearance } set appearance(t) { this._appearance = t } get checked() { return this.buttonToggleGroup ? this.buttonToggleGroup._isSelected(this) : this._checked } set checked(t) { const e = Vv(t);
                e !== this._checked && (this._checked = e, this.buttonToggleGroup && this.buttonToggleGroup._syncButtonToggle(this, this._checked), this._changeDetectorRef.markForCheck()) } get disabled() { return this._disabled || this.buttonToggleGroup && this.buttonToggleGroup.disabled } set disabled(t) { this._disabled = Vv(t) } ngOnInit() { this._isSingleSelector = this.buttonToggleGroup && !this.buttonToggleGroup.multiple, this._type = this._isSingleSelector ? "radio" : "checkbox", this.id = this.id || `mat-button-toggle-${AF++}`, this._isSingleSelector && (this.name = this.buttonToggleGroup.name), this.buttonToggleGroup && this.buttonToggleGroup._isPrechecked(this) && (this.checked = !0), this._focusMonitor.monitor(this._elementRef, !0) } ngOnDestroy() { const t = this.buttonToggleGroup;
                this._focusMonitor.stopMonitoring(this._elementRef), t && t._isSelected(this) && t._syncButtonToggle(this, !1, !1, !0) } focus(t) { this._buttonElement.nativeElement.focus(t) } _onButtonClick() { const t = !!this._isSingleSelector || !this._checked;
                t !== this._checked && (this._checked = t, this.buttonToggleGroup && (this.buttonToggleGroup._syncButtonToggle(this, this._checked, !0), this.buttonToggleGroup._onTouched())), this.change.emit(new IF(this, this.value)) } _markForCheck() { this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(TF, 8), Sa(jr), Sa(Wo), Sa(Ew), ka("tabindex"), Sa(kF, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-button-toggle"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(xF, !0), 2 & t && tc(i = oc()) && (e._buttonElement = i.first) }, hostAttrs: [1, "mat-button-toggle", "mat-focus-indicator"], hostVars: 11, hostBindings: function(t, e) { 1 & t && Ba("focus", (function() { return e.focus() })), 2 & t && (va("tabindex", -1)("id", e.id)("name", null), no("mat-button-toggle-standalone", !e.buttonToggleGroup)("mat-button-toggle-checked", e.checked)("mat-button-toggle-disabled", e.disabled)("mat-button-toggle-appearance-standard", "standard" === e.appearance)) }, inputs: { disableRipple: "disableRipple", ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], tabIndex: "tabIndex", appearance: "appearance", checked: "checked", disabled: "disabled", id: "id", name: "name", ariaLabel: ["aria-label", "ariaLabel"], value: "value" }, outputs: { change: "change" }, exportAs: ["matButtonToggle"], features: [Eo], ngContentSelectors: SF, decls: 6, vars: 9, consts: [
                ["type", "button", 1, "mat-button-toggle-button", "mat-focus-indicator", 3, "id", "disabled", "click"],
                ["button", ""],
                [1, "mat-button-toggle-label-content"],
                [1, "mat-button-toggle-focus-overlay"],
                ["matRipple", "", 1, "mat-button-toggle-ripple", 3, "matRippleTrigger", "matRippleDisabled"]
            ], template: function(t, e) { if (1 & t && ($a(), Ia(0, "button", 0, 1), Ba("click", (function() { return e._onButtonClick() })), Ia(2, "div", 2), Wa(3), Ta(), Ta(), Oa(4, "div", 3), Oa(5, "div", 4)), 2 & t) { const t = xa(1);
                    Da("id", e.buttonId)("disabled", e.disabled || null), va("tabindex", e.disabled ? -1 : e.tabIndex)("aria-pressed", e.checked)("name", e.name || null)("aria-label", e.ariaLabel)("aria-labelledby", e.ariaLabelledby), ps(5), Da("matRippleTrigger", t)("matRippleDisabled", e.disableRipple || e.disabled) } }, directives: [qS], styles: [".mat-button-toggle-standalone,.mat-button-toggle-group{position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;border-radius:2px;-webkit-tap-highlight-color:transparent}.cdk-high-contrast-active .mat-button-toggle-standalone,.cdk-high-contrast-active .mat-button-toggle-group{outline:solid 1px}.mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.mat-button-toggle-group-appearance-standard{border-radius:4px}.cdk-high-contrast-active .mat-button-toggle-standalone.mat-button-toggle-appearance-standard,.cdk-high-contrast-active .mat-button-toggle-group-appearance-standard{outline:0}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:1}.cdk-high-contrast-active .mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:.5}.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{opacity:.04}.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.12}.cdk-high-contrast-active .mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.5}@media(hover: none){.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:inline-block;line-height:36px;padding:0 16px;position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px;padding:0 12px}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{border-radius:inherit;pointer-events:none;opacity:0;top:0;left:0;right:0;bottom:0;position:absolute}.mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 36px}.cdk-high-contrast-active .mat-button-toggle-checked .mat-button-toggle-focus-overlay{opacity:.5;height:0}.cdk-high-contrast-active .mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 48px}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:none;color:inherit;padding:0;margin:0;font:inherit;outline:none;width:100%;cursor:pointer}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}\n"], encapsulation: 2, changeDetection: 0 }), t })(), PF = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [_S, YS], _S
            ] }), t })();
    const FF = ["*"]; class NF { constructor(t) { this._elementRef = t } }
    const LF = wS(yS(vS(bS(NF)), "primary"), -1);
    let BF = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-chip-avatar"],
                ["", "matChipAvatar", ""]
            ], hostAttrs: [1, "mat-chip-avatar"] }), t })(), VF = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-chip-trailing-icon"],
                ["", "matChipTrailingIcon", ""]
            ], hostAttrs: [1, "mat-chip-trailing-icon"] }), t })(), zF = (() => { class t extends LF { constructor(t, e, i, n, s, r, a, o) { super(t), this._elementRef = t, this._ngZone = e, this._changeDetectorRef = r, this._hasFocus = !1, this.chipListSelectable = !0, this._chipListMultiple = !1, this._selected = !1, this._selectable = !0, this._removable = !0, this._onFocus = new k, this._onBlur = new k, this.selectionChange = new jl, this.destroyed = new jl, this.removed = new jl, this._addHostClassName(), this._chipRippleTarget = (o || document).createElement("div"), this._chipRippleTarget.classList.add("mat-chip-ripple"), this._elementRef.nativeElement.appendChild(this._chipRippleTarget), this._chipRipple = new $S(this, e, this._chipRippleTarget, i), this._chipRipple.setupTriggerEvents(t), this.rippleConfig = n || {}, this._animationsDisabled = "NoopAnimations" === s, this.tabIndex = null != a && parseInt(a) || -1 } get rippleDisabled() { return this.disabled || this.disableRipple || !!this.rippleConfig.disabled } get selected() { return this._selected } set selected(t) { const e = Vv(t);
                e !== this._selected && (this._selected = e, this._dispatchSelectionChange()) } get value() { return void 0 !== this._value ? this._value : this._elementRef.nativeElement.textContent } set value(t) { this._value = t } get selectable() { return this._selectable && this.chipListSelectable } set selectable(t) { this._selectable = Vv(t) } get removable() { return this._removable } set removable(t) { this._removable = Vv(t) } get ariaSelected() { return this.selectable && (this._chipListMultiple || this.selected) ? this.selected.toString() : null } _addHostClassName() { const t = this._elementRef.nativeElement;
                t.hasAttribute("mat-basic-chip") || "mat-basic-chip" === t.tagName.toLowerCase() ? t.classList.add("mat-basic-chip") : t.classList.add("mat-standard-chip") } ngOnDestroy() { this.destroyed.emit({ chip: this }), this._chipRipple._removeTriggerEvents() } select() { this._selected || (this._selected = !0, this._dispatchSelectionChange(), this._markForCheck()) } deselect() { this._selected && (this._selected = !1, this._dispatchSelectionChange(), this._markForCheck()) } selectViaInteraction() { this._selected || (this._selected = !0, this._dispatchSelectionChange(!0), this._markForCheck()) } toggleSelected(t = !1) { return this._selected = !this.selected, this._dispatchSelectionChange(t), this._markForCheck(), this.selected } focus() { this._hasFocus || (this._elementRef.nativeElement.focus(), this._onFocus.next({ chip: this })), this._hasFocus = !0 } remove() { this.removable && this.removed.emit({ chip: this }) } _handleClick(t) { this.disabled ? t.preventDefault() : t.stopPropagation() } _handleKeydown(t) { if (!this.disabled) switch (t.keyCode) {
                    case 46:
                    case 8:
                        this.remove(), t.preventDefault(); break;
                    case 32:
                        this.selectable && this.toggleSelected(!0), t.preventDefault() } } _blur() { this._ngZone.onStable.asObservable().pipe(lm(1)).subscribe(() => { this._ngZone.run(() => { this._hasFocus = !1, this._onBlur.next({ chip: this }) }) }) } _dispatchSelectionChange(t = !1) { this.selectionChange.emit({ source: this, isUserInput: t, selected: this._selected }) } _markForCheck() { this._changeDetectorRef && this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Pc), Sa(Wv), Sa(WS, 8), Sa(aS, 8), Sa(jr), ka("tabindex"), Sa(uh, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-basic-chip"],
                ["", "mat-basic-chip", ""],
                ["mat-chip"],
                ["", "mat-chip", ""]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, BF, !0), sc(i, VF, !0), sc(i, UF, !0)), 2 & t && (tc(n = oc()) && (e.avatar = n.first), tc(n = oc()) && (e.trailingIcon = n.first), tc(n = oc()) && (e.removeIcon = n.first)) }, hostAttrs: ["role", "option", 1, "mat-chip", "mat-focus-indicator"], hostVars: 14, hostBindings: function(t, e) { 1 & t && Ba("click", (function(t) { return e._handleClick(t) }))("keydown", (function(t) { return e._handleKeydown(t) }))("focus", (function() { return e.focus() }))("blur", (function() { return e._blur() })), 2 & t && (va("tabindex", e.disabled ? null : e.tabIndex)("disabled", e.disabled || null)("aria-disabled", e.disabled.toString())("aria-selected", e.ariaSelected), no("mat-chip-selected", e.selected)("mat-chip-with-avatar", e.avatar)("mat-chip-with-trailing-icon", e.trailingIcon || e.removeIcon)("mat-chip-disabled", e.disabled)("_mat-animation-noopable", e._animationsDisabled)) }, inputs: { color: "color", disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex", selected: "selected", value: "value", selectable: "selectable", removable: "removable" }, outputs: { selectionChange: "selectionChange", destroyed: "destroyed", removed: "removed" }, exportAs: ["matChip"], features: [Eo] }), t })(), UF = (() => { class t { constructor(t, e) { this._parentChip = t, e && "BUTTON" === e.nativeElement.nodeName && e.nativeElement.setAttribute("type", "button") } _handleClick(t) { const e = this._parentChip;
                e.removable && !e.disabled && e.remove(), t.stopPropagation() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(zF), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matChipRemove", ""]
            ], hostAttrs: [1, "mat-chip-remove", "mat-chip-trailing-icon"], hostBindings: function(t, e) { 1 & t && Ba("click", (function(t) { return e._handleClick(t) })) } }), t })();
    const HF = new Vt("mat-chips-default-options"); class jF { constructor(t, e, i, n) { this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = i, this.ngControl = n } }
    const GF = CS(jF);
    let $F = 0; class WF { constructor(t, e) { this.source = t, this.value = e } }
    let qF = (() => { class t extends GF { constructor(t, e, i, n, s, r, a) { super(r, n, s, a), this._elementRef = t, this._changeDetectorRef = e, this._dir = i, this.ngControl = a, this.controlType = "mat-chip-list", this._lastDestroyedChipIndex = null, this._destroyed = new k, this._uid = `mat-chip-list-${$F++}`, this._tabIndex = 0, this._userTabIndex = null, this._onTouched = () => {}, this._onChange = () => {}, this._multiple = !1, this._compareWith = (t, e) => t === e, this._required = !1, this._disabled = !1, this.ariaOrientation = "horizontal", this._selectable = !0, this.change = new jl, this.valueChange = new jl, this.ngControl && (this.ngControl.valueAccessor = this) } get selected() { return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0] } get role() { return this.empty ? null : "listbox" } get multiple() { return this._multiple } set multiple(t) { this._multiple = Vv(t), this._syncChipsState() } get compareWith() { return this._compareWith } set compareWith(t) { this._compareWith = t, this._selectionModel && this._initializeSelection() } get value() { return this._value } set value(t) { this.writeValue(t), this._value = t } get id() { return this._chipInput ? this._chipInput.id : this._uid } get required() { return this._required } set required(t) { this._required = Vv(t), this.stateChanges.next() } get placeholder() { return this._chipInput ? this._chipInput.placeholder : this._placeholder } set placeholder(t) { this._placeholder = t, this.stateChanges.next() } get focused() { return this._chipInput && this._chipInput.focused || this._hasFocusedChip() } get empty() { return (!this._chipInput || this._chipInput.empty) && 0 === this.chips.length } get shouldLabelFloat() { return !this.empty || this.focused } get disabled() { return this.ngControl ? !!this.ngControl.disabled : this._disabled } set disabled(t) { this._disabled = Vv(t), this._syncChipsState() } get selectable() { return this._selectable } set selectable(t) { this._selectable = Vv(t), this.chips && this.chips.forEach(t => t.chipListSelectable = this._selectable) } set tabIndex(t) { this._userTabIndex = t, this._tabIndex = t } get chipSelectionChanges() { return q(...this.chips.map(t => t.selectionChange)) } get chipFocusChanges() { return q(...this.chips.map(t => t._onFocus)) } get chipBlurChanges() { return q(...this.chips.map(t => t._onBlur)) } get chipRemoveChanges() { return q(...this.chips.map(t => t.destroyed)) } ngAfterContentInit() { this._keyManager = new mw(this.chips).withWrap().withVerticalOrientation().withHorizontalOrientation(this._dir ? this._dir.value : "ltr"), this._dir && this._dir.change.pipe(jk(this._destroyed)).subscribe(t => this._keyManager.withHorizontalOrientation(t)), this._keyManager.tabOut.pipe(jk(this._destroyed)).subscribe(() => { this._allowFocusEscape() }), this.chips.changes.pipe(bm(null), jk(this._destroyed)).subscribe(() => { this.disabled && Promise.resolve().then(() => { this._syncChipsState() }), this._resetChips(), this._initializeSelection(), this._updateTabIndex(), this._updateFocusForDestroyedChips(), this.stateChanges.next() }) } ngOnInit() { this._selectionModel = new cD(this.multiple, void 0, !1), this.stateChanges.next() } ngDoCheck() { this.ngControl && this.updateErrorState() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete(), this.stateChanges.complete(), this._dropSubscriptions() } registerInput(t) { this._chipInput = t } setDescribedByIds(t) { this._ariaDescribedby = t.join(" ") } writeValue(t) { this.chips && this._setSelectionByValue(t, !1) } registerOnChange(t) { this._onChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t, this.stateChanges.next() } onContainerClick(t) { this._originatesFromChip(t) || this.focus() } focus(t) { this.disabled || this._chipInput && this._chipInput.focused || (this.chips.length > 0 ? (this._keyManager.setFirstItemActive(), this.stateChanges.next()) : (this._focusInput(t), this.stateChanges.next())) } _focusInput(t) { this._chipInput && this._chipInput.focus(t) } _keydown(t) { const e = t.target;
                8 === t.keyCode && this._isInputEmpty(e) ? (this._keyManager.setLastItemActive(), t.preventDefault()) : e && e.classList.contains("mat-chip") && (36 === t.keyCode ? (this._keyManager.setFirstItemActive(), t.preventDefault()) : 35 === t.keyCode ? (this._keyManager.setLastItemActive(), t.preventDefault()) : this._keyManager.onKeydown(t), this.stateChanges.next()) } _updateTabIndex() { this._tabIndex = this._userTabIndex || (0 === this.chips.length ? -1 : 0) } _updateFocusForDestroyedChips() { if (null != this._lastDestroyedChipIndex)
                    if (this.chips.length) { const t = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);
                        this._keyManager.setActiveItem(t) } else this.focus();
                this._lastDestroyedChipIndex = null } _isValidIndex(t) { return t >= 0 && t < this.chips.length } _isInputEmpty(t) { return !(!t || "input" !== t.nodeName.toLowerCase() || t.value) } _setSelectionByValue(t, e = !0) { if (this._clearSelection(), this.chips.forEach(t => t.deselect()), Array.isArray(t)) t.forEach(t => this._selectValue(t, e)), this._sortValues();
                else { const i = this._selectValue(t, e);
                    i && e && this._keyManager.setActiveItem(i) } } _selectValue(t, e = !0) { const i = this.chips.find(e => null != e.value && this._compareWith(e.value, t)); return i && (e ? i.selectViaInteraction() : i.select(), this._selectionModel.select(i)), i } _initializeSelection() { Promise.resolve().then(() => {
                    (this.ngControl || this._value) && (this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value, !1), this.stateChanges.next()) }) } _clearSelection(t) { this._selectionModel.clear(), this.chips.forEach(e => { e !== t && e.deselect() }), this.stateChanges.next() } _sortValues() { this._multiple && (this._selectionModel.clear(), this.chips.forEach(t => { t.selected && this._selectionModel.select(t) }), this.stateChanges.next()) } _propagateChanges(t) { let e = null;
                e = Array.isArray(this.selected) ? this.selected.map(t => t.value) : this.selected ? this.selected.value : t, this._value = e, this.change.emit(new WF(this, e)), this.valueChange.emit(e), this._onChange(e), this._changeDetectorRef.markForCheck() } _blur() { this._hasFocusedChip() || this._keyManager.setActiveItem(-1), this.disabled || (this._chipInput ? setTimeout(() => { this.focused || this._markAsTouched() }) : this._markAsTouched()) } _markAsTouched() { this._onTouched(), this._changeDetectorRef.markForCheck(), this.stateChanges.next() } _allowFocusEscape() {-1 !== this._tabIndex && (this._tabIndex = -1, setTimeout(() => { this._tabIndex = this._userTabIndex || 0, this._changeDetectorRef.markForCheck() })) } _resetChips() { this._dropSubscriptions(), this._listenToChipsFocus(), this._listenToChipsSelection(), this._listenToChipsRemoved() } _dropSubscriptions() { this._chipFocusSubscription && (this._chipFocusSubscription.unsubscribe(), this._chipFocusSubscription = null), this._chipBlurSubscription && (this._chipBlurSubscription.unsubscribe(), this._chipBlurSubscription = null), this._chipSelectionSubscription && (this._chipSelectionSubscription.unsubscribe(), this._chipSelectionSubscription = null), this._chipRemoveSubscription && (this._chipRemoveSubscription.unsubscribe(), this._chipRemoveSubscription = null) } _listenToChipsSelection() { this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(t => { t.source.selected ? this._selectionModel.select(t.source) : this._selectionModel.deselect(t.source), this.multiple || this.chips.forEach(t => {!this._selectionModel.isSelected(t) && t.selected && t.deselect() }), t.isUserInput && this._propagateChanges() }) } _listenToChipsFocus() { this._chipFocusSubscription = this.chipFocusChanges.subscribe(t => { let e = this.chips.toArray().indexOf(t.chip);
                    this._isValidIndex(e) && this._keyManager.updateActiveItem(e), this.stateChanges.next() }), this._chipBlurSubscription = this.chipBlurChanges.subscribe(() => { this._blur(), this.stateChanges.next() }) } _listenToChipsRemoved() { this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(t => { const e = t.chip,
                        i = this.chips.toArray().indexOf(t.chip);
                    this._isValidIndex(i) && e._hasFocus && (this._lastDestroyedChipIndex = i) }) } _originatesFromChip(t) { let e = t.target; for (; e && e !== this._elementRef.nativeElement;) { if (e.classList.contains("mat-chip")) return !0;
                    e = e.parentElement } return !1 } _hasFocusedChip() { return this.chips.some(t => t._hasFocus) } _syncChipsState() { this.chips && this.chips.forEach(t => { t.disabled = this._disabled, t._chipListMultiple = this.multiple }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(jr), Sa(Rw, 8), Sa(R_, 8), Sa(W_, 8), Sa(LS), Sa(Tg, 10)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-chip-list"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && sc(i, zF, !0), 2 & t && tc(n = oc()) && (e.chips = n) }, hostAttrs: [1, "mat-chip-list"], hostVars: 15, hostBindings: function(t, e) { 1 & t && Ba("focus", (function() { return e.focus() }))("blur", (function() { return e._blur() }))("keydown", (function(t) { return e._keydown(t) })), 2 & t && (xo("id", e._uid), va("tabindex", e.disabled ? null : e._tabIndex)("aria-describedby", e._ariaDescribedby || null)("aria-required", e.role ? e.required : null)("aria-disabled", e.disabled.toString())("aria-invalid", e.errorState)("aria-multiselectable", e.multiple)("role", e.role)("aria-orientation", e.ariaOrientation), no("mat-chip-list-disabled", e.disabled)("mat-chip-list-invalid", e.errorState)("mat-chip-list-required", e.required)) }, inputs: { ariaOrientation: ["aria-orientation", "ariaOrientation"], multiple: "multiple", compareWith: "compareWith", value: "value", required: "required", placeholder: "placeholder", disabled: "disabled", selectable: "selectable", tabIndex: "tabIndex", errorStateMatcher: "errorStateMatcher" }, outputs: { change: "change", valueChange: "valueChange" }, exportAs: ["matChipList"], features: [Ho([{ provide: _E, useExisting: t }]), Eo], ngContentSelectors: FF, decls: 2, vars: 0, consts: [
                [1, "mat-chip-list-wrapper"]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "div", 0), Wa(1), Ta()) }, styles: ['.mat-chip{position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0);border:none;-webkit-appearance:none;-moz-appearance:none}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:"";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}.cdk-high-contrast-active .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-standard-chip:focus{outline:dotted 2px}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit;overflow:hidden}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\n'], encapsulation: 2, changeDetection: 0 }), t })(), YF = 0, XF = (() => { class t { constructor(t, e) { this._elementRef = t, this._defaultOptions = e, this.focused = !1, this._addOnBlur = !1, this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes, this.chipEnd = new jl, this.placeholder = "", this.id = `mat-chip-list-input-${YF++}`, this._disabled = !1, this._inputElement = this._elementRef.nativeElement } set chipList(t) { t && (this._chipList = t, this._chipList.registerInput(this)) } get addOnBlur() { return this._addOnBlur } set addOnBlur(t) { this._addOnBlur = Vv(t) } get disabled() { return this._disabled || this._chipList && this._chipList.disabled } set disabled(t) { this._disabled = Vv(t) } get empty() { return !this._inputElement.value } ngOnChanges() { this._chipList.stateChanges.next() } _keydown(t) { t && 9 === t.keyCode && !Iv(t, "shiftKey") && this._chipList._allowFocusEscape(), this._emitChipEnd(t) } _blur() { this.addOnBlur && this._emitChipEnd(), this.focused = !1, this._chipList.focused || this._chipList._blur(), this._chipList.stateChanges.next() } _focus() { this.focused = !0, this._chipList.stateChanges.next() } _emitChipEnd(t) {!this._inputElement.value && t && this._chipList._keydown(t), t && !this._isSeparatorKey(t) || (this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value }), t && t.preventDefault()) } _onInput() { this._chipList.stateChanges.next() } focus(t) { this._inputElement.focus(t) } _isSeparatorKey(t) { if (Iv(t)) return !1; const e = this.separatorKeyCodes,
                    i = t.keyCode; return Array.isArray(e) ? e.indexOf(i) > -1 : e.has(i) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(HF)) }, t.\u0275dir = we({ type: t, selectors: [
                ["input", "matChipInputFor", ""]
            ], hostAttrs: [1, "mat-chip-input", "mat-input-element"], hostVars: 5, hostBindings: function(t, e) { 1 & t && Ba("keydown", (function(t) { return e._keydown(t) }))("blur", (function() { return e._blur() }))("focus", (function() { return e._focus() }))("input", (function() { return e._onInput() })), 2 & t && (xo("id", e.id), va("disabled", e.disabled || null)("placeholder", e.placeholder || null)("aria-invalid", e._chipList && e._chipList.ngControl ? e._chipList.ngControl.invalid : null)("aria-required", e._chipList && e._chipList.required || null)) }, inputs: { separatorKeyCodes: ["matChipInputSeparatorKeyCodes", "separatorKeyCodes"], placeholder: "placeholder", id: "id", chipList: ["matChipInputFor", "chipList"], addOnBlur: ["matChipInputAddOnBlur", "addOnBlur"], disabled: "disabled" }, outputs: { chipEnd: "matChipInputTokenEnd" }, exportAs: ["matChipInput", "matChipInputFor"], features: [Ro] }), t })();
    const KF = { separatorKeyCodes: [13] };
    let ZF = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [LS, { provide: HF, useValue: KF }] }), t })();

    function QF(t, e) { if (1 & t && (Ci(), Oa(0, "circle", 3)), 2 & t) { const t = ja();
            io("animation-name", "mat-progress-spinner-stroke-rotate-" + t.diameter)("stroke-dashoffset", t._strokeDashOffset, "px")("stroke-dasharray", t._strokeCircumference, "px")("stroke-width", t._circleStrokeWidth, "%"), va("r", t._circleRadius) } }

    function JF(t, e) { if (1 & t && (Ci(), Oa(0, "circle", 3)), 2 & t) { const t = ja();
            io("stroke-dashoffset", t._strokeDashOffset, "px")("stroke-dasharray", t._strokeCircumference, "px")("stroke-width", t._circleStrokeWidth, "%"), va("r", t._circleRadius) } }

    function tN(t, e) { if (1 & t && (Ci(), Oa(0, "circle", 3)), 2 & t) { const t = ja();
            io("animation-name", "mat-progress-spinner-stroke-rotate-" + t.diameter)("stroke-dashoffset", t._strokeDashOffset, "px")("stroke-dasharray", t._strokeCircumference, "px")("stroke-width", t._circleStrokeWidth, "%"), va("r", t._circleRadius) } }

    function eN(t, e) { if (1 & t && (Ci(), Oa(0, "circle", 3)), 2 & t) { const t = ja();
            io("stroke-dashoffset", t._strokeDashOffset, "px")("stroke-dasharray", t._strokeCircumference, "px")("stroke-width", t._circleStrokeWidth, "%"), va("r", t._circleRadius) } } class iN { constructor(t) { this._elementRef = t } }
    const nN = yS(iN, "primary"), sN = new Vt("mat-progress-spinner-default-options", { providedIn: "root", factory: function() { return { diameter: 100 } } });
    let rN = (() => { class t extends nN { constructor(e, i, n, s, r) { super(e), this._elementRef = e, this._document = n, this._diameter = 100, this._value = 0, this._fallbackAnimation = !1, this.mode = "determinate"; const a = t._diameters;
                a.has(n.head) || a.set(n.head, new Set([100])), this._fallbackAnimation = i.EDGE || i.TRIDENT, this._noopAnimations = "NoopAnimations" === s && !!r && !r._forceAnimations, r && (r.diameter && (this.diameter = r.diameter), r.strokeWidth && (this.strokeWidth = r.strokeWidth)) } get diameter() { return this._diameter } set diameter(t) { this._diameter = zv(t), !this._fallbackAnimation && this._styleRoot && this._attachStyleNode() } get strokeWidth() { return this._strokeWidth || this.diameter / 10 } set strokeWidth(t) { this._strokeWidth = zv(t) } get value() { return "determinate" === this.mode ? this._value : 0 } set value(t) { this._value = Math.max(0, Math.min(100, zv(t))) } ngOnInit() { const t = this._elementRef.nativeElement;
                this._styleRoot = ew(t) || this._document.head, this._attachStyleNode(), t.classList.add(`mat-progress-spinner-indeterminate${this._fallbackAnimation?"-fallback":""}-animation`) } get _circleRadius() { return (this.diameter - 10) / 2 } get _viewBox() { const t = 2 * this._circleRadius + this.strokeWidth; return `0 0 ${t} ${t}` } get _strokeCircumference() { return 2 * Math.PI * this._circleRadius } get _strokeDashOffset() { return "determinate" === this.mode ? this._strokeCircumference * (100 - this._value) / 100 : this._fallbackAnimation && "indeterminate" === this.mode ? .2 * this._strokeCircumference : null } get _circleStrokeWidth() { return this.strokeWidth / this.diameter * 100 } _attachStyleNode() { const e = this._styleRoot,
                    i = this._diameter,
                    n = t._diameters; let s = n.get(e); if (!s || !s.has(i)) { const t = this._document.createElement("style");
                    t.setAttribute("mat-spinner-animation", i + ""), t.textContent = this._getAnimationText(), e.appendChild(t), s || (s = new Set, n.set(e, s)), s.add(i) } } _getAnimationText() { return "\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n".replace(/START_VALUE/g, `${.95*this._strokeCircumference}`).replace(/END_VALUE/g, `${.2*this._strokeCircumference}`).replace(/DIAMETER/g, `${this.diameter}`) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Wv), Sa(uh, 8), Sa(aS, 8), Sa(sN)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-progress-spinner"]
            ], hostAttrs: ["role", "progressbar", 1, "mat-progress-spinner"], hostVars: 10, hostBindings: function(t, e) { 2 & t && (va("aria-valuemin", "determinate" === e.mode ? 0 : null)("aria-valuemax", "determinate" === e.mode ? 100 : null)("aria-valuenow", "determinate" === e.mode ? e.value : null)("mode", e.mode), io("width", e.diameter, "px")("height", e.diameter, "px"), no("_mat-animation-noopable", e._noopAnimations)) }, inputs: { color: "color", mode: "mode", diameter: "diameter", strokeWidth: "strokeWidth", value: "value" }, exportAs: ["matProgressSpinner"], features: [Eo], decls: 3, vars: 8, consts: [
                ["preserveAspectRatio", "xMidYMid meet", "focusable", "false", 3, "ngSwitch"],
                ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"],
                ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"],
                ["cx", "50%", "cy", "50%"]
            ], template: function(t, e) { 1 & t && (Ci(), Ia(0, "svg", 0), Ca(1, QF, 1, 9, "circle", 1), Ca(2, JF, 1, 7, "circle", 2), Ta()), 2 & t && (io("width", e.diameter, "px")("height", e.diameter, "px"), Da("ngSwitch", "indeterminate" === e.mode), va("viewBox", e._viewBox), ps(1), Da("ngSwitchCase", !0), ps(1), Da("ngSwitchCase", !1)) }, directives: [xd, Sd], styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"], encapsulation: 2, changeDetection: 0 }), t._diameters = new WeakMap, t })(), aN = (() => { class t extends rN { constructor(t, e, i, n, s) { super(t, e, i, n, s), this.mode = "indeterminate" } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Wv), Sa(uh, 8), Sa(aS, 8), Sa(sN)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-spinner"]
            ], hostAttrs: ["role", "progressbar", "mode", "indeterminate", 1, "mat-spinner", "mat-progress-spinner"], hostVars: 6, hostBindings: function(t, e) { 2 & t && (io("width", e.diameter, "px")("height", e.diameter, "px"), no("_mat-animation-noopable", e._noopAnimations)) }, inputs: { color: "color" }, features: [Eo], decls: 3, vars: 8, consts: [
                ["preserveAspectRatio", "xMidYMid meet", "focusable", "false", 3, "ngSwitch"],
                ["cx", "50%", "cy", "50%", 3, "animation-name", "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"],
                ["cx", "50%", "cy", "50%", 3, "stroke-dashoffset", "stroke-dasharray", "stroke-width", 4, "ngSwitchCase"],
                ["cx", "50%", "cy", "50%"]
            ], template: function(t, e) { 1 & t && (Ci(), Ia(0, "svg", 0), Ca(1, tN, 1, 9, "circle", 1), Ca(2, eN, 1, 7, "circle", 2), Ta()), 2 & t && (io("width", e.diameter, "px")("height", e.diameter, "px"), Da("ngSwitch", "indeterminate" === e.mode), va("viewBox", e._viewBox), ps(1), Da("ngSwitchCase", !0), ps(1), Da("ngSwitchCase", !1)) }, directives: [xd, Sd], styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n"], encapsulation: 2, changeDetection: 0 }), t })(), oN = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [_S, Jd], _S
            ] }), t })();
    const lN = ["primaryValueBar"]; class cN { constructor(t) { this._elementRef = t } }
    const hN = yS(cN, "primary"), dN = new Vt("mat-progress-bar-location", { providedIn: "root", factory: function() { const t = Kt(uh),
                e = t ? t.location : null; return { getPathname: () => e ? e.pathname + e.search : "" } } });
    let uN = 0, mN = (() => { class t extends hN { constructor(t, e, i, n) { super(t), this._elementRef = t, this._ngZone = e, this._animationMode = i, this._isNoopAnimation = !1, this._value = 0, this._bufferValue = 0, this.animationEnd = new jl, this._animationEndSubscription = d.EMPTY, this.mode = "determinate", this.progressbarId = `mat-progress-bar-${uN++}`; const s = n ? n.getPathname().split("#")[0] : "";
                this._rectangleFillValue = `url('${s}#${this.progressbarId}')`, this._isNoopAnimation = "NoopAnimations" === i } get value() { return this._value } set value(t) { this._value = pN(zv(t) || 0) } get bufferValue() { return this._bufferValue } set bufferValue(t) { this._bufferValue = pN(t || 0) } _primaryTransform() { return { transform: `scaleX(${this.value/100})` } } _bufferTransform() { return "buffer" === this.mode ? { transform: `scaleX(${this.bufferValue/100})` } : null } ngAfterViewInit() { this._ngZone.runOutsideAngular(() => { const t = this._primaryValueBar.nativeElement;
                    this._animationEndSubscription = Nk(t, "transitionend").pipe(Gu(e => e.target === t)).subscribe(() => { "determinate" !== this.mode && "buffer" !== this.mode || this._ngZone.run(() => this.animationEnd.next({ value: this.value })) }) }) } ngOnDestroy() { this._animationEndSubscription.unsubscribe() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Pc), Sa(aS, 8), Sa(dN, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-progress-bar"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ic(lN, !0), 2 & t && tc(i = oc()) && (e._primaryValueBar = i.first) }, hostAttrs: ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", 1, "mat-progress-bar"], hostVars: 4, hostBindings: function(t, e) { 2 & t && (va("aria-valuenow", "indeterminate" === e.mode || "query" === e.mode ? null : e.value)("mode", e.mode), no("_mat-animation-noopable", e._isNoopAnimation)) }, inputs: { color: "color", mode: "mode", value: "value", bufferValue: "bufferValue" }, outputs: { animationEnd: "animationEnd" }, exportAs: ["matProgressBar"], features: [Eo], decls: 9, vars: 4, consts: [
                ["width", "100%", "height", "4", "focusable", "false", 1, "mat-progress-bar-background", "mat-progress-bar-element"],
                ["x", "4", "y", "0", "width", "8", "height", "4", "patternUnits", "userSpaceOnUse", 3, "id"],
                ["cx", "2", "cy", "2", "r", "2"],
                ["width", "100%", "height", "100%"],
                [1, "mat-progress-bar-buffer", "mat-progress-bar-element", 3, "ngStyle"],
                [1, "mat-progress-bar-primary", "mat-progress-bar-fill", "mat-progress-bar-element", 3, "ngStyle"],
                ["primaryValueBar", ""],
                [1, "mat-progress-bar-secondary", "mat-progress-bar-fill", "mat-progress-bar-element"]
            ], template: function(t, e) { 1 & t && (Ci(), Ia(0, "svg", 0), Ia(1, "defs"), Ia(2, "pattern", 1), Oa(3, "circle", 2), Ta(), Ta(), Oa(4, "rect", 3), Ta(), xi(), Oa(5, "div", 4), Oa(6, "div", 5, 6), Oa(8, "div", 7)), 2 & t && (ps(2), Da("id", e.progressbarId), ps(2), va("fill", e._rectangleFillValue), ps(1), Da("ngStyle", e._bufferTransform()), ps(1), Da("ngStyle", e._primaryTransform())) }, directives: [Ad], styles: ['.mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-background{display:none}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}.cdk-high-contrast-active .mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:"";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition-duration:1ms}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\n'], encapsulation: 2, changeDetection: 0 }), t })();

    function pN(t, e = 0, i = 100) { return Math.max(e, Math.min(i, t)) }
    let fN = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [Jd, _S], _S
            ] }), t })(); class gN { constructor(t) { this.total = t } call(t, e) { return e.subscribe(new _N(t, this.total)) } } class _N extends p { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) {++this.count > this.total && this.destination.next(t) } }
    const bN = new Set;
    let yN, vN = (() => { class t { constructor(t) { this._platform = t, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : wN } matchMedia(t) { return this._platform.WEBKIT && function(t) { if (!bN.has(t)) try { yN || (yN = document.createElement("style"), yN.setAttribute("type", "text/css"), document.head.appendChild(yN)), yN.sheet && (yN.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`, 0), bN.add(t)) } catch (L$) { console.error(L$) } }(t), this._matchMedia(t) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Wv)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(Wv)) }, token: t, providedIn: "root" }), t })();

    function wN(t) { return { matches: "all" === t || "" === t, media: t, addListener: () => {}, removeListener: () => {} } }
    let CN = (() => { class t { constructor(t, e) { this._mediaMatcher = t, this._zone = e, this._queries = new Map, this._destroySubject = new k } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(t) { return xN(Uv(t)).some(t => this._registerQuery(t).mql.matches) } observe(t) { let e = Lu(xN(Uv(t)).map(t => this._registerQuery(t).observable)); return e = _m(e.pipe(lm(1)), e.pipe(t => t.lift(new gN(1)), Fv(0))), e.pipe(L(t => { const e = { matches: !1, breakpoints: {} }; return t.forEach(t => { e.matches = e.matches || t.matches, e.breakpoints[t.query] = t.matches }), e })) } _registerQuery(t) { if (this._queries.has(t)) return this._queries.get(t); const e = this._mediaMatcher.matchMedia(t),
                    i = { observable: new v(t => { const i = e => this._zone.run(() => t.next(e)); return e.addListener(i), () => { e.removeListener(i) } }).pipe(bm(e), L(e => ({ query: t, matches: e.matches })), jk(this._destroySubject)), mql: e }; return this._queries.set(t, i), i } } return t.\u0275fac = function(e) { return new(e || t)(Xt(vN), Xt(Pc)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(vN), Xt(Pc)) }, token: t, providedIn: "root" }), t })();

    function xN(t) { return t.map(t => t.split(",")).reduce((t, e) => t.concat(e)).map(t => t.trim()) }
    const SN = { tooltipState: Lw("state", [Hw("initial, void, hidden", Uw({ opacity: 0, transform: "scale(0)" })), Hw("visible", Uw({ transform: "scale(1)" })), Gw("* => visible", Bw("200ms cubic-bezier(0, 0, 0.2, 1)", jw([Uw({ opacity: 0, transform: "scale(0)", offset: 0 }), Uw({ opacity: .5, transform: "scale(0.99)", offset: .5 }), Uw({ opacity: 1, transform: "scale(1)", offset: 1 })]))), Gw("* => hidden", Bw("100ms cubic-bezier(0, 0, 0.2, 1)", Uw({ opacity: 0 })))]) }, kN = Jv({ passive: !0 });

    function EN(t) { return Error(`Tooltip position "${t}" is invalid.`) }
    const DN = new Vt("mat-tooltip-scroll-strategy"), AN = { provide: DN, deps: [JD], useFactory: function(t) { return () => t.scrollStrategies.reposition({ scrollThrottle: 20 }) } }, IN = new Vt("mat-tooltip-default-options", { providedIn: "root", factory: function() { return { showDelay: 0, hideDelay: 0, touchendHideDelay: 1500 } } });
    let TN = (() => { class t { constructor(t, e, i, n, s, r, a, o, l, c, h, d) { this._overlay = t, this._elementRef = e, this._scrollDispatcher = i, this._viewContainerRef = n, this._ngZone = s, this._platform = r, this._ariaDescriber = a, this._focusMonitor = o, this._dir = c, this._defaultOptions = h, this._position = "below", this._disabled = !1, this.showDelay = this._defaultOptions.showDelay, this.hideDelay = this._defaultOptions.hideDelay, this.touchGestures = "auto", this._message = "", this._passiveListeners = new Map, this._destroyed = new k, this._handleKeydown = t => { this._isTooltipVisible() && 27 === t.keyCode && !Iv(t) && (t.preventDefault(), t.stopPropagation(), this._ngZone.run(() => this.hide(0))) }, this._scrollStrategy = l, h && (h.position && (this.position = h.position), h.touchGestures && (this.touchGestures = h.touchGestures)), o.monitor(e).pipe(jk(this._destroyed)).subscribe(t => { t ? "keyboard" === t && s.run(() => this.show()) : s.run(() => this.hide(0)) }), s.runOutsideAngular(() => { e.nativeElement.addEventListener("keydown", this._handleKeydown) }) } get position() { return this._position } set position(t) { t !== this._position && (this._position = t, this._overlayRef && (this._updatePosition(), this._tooltipInstance && this._tooltipInstance.show(0), this._overlayRef.updatePosition())) } get disabled() { return this._disabled } set disabled(t) { this._disabled = Vv(t), this._disabled && this.hide(0) } get message() { return this._message } set message(t) { this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message), this._message = null != t ? `${t}`.trim() : "", !this._message && this._isTooltipVisible() ? this.hide(0) : (this._updateTooltipMessage(), this._ngZone.runOutsideAngular(() => { Promise.resolve().then(() => { this._ariaDescriber.describe(this._elementRef.nativeElement, this.message) }) })) } get tooltipClass() { return this._tooltipClass } set tooltipClass(t) { this._tooltipClass = t, this._tooltipInstance && this._setTooltipClass(this._tooltipClass) } ngOnInit() { this._setupPointerEvents() } ngOnDestroy() { const t = this._elementRef.nativeElement;
                clearTimeout(this._touchstartTimeout), this._overlayRef && (this._overlayRef.dispose(), this._tooltipInstance = null), t.removeEventListener("keydown", this._handleKeydown), this._passiveListeners.forEach((e, i) => { t.removeEventListener(i, e, kN) }), this._passiveListeners.clear(), this._destroyed.next(), this._destroyed.complete(), this._ariaDescriber.removeDescription(t, this.message), this._focusMonitor.stopMonitoring(t) } show(t = this.showDelay) { if (this.disabled || !this.message || this._isTooltipVisible() && !this._tooltipInstance._showTimeoutId && !this._tooltipInstance._hideTimeoutId) return; const e = this._createOverlay();
                this._detach(), this._portal = this._portal || new _D(ON, this._viewContainerRef), this._tooltipInstance = e.attach(this._portal).instance, this._tooltipInstance.afterHidden().pipe(jk(this._destroyed)).subscribe(() => this._detach()), this._setTooltipClass(this._tooltipClass), this._updateTooltipMessage(), this._tooltipInstance.show(t) } hide(t = this.hideDelay) { this._tooltipInstance && this._tooltipInstance.hide(t) } toggle() { this._isTooltipVisible() ? this.hide() : this.show() } _isTooltipVisible() { return !!this._tooltipInstance && this._tooltipInstance.isVisible() } _createOverlay() { if (this._overlayRef) return this._overlayRef; const t = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef),
                    e = this._overlay.position().flexibleConnectedTo(this._elementRef).withTransformOriginOn(".mat-tooltip").withFlexibleDimensions(!1).withViewportMargin(8).withScrollableContainers(t); return e.positionChanges.pipe(jk(this._destroyed)).subscribe(t => { this._tooltipInstance && t.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible() && this._ngZone.run(() => this.hide(0)) }), this._overlayRef = this._overlay.create({ direction: this._dir, positionStrategy: e, panelClass: "mat-tooltip-panel", scrollStrategy: this._scrollStrategy() }), this._updatePosition(), this._overlayRef.detachments().pipe(jk(this._destroyed)).subscribe(() => this._detach()), this._overlayRef } _detach() { this._overlayRef && this._overlayRef.hasAttached() && this._overlayRef.detach(), this._tooltipInstance = null } _updatePosition() { const t = this._overlayRef.getConfig().positionStrategy,
                    e = this._getOrigin(),
                    i = this._getOverlayPosition();
                t.withPositions([Object.assign(Object.assign({}, e.main), i.main), Object.assign(Object.assign({}, e.fallback), i.fallback)]) } _getOrigin() { const t = !this._dir || "ltr" == this._dir.value,
                    e = this.position; let i; if ("above" == e || "below" == e) i = { originX: "center", originY: "above" == e ? "top" : "bottom" };
                else if ("before" == e || "left" == e && t || "right" == e && !t) i = { originX: "start", originY: "center" };
                else { if (!("after" == e || "right" == e && t || "left" == e && !t)) throw EN(e);
                    i = { originX: "end", originY: "center" } } const { x: n, y: s } = this._invertPosition(i.originX, i.originY); return { main: i, fallback: { originX: n, originY: s } } } _getOverlayPosition() { const t = !this._dir || "ltr" == this._dir.value,
                    e = this.position; let i; if ("above" == e) i = { overlayX: "center", overlayY: "bottom" };
                else if ("below" == e) i = { overlayX: "center", overlayY: "top" };
                else if ("before" == e || "left" == e && t || "right" == e && !t) i = { overlayX: "end", overlayY: "center" };
                else { if (!("after" == e || "right" == e && t || "left" == e && !t)) throw EN(e);
                    i = { overlayX: "start", overlayY: "center" } } const { x: n, y: s } = this._invertPosition(i.overlayX, i.overlayY); return { main: i, fallback: { overlayX: n, overlayY: s } } } _updateTooltipMessage() { this._tooltipInstance && (this._tooltipInstance.message = this.message, this._tooltipInstance._markForCheck(), this._ngZone.onMicrotaskEmpty.asObservable().pipe(lm(1), jk(this._destroyed)).subscribe(() => { this._tooltipInstance && this._overlayRef.updatePosition() })) } _setTooltipClass(t) { this._tooltipInstance && (this._tooltipInstance.tooltipClass = t, this._tooltipInstance._markForCheck()) } _invertPosition(t, e) { return "above" === this.position || "below" === this.position ? "top" === e ? e = "bottom" : "bottom" === e && (e = "top") : "end" === t ? t = "start" : "start" === t && (t = "end"), { x: t, y: e } } _setupPointerEvents() { if (this._platform.IOS || this._platform.ANDROID) { if ("off" !== this.touchGestures) { this._disableNativeGesturesIfNecessary(); const t = () => { clearTimeout(this._touchstartTimeout), this.hide(this._defaultOptions.touchendHideDelay) };
                        this._passiveListeners.set("touchend", t).set("touchcancel", t).set("touchstart", () => { clearTimeout(this._touchstartTimeout), this._touchstartTimeout = setTimeout(() => this.show(), 500) }) } } else this._passiveListeners.set("mouseenter", () => this.show()).set("mouseleave", () => this.hide());
                this._passiveListeners.forEach((t, e) => { this._elementRef.nativeElement.addEventListener(e, t, kN) }) } _disableNativeGesturesIfNecessary() { const t = this._elementRef.nativeElement,
                    e = t.style,
                    i = this.touchGestures; "off" !== i && (("on" === i || "INPUT" !== t.nodeName && "TEXTAREA" !== t.nodeName) && (e.userSelect = e.msUserSelect = e.webkitUserSelect = e.MozUserSelect = "none"), "on" !== i && t.draggable || (e.webkitUserDrag = "none"), e.touchAction = "none", e.webkitTapHighlightColor = "transparent") } } return t.\u0275fac = function(e) { return new(e || t)(Sa(JD), Sa(Wo), Sa(dD), Sa(bl), Sa(Pc), Sa(Wv), Sa(hw), Sa(Ew), Sa(DN), Sa(Rw, 8), Sa(IN, 8), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matTooltip", ""]
            ], inputs: { showDelay: ["matTooltipShowDelay", "showDelay"], hideDelay: ["matTooltipHideDelay", "hideDelay"], touchGestures: ["matTooltipTouchGestures", "touchGestures"], position: ["matTooltipPosition", "position"], disabled: ["matTooltipDisabled", "disabled"], message: ["matTooltip", "message"], tooltipClass: ["matTooltipClass", "tooltipClass"] }, exportAs: ["matTooltip"] }), t })(), ON = (() => { class t { constructor(t, e) { this._changeDetectorRef = t, this._breakpointObserver = e, this._visibility = "initial", this._closeOnInteraction = !1, this._onHide = new k, this._isHandset = this._breakpointObserver.observe("(max-width: 599.99px) and (orientation: portrait), (max-width: 959.99px) and (orientation: landscape)") } show(t) { this._hideTimeoutId && (clearTimeout(this._hideTimeoutId), this._hideTimeoutId = null), this._closeOnInteraction = !0, this._showTimeoutId = setTimeout(() => { this._visibility = "visible", this._showTimeoutId = null, this._markForCheck() }, t) } hide(t) { this._showTimeoutId && (clearTimeout(this._showTimeoutId), this._showTimeoutId = null), this._hideTimeoutId = setTimeout(() => { this._visibility = "hidden", this._hideTimeoutId = null, this._markForCheck() }, t) } afterHidden() { return this._onHide.asObservable() } isVisible() { return "visible" === this._visibility } ngOnDestroy() { this._onHide.complete() } _animationStart() { this._closeOnInteraction = !1 } _animationDone(t) { const e = t.toState; "hidden" !== e || this.isVisible() || this._onHide.next(), "visible" !== e && "hidden" !== e || (this._closeOnInteraction = !0) } _handleBodyInteraction() { this._closeOnInteraction && this.hide(0) } _markForCheck() { this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(jr), Sa(CN)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-tooltip-component"]
            ], hostAttrs: ["aria-hidden", "true"], hostVars: 2, hostBindings: function(t, e) { 1 & t && Ba("click", (function() { return e._handleBodyInteraction() }), !1, ji), 2 & t && io("zoom", "visible" === e._visibility ? 1 : null) }, decls: 3, vars: 7, consts: [
                [1, "mat-tooltip", 3, "ngClass"]
            ], template: function(t, e) { var i;
                1 & t && (Ia(0, "div", 0), Ba("@state.start", (function() { return e._animationStart() }))("@state.done", (function(t) { return e._animationDone(t) })), Ul(1, "async"), _o(2), Ta()), 2 & t && (no("mat-tooltip-handset", null == (i = Hl(1, 5, e._isHandset)) ? null : i.matches), Da("ngClass", e.tooltipClass)("@state", e._visibility), ps(2), bo(e.message)) }, directives: [pd], pipes: [Fd], styles: [".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"], encapsulation: 2, data: { animation: [SN.tooltipState] }, changeDetection: 0 }), t })(), RN = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [AN], imports: [
                [Tw, Jd, rA, _S], _S
            ] }), t })();

    function MN(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 1), Ia(1, "button", 2), Ba("click", (function() { return Qe(t), ja().action() })), _o(2), Ta(), Ta() } if (2 & t) { const t = ja();
            ps(2), bo(t.data.action) } }

    function PN(t, e) {}
    const FN = Math.pow(2, 31) - 1; class NN { constructor(t, e) { this._overlayRef = e, this._afterDismissed = new k, this._afterOpened = new k, this._onAction = new k, this._dismissedByAction = !1, this.containerInstance = t, this.onAction().subscribe(() => this.dismiss()), t._onExit.subscribe(() => this._finishDismiss()) } dismiss() { this._afterDismissed.closed || this.containerInstance.exit(), clearTimeout(this._durationTimeoutId) } dismissWithAction() { this._onAction.closed || (this._dismissedByAction = !0, this._onAction.next(), this._onAction.complete()) } closeWithAction() { this.dismissWithAction() } _dismissAfter(t) { this._durationTimeoutId = setTimeout(() => this.dismiss(), Math.min(t, FN)) } _open() { this._afterOpened.closed || (this._afterOpened.next(), this._afterOpened.complete()) } _finishDismiss() { this._overlayRef.dispose(), this._onAction.closed || this._onAction.complete(), this._afterDismissed.next({ dismissedByAction: this._dismissedByAction }), this._afterDismissed.complete(), this._dismissedByAction = !1 } afterDismissed() { return this._afterDismissed.asObservable() } afterOpened() { return this.containerInstance._onEnter } onAction() { return this._onAction.asObservable() } }
    const LN = new Vt("MatSnackBarData"); class BN { constructor() { this.politeness = "assertive", this.announcementMessage = "", this.duration = 0, this.data = null, this.horizontalPosition = "center", this.verticalPosition = "bottom" } }
    let VN = (() => { class t { constructor(t, e) { this.snackBarRef = t, this.data = e } action() { this.snackBarRef.dismissWithAction() } get hasAction() { return !!this.data.action } } return t.\u0275fac = function(e) { return new(e || t)(Sa(NN), Sa(LN)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["simple-snack-bar"]
            ], hostAttrs: [1, "mat-simple-snackbar"], decls: 3, vars: 2, consts: [
                ["class", "mat-simple-snackbar-action", 4, "ngIf"],
                [1, "mat-simple-snackbar-action"],
                ["mat-button", "", 3, "click"]
            ], template: function(t, e) { 1 & t && (Ia(0, "span"), _o(1), Ta(), Ca(2, MN, 3, 1, "div", 0)), 2 & t && (ps(1), bo(e.data.message), ps(1), Da("ngIf", e.hasAction)) }, directives: [yd, fk], styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}\n"], encapsulation: 2, changeDetection: 0 }), t })();
    const zN = { snackBarState: Lw("state", [Hw("void, hidden", Uw({ transform: "scale(0.8)", opacity: 0 })), Hw("visible", Uw({ transform: "scale(1)", opacity: 1 })), Gw("* => visible", Bw("150ms cubic-bezier(0, 0, 0.2, 1)")), Gw("* => void, * => hidden", Bw("75ms cubic-bezier(0.4, 0.0, 1, 1)", Uw({ opacity: 0 })))]) };
    let UN = (() => { class t extends vD { constructor(t, e, i, n) { super(), this._ngZone = t, this._elementRef = e, this._changeDetectorRef = i, this.snackBarConfig = n, this._destroyed = !1, this._onExit = new k, this._onEnter = new k, this._animationState = "void", this.attachDomPortal = t => (this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachDomPortal(t)), this._role = "assertive" !== n.politeness || n.announcementMessage ? "off" === n.politeness ? null : "status" : "alert" } attachComponentPortal(t) { return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachComponentPortal(t) } attachTemplatePortal(t) { return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachTemplatePortal(t) } onAnimationEnd(t) { const { fromState: e, toState: i } = t; if (("void" === i && "void" !== e || "hidden" === i) && this._completeExit(), "visible" === i) { const t = this._onEnter;
                    this._ngZone.run(() => { t.next(), t.complete() }) } } enter() { this._destroyed || (this._animationState = "visible", this._changeDetectorRef.detectChanges()) } exit() { return this._animationState = "hidden", this._elementRef.nativeElement.setAttribute("mat-exit", ""), this._onExit } ngOnDestroy() { this._destroyed = !0, this._completeExit() } _completeExit() { this._ngZone.onMicrotaskEmpty.asObservable().pipe(lm(1)).subscribe(() => { this._onExit.next(), this._onExit.complete() }) } _applySnackBarClasses() { const t = this._elementRef.nativeElement,
                    e = this.snackBarConfig.panelClass;
                e && (Array.isArray(e) ? e.forEach(e => t.classList.add(e)) : t.classList.add(e)), "center" === this.snackBarConfig.horizontalPosition && t.classList.add("mat-snack-bar-center"), "top" === this.snackBarConfig.verticalPosition && t.classList.add("mat-snack-bar-top") } _assertNotAttached() { if (this._portalOutlet.hasAttached()) throw Error("Attempting to attach snack bar content after content is already attached") } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Pc), Sa(Wo), Sa(jr), Sa(BN)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["snack-bar-container"]
            ], viewQuery: function(t, e) { var i;
                1 & t && ec(xD, !0), 2 & t && tc(i = oc()) && (e._portalOutlet = i.first) }, hostAttrs: [1, "mat-snack-bar-container"], hostVars: 2, hostBindings: function(t, e) { 1 & t && Va("@state.done", (function(t) { return e.onAnimationEnd(t) })), 2 & t && (va("role", e._role), So("@state", e._animationState)) }, features: [Eo], decls: 1, vars: 0, consts: [
                ["cdkPortalOutlet", ""]
            ], template: function(t, e) { 1 & t && Ca(0, PN, 0, 0, "ng-template", 0) }, directives: [xD], styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"], encapsulation: 2, data: { animation: [zN.snackBarState] } }), t })(), HN = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [rA, ED, Jd, _k, _S], _S
            ] }), t })();
    const jN = new Vt("mat-snack-bar-default-options", { providedIn: "root", factory: function() { return new BN } });
    let GN = (() => { class t { constructor(t, e, i, n, s, r) { this._overlay = t, this._live = e, this._injector = i, this._breakpointObserver = n, this._parentSnackBar = s, this._defaultConfig = r, this._snackBarRefAtThisLevel = null } get _openedSnackBarRef() { const t = this._parentSnackBar; return t ? t._openedSnackBarRef : this._snackBarRefAtThisLevel } set _openedSnackBarRef(t) { this._parentSnackBar ? this._parentSnackBar._openedSnackBarRef = t : this._snackBarRefAtThisLevel = t } openFromComponent(t, e) { return this._attach(t, e) } openFromTemplate(t, e) { return this._attach(t, e) } open(t, e = "", i) { const n = Object.assign(Object.assign({}, this._defaultConfig), i); return n.data = { message: t, action: e }, n.announcementMessage || (n.announcementMessage = t), this.openFromComponent(VN, n) } dismiss() { this._openedSnackBarRef && this._openedSnackBarRef.dismiss() } ngOnDestroy() { this._snackBarRefAtThisLevel && this._snackBarRefAtThisLevel.dismiss() } _attachSnackBarContainer(t, e) { const i = new DD(e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, new WeakMap([
                        [BN, e]
                    ])),
                    n = new _D(UN, e.viewContainerRef, i),
                    s = t.attach(n); return s.instance.snackBarConfig = e, s.instance } _attach(t, e) { const i = Object.assign(Object.assign(Object.assign({}, new BN), this._defaultConfig), e),
                    n = this._createOverlay(i),
                    s = this._attachSnackBarContainer(n, i),
                    r = new NN(s, n); if (t instanceof gl) { const e = new bD(t, null, { $implicit: i.data, snackBarRef: r });
                    r.instance = s.attachTemplatePortal(e) } else { const e = this._createInjector(i, r),
                        n = new _D(t, void 0, e),
                        a = s.attachComponentPortal(n);
                    r.instance = a.instance } return this._breakpointObserver.observe("(max-width: 599.99px) and (orientation: portrait)").pipe(jk(n.detachments())).subscribe(t => { const e = n.overlayElement.classList;
                    t.matches ? e.add("mat-snack-bar-handset") : e.remove("mat-snack-bar-handset") }), this._animateSnackBar(r, i), this._openedSnackBarRef = r, this._openedSnackBarRef } _animateSnackBar(t, e) { t.afterDismissed().subscribe(() => { this._openedSnackBarRef == t && (this._openedSnackBarRef = null), e.announcementMessage && this._live.clear() }), this._openedSnackBarRef ? (this._openedSnackBarRef.afterDismissed().subscribe(() => { t.containerInstance.enter() }), this._openedSnackBarRef.dismiss()) : t.containerInstance.enter(), e.duration && e.duration > 0 && t.afterOpened().subscribe(() => t._dismissAfter(e.duration)), e.announcementMessage && this._live.announce(e.announcementMessage, e.politeness) } _createOverlay(t) { const e = new ND;
                e.direction = t.direction; let i = this._overlay.position().global(); const n = "rtl" === t.direction,
                    s = "left" === t.horizontalPosition || "start" === t.horizontalPosition && !n || "end" === t.horizontalPosition && n,
                    r = !s && "center" !== t.horizontalPosition; return s ? i.left("0") : r ? i.right("0") : i.centerHorizontally(), "top" === t.verticalPosition ? i.top("0") : i.bottom("0"), e.positionStrategy = i, this._overlay.create(e) } _createInjector(t, e) { return new DD(t && t.viewContainerRef && t.viewContainerRef.injector || this._injector, new WeakMap([
                    [NN, e],
                    [LN, t.data]
                ])) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(JD), Xt(Cw), Xt(ra), Xt(CN), Xt(t, 12), Xt(jN)) }, t.\u0275prov = dt({ factory: function() { return new t(Xt(JD), Xt(Cw), Xt(zt), Xt(CN), Xt(t, 12), Xt(jN)) }, token: t, providedIn: HN }), t })();
    const $N = [
        [
            ["caption"]
        ]
    ], WN = ["caption"];

    function qN(t, e) { if (1 & t && (Ia(0, "th", 3), _o(1), Ta()), 2 & t) { const t = ja();
            io("text-align", t.justify), ps(1), yo(" ", t.headerText, " ") } }

    function YN(t, e) { if (1 & t && (Ia(0, "td", 4), _o(1), Ta()), 2 & t) { const t = e.$implicit,
                i = ja();
            io("text-align", i.justify), ps(1), yo(" ", i.dataAccessor(t, i.name), " ") } }

    function XN(t) { return class extends t { constructor(...t) { super(...t), this._sticky = !1, this._hasStickyChanged = !1 } get sticky() { return this._sticky } set sticky(t) { const e = this._sticky;
                this._sticky = Vv(t), this._hasStickyChanged = e !== this._sticky } hasStickyChanged() { const t = this._hasStickyChanged; return this._hasStickyChanged = !1, t } resetStickyChanged() { this._hasStickyChanged = !1 } } }
    const KN = new Vt("CDK_TABLE"), ZN = new Vt("text-column-options");
    let QN = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkCellDef", ""]
            ] }), t })(), JN = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkHeaderCellDef", ""]
            ] }), t })(), tL = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkFooterCellDef", ""]
            ] }), t })(); class eL {}
    const iL = XN(eL);
    let nL = (() => { class t extends iL { constructor(t) { super(), this._table = t, this._stickyEnd = !1 } get name() { return this._name } set name(t) { t && (this._name = t, this.cssClassFriendlyName = t.replace(/[^a-z0-9_-]/gi, "-")) } get stickyEnd() { return this._stickyEnd } set stickyEnd(t) { const e = this._stickyEnd;
                this._stickyEnd = Vv(t), this._hasStickyChanged = e !== this._stickyEnd } } return t.\u0275fac = function(e) { return new(e || t)(Sa(KN, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkColumnDef", ""]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, QN, !0), sc(i, JN, !0), sc(i, tL, !0)), 2 & t && (tc(n = oc()) && (e.cell = n.first), tc(n = oc()) && (e.headerCell = n.first), tc(n = oc()) && (e.footerCell = n.first)) }, inputs: { sticky: "sticky", name: ["cdkColumnDef", "name"], stickyEnd: "stickyEnd" }, features: [Ho([{ provide: "MAT_SORT_HEADER_COLUMN_DEF", useExisting: t }]), Eo] }), t })(); class sL { constructor(t, e) { e.nativeElement.classList.add(`cdk-column-${t.cssClassFriendlyName}`) } }
    let rL = (() => { class t extends sL { constructor(t, e) { super(t, e) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(nL), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["cdk-header-cell"],
                ["th", "cdk-header-cell", ""]
            ], hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"], features: [Eo] }), t })(), aL = (() => { class t extends sL { constructor(t, e) { super(t, e) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(nL), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["cdk-footer-cell"],
                ["td", "cdk-footer-cell", ""]
            ], hostAttrs: ["role", "gridcell", 1, "cdk-footer-cell"], features: [Eo] }), t })(), oL = (() => { class t extends sL { constructor(t, e) { super(t, e) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(nL), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["cdk-cell"],
                ["td", "cdk-cell", ""]
            ], hostAttrs: ["role", "gridcell", 1, "cdk-cell"], features: [Eo] }), t })(), lL = (() => { class t { constructor(t, e) { this.template = t, this._differs = e } ngOnChanges(t) { if (!this._columnsDiffer) { const e = t.columns && t.columns.currentValue || [];
                    this._columnsDiffer = this._differs.find(e).create(), this._columnsDiffer.diff(e) } } getColumnsDiff() { return this._columnsDiffer.diff(this.columns) } extractCellTemplate(t) { return this instanceof dL ? t.headerCell.template : this instanceof pL ? t.footerCell.template : t.cell.template } } return t.\u0275fac = function(t) { Ea() }, t.\u0275dir = we({ type: t, features: [Ro] }), t })(); class cL extends lL {}
    const hL = XN(cL);
    let dL = (() => { class t extends hL { constructor(t, e, i) { super(t, e), this._table = i } ngOnChanges(t) { super.ngOnChanges(t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl), Sa(dl), Sa(KN, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkHeaderRowDef", ""]
            ], inputs: { columns: ["cdkHeaderRowDef", "columns"], sticky: ["cdkHeaderRowDefSticky", "sticky"] }, features: [Eo, Ro] }), t })(); class uL extends lL {}
    const mL = XN(uL);
    let pL = (() => { class t extends mL { constructor(t, e, i) { super(t, e), this._table = i } ngOnChanges(t) { super.ngOnChanges(t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl), Sa(dl), Sa(KN, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkFooterRowDef", ""]
            ], inputs: { columns: ["cdkFooterRowDef", "columns"], sticky: ["cdkFooterRowDefSticky", "sticky"] }, features: [Eo, Ro] }), t })(), fL = (() => { class t extends lL { constructor(t, e, i) { super(t, e), this._table = i } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gl), Sa(dl), Sa(KN, 8)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkRowDef", ""]
            ], inputs: { columns: ["cdkRowDefColumns", "columns"], when: ["cdkRowDefWhen", "when"] }, features: [Eo] }), t })(), gL = (() => { class t { constructor(e) { this._viewContainer = e, t.mostRecentCellOutlet = this } ngOnDestroy() { t.mostRecentCellOutlet === this && (t.mostRecentCellOutlet = null) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "cdkCellOutlet", ""]
            ] }), t.mostRecentCellOutlet = null, t })(), _L = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["cdk-header-row"],
                ["tr", "cdk-header-row", ""]
            ], hostAttrs: ["role", "row", 1, "cdk-header-row"], decls: 1, vars: 0, consts: [
                ["cdkCellOutlet", ""]
            ], template: function(t, e) { 1 & t && Pa(0, 0) }, directives: [gL], encapsulation: 2 }), t })(), bL = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["cdk-footer-row"],
                ["tr", "cdk-footer-row", ""]
            ], hostAttrs: ["role", "row", 1, "cdk-footer-row"], decls: 1, vars: 0, consts: [
                ["cdkCellOutlet", ""]
            ], template: function(t, e) { 1 & t && Pa(0, 0) }, directives: [gL], encapsulation: 2 }), t })(), yL = (() => { class t {} return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["cdk-row"],
                ["tr", "cdk-row", ""]
            ], hostAttrs: ["role", "row", 1, "cdk-row"], decls: 1, vars: 0, consts: [
                ["cdkCellOutlet", ""]
            ], template: function(t, e) { 1 & t && Pa(0, 0) }, directives: [gL], encapsulation: 2 }), t })();
    const vL = ["top", "bottom", "left", "right"]; class wL { constructor(t, e, i, n = !0) { this._isNativeHtmlTable = t, this._stickCellCss = e, this.direction = i, this._isBrowser = n } clearStickyPositioning(t, e) { for (const i of t)
                if (i.nodeType === i.ELEMENT_NODE) { this._removeStickyStyle(i, e); for (let t = 0; t < i.children.length; t++) this._removeStickyStyle(i.children[t], e) } } updateStickyColumns(t, e, i) { const n = e.some(t => t) || i.some(t => t); if (!t.length || !n || !this._isBrowser) return; const s = t[0],
                r = s.children.length,
                a = this._getCellWidths(s),
                o = this._getStickyStartColumnPositions(a, e),
                l = this._getStickyEndColumnPositions(a, i),
                c = "rtl" === this.direction; for (const h of t)
                for (let t = 0; t < r; t++) { const n = h.children[t];
                    e[t] && this._addStickyStyle(n, c ? "right" : "left", o[t]), i[t] && this._addStickyStyle(n, c ? "left" : "right", l[t]) } } stickRows(t, e, i) { if (!this._isBrowser) return; const n = "bottom" === i ? t.reverse() : t; let s = 0; for (let r = 0; r < n.length; r++) { if (!e[r]) continue; const t = n[r]; if (this._isNativeHtmlTable)
                    for (let e = 0; e < t.children.length; e++) this._addStickyStyle(t.children[e], i, s);
                else this._addStickyStyle(t, i, s); if (r === n.length - 1) return;
                s += t.getBoundingClientRect().height } } updateStickyFooterContainer(t, e) { if (!this._isNativeHtmlTable) return; const i = t.querySelector("tfoot");
            e.some(t => !t) ? this._removeStickyStyle(i, ["bottom"]) : this._addStickyStyle(i, "bottom", 0) } _removeStickyStyle(t, e) { for (const i of e) t.style[i] = "";
            t.style.zIndex = this._getCalculatedZIndex(t), vL.some(e => !!t.style[e]) || (t.style.position = "", t.classList.remove(this._stickCellCss)) } _addStickyStyle(t, e, i) { t.classList.add(this._stickCellCss), t.style[e] = `${i}px`, t.style.cssText += "position: -webkit-sticky; position: sticky; ", t.style.zIndex = this._getCalculatedZIndex(t) } _getCalculatedZIndex(t) { const e = { top: 100, bottom: 10, left: 1, right: 1 }; let i = 0; for (const n of vL) t.style[n] && (i += e[n]); return i ? `${i}` : "" } _getCellWidths(t) { const e = [],
                i = t.children; for (let n = 0; n < i.length; n++) e.push(i[n].getBoundingClientRect().width); return e } _getStickyStartColumnPositions(t, e) { const i = []; let n = 0; for (let s = 0; s < t.length; s++) e[s] && (i[s] = n, n += t[s]); return i } _getStickyEndColumnPositions(t, e) { const i = []; let n = 0; for (let s = t.length; s > 0; s--) e[s] && (i[s] = n, n += t[s]); return i } }

    function CL(t) { return Error(`Could not find column with id "${t}".`) }
    let xL = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "rowOutlet", ""]
            ] }), t })(), SL = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "headerRowOutlet", ""]
            ] }), t })(), kL = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function(e) { return new(e || t)(Sa(bl), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "footerRowOutlet", ""]
            ] }), t })(), EL = (() => { class t { constructor(t, e, i, n, s, r, a) { this._differs = t, this._changeDetectorRef = e, this._elementRef = i, this._dir = s, this._platform = a, this._onDestroy = new k, this._columnDefsByName = new Map, this._customColumnDefs = new Set, this._customRowDefs = new Set, this._customHeaderRowDefs = new Set, this._customFooterRowDefs = new Set, this._headerRowDefChanged = !0, this._footerRowDefChanged = !0, this._cachedRenderRowsMap = new Map, this.stickyCssClass = "cdk-table-sticky", this._multiTemplateDataRows = !1, this.viewChange = new Pu({ start: 0, end: Number.MAX_VALUE }), n || this._elementRef.nativeElement.setAttribute("role", "grid"), this._document = r, this._isNativeHtmlTable = "TABLE" === this._elementRef.nativeElement.nodeName } get trackBy() { return this._trackByFn } set trackBy(t) { Sn() && null != t && "function" != typeof t && console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(t)}.`), this._trackByFn = t } get dataSource() { return this._dataSource } set dataSource(t) { this._dataSource !== t && this._switchDataSource(t) } get multiTemplateDataRows() { return this._multiTemplateDataRows } set multiTemplateDataRows(t) { this._multiTemplateDataRows = Vv(t), this._rowOutlet && this._rowOutlet.viewContainer.length && this._forceRenderDataRows() } ngOnInit() { this._setupStickyStyler(), this._isNativeHtmlTable && this._applyNativeTableSections(), this._dataDiffer = this._differs.find([]).create((t, e) => this.trackBy ? this.trackBy(e.dataIndex, e.data) : e) } ngAfterContentChecked() { if (this._cacheRowDefs(), this._cacheColumnDefs(), !this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length) throw Error("Missing definitions for header, footer, and row; cannot determine which columns should be rendered.");
                this._renderUpdatedColumns(), this._headerRowDefChanged && (this._forceRenderHeaderRows(), this._headerRowDefChanged = !1), this._footerRowDefChanged && (this._forceRenderFooterRows(), this._footerRowDefChanged = !1), this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription && this._observeRenderChanges(), this._checkStickyStates() } ngOnDestroy() { this._rowOutlet.viewContainer.clear(), this._headerRowOutlet.viewContainer.clear(), this._footerRowOutlet.viewContainer.clear(), this._cachedRenderRowsMap.clear(), this._onDestroy.next(), this._onDestroy.complete(), lD(this.dataSource) && this.dataSource.disconnect(this) } renderRows() { this._renderRows = this._getAllRenderRows(); const t = this._dataDiffer.diff(this._renderRows); if (!t) return; const e = this._rowOutlet.viewContainer;
                t.forEachOperation((t, i, n) => { if (null == t.previousIndex) this._insertRow(t.item, n);
                    else if (null == n) e.remove(i);
                    else { const t = e.get(i);
                        e.move(t, n) } }), this._updateRowIndexContext(), t.forEachIdentityChange(t => { e.get(t.currentIndex).context.$implicit = t.item.data }), this.updateStickyColumnStyles() } setHeaderRowDef(t) { this._customHeaderRowDefs = new Set([t]), this._headerRowDefChanged = !0 } setFooterRowDef(t) { this._customFooterRowDefs = new Set([t]), this._footerRowDefChanged = !0 } addColumnDef(t) { this._customColumnDefs.add(t) } removeColumnDef(t) { this._customColumnDefs.delete(t) } addRowDef(t) { this._customRowDefs.add(t) } removeRowDef(t) { this._customRowDefs.delete(t) } addHeaderRowDef(t) { this._customHeaderRowDefs.add(t), this._headerRowDefChanged = !0 } removeHeaderRowDef(t) { this._customHeaderRowDefs.delete(t), this._headerRowDefChanged = !0 } addFooterRowDef(t) { this._customFooterRowDefs.add(t), this._footerRowDefChanged = !0 } removeFooterRowDef(t) { this._customFooterRowDefs.delete(t), this._footerRowDefChanged = !0 } updateStickyHeaderRowStyles() { const t = this._getRenderedRows(this._headerRowOutlet),
                    e = this._elementRef.nativeElement.querySelector("thead");
                e && (e.style.display = t.length ? "" : "none"); const i = this._headerRowDefs.map(t => t.sticky);
                this._stickyStyler.clearStickyPositioning(t, ["top"]), this._stickyStyler.stickRows(t, i, "top"), this._headerRowDefs.forEach(t => t.resetStickyChanged()) } updateStickyFooterRowStyles() { const t = this._getRenderedRows(this._footerRowOutlet),
                    e = this._elementRef.nativeElement.querySelector("tfoot");
                e && (e.style.display = t.length ? "" : "none"); const i = this._footerRowDefs.map(t => t.sticky);
                this._stickyStyler.clearStickyPositioning(t, ["bottom"]), this._stickyStyler.stickRows(t, i, "bottom"), this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, i), this._footerRowDefs.forEach(t => t.resetStickyChanged()) } updateStickyColumnStyles() { const t = this._getRenderedRows(this._headerRowOutlet),
                    e = this._getRenderedRows(this._rowOutlet),
                    i = this._getRenderedRows(this._footerRowOutlet);
                this._stickyStyler.clearStickyPositioning([...t, ...e, ...i], ["left", "right"]), t.forEach((t, e) => { this._addStickyColumnStyles([t], this._headerRowDefs[e]) }), this._rowDefs.forEach(t => { const i = []; for (let n = 0; n < e.length; n++) this._renderRows[n].rowDef === t && i.push(e[n]);
                    this._addStickyColumnStyles(i, t) }), i.forEach((t, e) => { this._addStickyColumnStyles([t], this._footerRowDefs[e]) }), Array.from(this._columnDefsByName.values()).forEach(t => t.resetStickyChanged()) } _getAllRenderRows() { const t = [],
                    e = this._cachedRenderRowsMap;
                this._cachedRenderRowsMap = new Map; for (let i = 0; i < this._data.length; i++) { let n = this._data[i]; const s = this._getRenderRowsForData(n, i, e.get(n));
                    this._cachedRenderRowsMap.has(n) || this._cachedRenderRowsMap.set(n, new WeakMap); for (let e = 0; e < s.length; e++) { let i = s[e]; const n = this._cachedRenderRowsMap.get(i.data);
                        n.has(i.rowDef) ? n.get(i.rowDef).push(i) : n.set(i.rowDef, [i]), t.push(i) } } return t } _getRenderRowsForData(t, e, i) { return this._getRowDefs(t, e).map(n => { const s = i && i.has(n) ? i.get(n) : []; if (s.length) { const t = s.shift(); return t.dataIndex = e, t } return { data: t, rowDef: n, dataIndex: e } }) } _cacheColumnDefs() { this._columnDefsByName.clear(), DL(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs).forEach(t => { if (this._columnDefsByName.has(t.name)) throw Error(`Duplicate column definition name provided: "${t.name}".`);
                    this._columnDefsByName.set(t.name, t) }) } _cacheRowDefs() { this._headerRowDefs = DL(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs), this._footerRowDefs = DL(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs), this._rowDefs = DL(this._getOwnDefs(this._contentRowDefs), this._customRowDefs); const t = this._rowDefs.filter(t => !t.when); if (!this.multiTemplateDataRows && t.length > 1) throw Error("There can only be one default row without a when predicate function.");
                this._defaultRowDef = t[0] } _renderUpdatedColumns() { const t = (t, e) => t || !!e.getColumnsDiff();
                this._rowDefs.reduce(t, !1) && this._forceRenderDataRows(), this._headerRowDefs.reduce(t, !1) && this._forceRenderHeaderRows(), this._footerRowDefs.reduce(t, !1) && this._forceRenderFooterRows() } _switchDataSource(t) { this._data = [], lD(this.dataSource) && this.dataSource.disconnect(this), this._renderChangeSubscription && (this._renderChangeSubscription.unsubscribe(), this._renderChangeSubscription = null), t || (this._dataDiffer && this._dataDiffer.diff([]), this._rowOutlet.viewContainer.clear()), this._dataSource = t } _observeRenderChanges() { if (!this.dataSource) return; let t; if (lD(this.dataSource) ? t = this.dataSource.connect(this) : (e = this.dataSource) && (e instanceof v || "function" == typeof e.lift && "function" == typeof e.subscribe) ? t = this.dataSource : Array.isArray(this.dataSource) && (t = Mu(this.dataSource)), void 0 === t) throw Error("Provided data source did not match an array, Observable, or DataSource"); var e;
                this._renderChangeSubscription = t.pipe(jk(this._onDestroy)).subscribe(t => { this._data = t || [], this.renderRows() }) } _forceRenderHeaderRows() { this._headerRowOutlet.viewContainer.length > 0 && this._headerRowOutlet.viewContainer.clear(), this._headerRowDefs.forEach((t, e) => this._renderRow(this._headerRowOutlet, t, e)), this.updateStickyHeaderRowStyles(), this.updateStickyColumnStyles() } _forceRenderFooterRows() { this._footerRowOutlet.viewContainer.length > 0 && this._footerRowOutlet.viewContainer.clear(), this._footerRowDefs.forEach((t, e) => this._renderRow(this._footerRowOutlet, t, e)), this.updateStickyFooterRowStyles(), this.updateStickyColumnStyles() } _addStickyColumnStyles(t, e) { const i = Array.from(e.columns || []).map(t => { const e = this._columnDefsByName.get(t); if (!e) throw CL(t); return e }),
                    n = i.map(t => t.sticky),
                    s = i.map(t => t.stickyEnd);
                this._stickyStyler.updateStickyColumns(t, n, s) } _getRenderedRows(t) { const e = []; for (let i = 0; i < t.viewContainer.length; i++) { const n = t.viewContainer.get(i);
                    e.push(n.rootNodes[0]) } return e } _getRowDefs(t, e) { if (1 == this._rowDefs.length) return [this._rowDefs[0]]; let i = []; if (this.multiTemplateDataRows) i = this._rowDefs.filter(i => !i.when || i.when(e, t));
                else { let n = this._rowDefs.find(i => i.when && i.when(e, t)) || this._defaultRowDef;
                    n && i.push(n) } if (!i.length) throw function(t) { return Error("Could not find a matching row definition for the" + `provided row data: ${JSON.stringify(t)}`) }(t); return i } _insertRow(t, e) { this._renderRow(this._rowOutlet, t.rowDef, e, { $implicit: t.data }) } _renderRow(t, e, i, n = {}) { t.viewContainer.createEmbeddedView(e.template, n, i); for (let s of this._getCellTemplates(e)) gL.mostRecentCellOutlet && gL.mostRecentCellOutlet._viewContainer.createEmbeddedView(s, n);
                this._changeDetectorRef.markForCheck() } _updateRowIndexContext() { const t = this._rowOutlet.viewContainer; for (let e = 0, i = t.length; e < i; e++) { const n = t.get(e).context;
                    n.count = i, n.first = 0 === e, n.last = e === i - 1, n.even = e % 2 == 0, n.odd = !n.even, this.multiTemplateDataRows ? (n.dataIndex = this._renderRows[e].dataIndex, n.renderIndex = e) : n.index = this._renderRows[e].dataIndex } } _getCellTemplates(t) { return t && t.columns ? Array.from(t.columns, e => { const i = this._columnDefsByName.get(e); if (!i) throw CL(e); return t.extractCellTemplate(i) }) : [] } _applyNativeTableSections() { const t = this._document.createDocumentFragment(),
                    e = [{ tag: "thead", outlet: this._headerRowOutlet }, { tag: "tbody", outlet: this._rowOutlet }, { tag: "tfoot", outlet: this._footerRowOutlet }]; for (const i of e) { const e = this._document.createElement(i.tag);
                    e.setAttribute("role", "rowgroup"), e.appendChild(i.outlet.elementRef.nativeElement), t.appendChild(e) } this._elementRef.nativeElement.appendChild(t) } _forceRenderDataRows() { this._dataDiffer.diff([]), this._rowOutlet.viewContainer.clear(), this.renderRows(), this.updateStickyColumnStyles() } _checkStickyStates() { const t = (t, e) => t || e.hasStickyChanged();
                this._headerRowDefs.reduce(t, !1) && this.updateStickyHeaderRowStyles(), this._footerRowDefs.reduce(t, !1) && this.updateStickyFooterRowStyles(), Array.from(this._columnDefsByName.values()).reduce(t, !1) && this.updateStickyColumnStyles() } _setupStickyStyler() { this._stickyStyler = new wL(this._isNativeHtmlTable, this.stickyCssClass, this._dir ? this._dir.value : "ltr", this._platform.isBrowser), (this._dir ? this._dir.change : Mu()).pipe(jk(this._onDestroy)).subscribe(t => { this._stickyStyler.direction = t, this.updateStickyColumnStyles() }) } _getOwnDefs(t) { return t.filter(t => !t._table || t._table === this) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(dl), Sa(jr), Sa(Wo), ka("role"), Sa(Rw, 8), Sa(uh), Sa(Wv)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["cdk-table"],
                ["table", "cdk-table", ""]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, nL, !0), sc(i, fL, !0), sc(i, dL, !0), sc(i, pL, !0)), 2 & t && (tc(n = oc()) && (e._contentColumnDefs = n), tc(n = oc()) && (e._contentRowDefs = n), tc(n = oc()) && (e._contentHeaderRowDefs = n), tc(n = oc()) && (e._contentFooterRowDefs = n)) }, viewQuery: function(t, e) { var i;
                1 & t && (ec(xL, !0), ec(SL, !0), ec(kL, !0)), 2 & t && (tc(i = oc()) && (e._rowOutlet = i.first), tc(i = oc()) && (e._headerRowOutlet = i.first), tc(i = oc()) && (e._footerRowOutlet = i.first)) }, hostAttrs: [1, "cdk-table"], inputs: { trackBy: "trackBy", dataSource: "dataSource", multiTemplateDataRows: "multiTemplateDataRows" }, exportAs: ["cdkTable"], features: [Ho([{ provide: KN, useExisting: t }])], ngContentSelectors: WN, decls: 4, vars: 0, consts: [
                ["headerRowOutlet", ""],
                ["rowOutlet", ""],
                ["footerRowOutlet", ""]
            ], template: function(t, e) { 1 & t && ($a($N), Wa(0), Pa(1, 0), Pa(2, 1), Pa(3, 2)) }, directives: [SL, xL, kL], encapsulation: 2 }), t })();

    function DL(t, e) { return t.concat(Array.from(e)) }
    let AL = (() => { class t { constructor(t, e) { this._table = t, this._options = e, this.justify = "start", this._options = e || {} } get name() { return this._name } set name(t) { this._name = t, this._syncColumnDefName() } ngOnInit() { if (this._syncColumnDefName(), void 0 === this.headerText && (this.headerText = this._createDefaultHeaderText()), this.dataAccessor || (this.dataAccessor = this._options.defaultDataAccessor || ((t, e) => t[e])), !this._table) throw Error("Text column could not find a parent table for registration.");
                this.columnDef.cell = this.cell, this.columnDef.headerCell = this.headerCell, this._table.addColumnDef(this.columnDef) } ngOnDestroy() { this._table && this._table.removeColumnDef(this.columnDef) } _createDefaultHeaderText() { const t = this.name; if (Sn() && !t) throw Error("Table text column must have a name."); return this._options && this._options.defaultHeaderTextTransform ? this._options.defaultHeaderTextTransform(t) : t[0].toUpperCase() + t.slice(1) } _syncColumnDefName() { this.columnDef && (this.columnDef.name = this.name) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(EL, 8), Sa(ZN, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["cdk-text-column"]
            ], viewQuery: function(t, e) { var i;
                1 & t && (ec(nL, !0), ec(QN, !0), ec(JN, !0)), 2 & t && (tc(i = oc()) && (e.columnDef = i.first), tc(i = oc()) && (e.cell = i.first), tc(i = oc()) && (e.headerCell = i.first)) }, inputs: { justify: "justify", name: "name", headerText: "headerText", dataAccessor: "dataAccessor" }, decls: 3, vars: 0, consts: [
                ["cdkColumnDef", ""],
                ["cdk-header-cell", "", 3, "text-align", 4, "cdkHeaderCellDef"],
                ["cdk-cell", "", 3, "text-align", 4, "cdkCellDef"],
                ["cdk-header-cell", ""],
                ["cdk-cell", ""]
            ], template: function(t, e) { 1 & t && (Ra(0, 0), Ca(1, qN, 2, 3, "th", 1), Ca(2, YN, 2, 3, "td", 2), Ma()) }, directives: [nL, JN, QN, rL, oL], encapsulation: 2 }), t })(), IL = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })();
    const TL = [
        [
            ["caption"]
        ]
    ], OL = ["caption"];

    function RL(t, e) { if (1 & t && (Ia(0, "th", 3), _o(1), Ta()), 2 & t) { const t = ja();
            io("text-align", t.justify), ps(1), yo(" ", t.headerText, " ") } }

    function ML(t, e) { if (1 & t && (Ia(0, "td", 4), _o(1), Ta()), 2 & t) { const t = e.$implicit,
                i = ja();
            io("text-align", i.justify), ps(1), yo(" ", i.dataAccessor(t, i.name), " ") } }
    let PL = (() => { class t extends EL { constructor() { super(...arguments), this.stickyCssClass = "mat-table-sticky" } } return t.\u0275fac = function(e) { return FL(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-table"],
                ["table", "mat-table", ""]
            ], hostAttrs: [1, "mat-table"], exportAs: ["matTable"], features: [Ho([{ provide: EL, useExisting: t }, { provide: KN, useExisting: t }]), Eo], ngContentSelectors: OL, decls: 4, vars: 0, consts: [
                ["headerRowOutlet", ""],
                ["rowOutlet", ""],
                ["footerRowOutlet", ""]
            ], template: function(t, e) { 1 & t && ($a(TL), Wa(0), Pa(1, 0), Pa(2, 1), Pa(3, 2)) }, directives: [SL, xL, kL], styles: ['mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-row::after,mat-header-row::after,mat-footer-row::after{display:inline-block;min-height:inherit;content:""}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type,[dir=rtl] mat-header-cell:first-of-type,[dir=rtl] mat-footer-cell:first-of-type{padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type,[dir=rtl] mat-header-cell:last-of-type,[dir=rtl] mat-footer-cell:last-of-type{padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}table.mat-table{border-spacing:0}tr.mat-header-row{height:56px}tr.mat-row,tr.mat-footer-row{height:48px}th.mat-header-cell{text-align:left}[dir=rtl] th.mat-header-cell{text-align:right}th.mat-header-cell,td.mat-cell,td.mat-footer-cell{padding:0;border-bottom-width:1px;border-bottom-style:solid}th.mat-header-cell:first-of-type,td.mat-cell:first-of-type,td.mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] th.mat-header-cell:first-of-type,[dir=rtl] td.mat-cell:first-of-type,[dir=rtl] td.mat-footer-cell:first-of-type{padding-left:0;padding-right:24px}th.mat-header-cell:last-of-type,td.mat-cell:last-of-type,td.mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] th.mat-header-cell:last-of-type,[dir=rtl] td.mat-cell:last-of-type,[dir=rtl] td.mat-footer-cell:last-of-type{padding-right:0;padding-left:24px}\n'], encapsulation: 2 }), t })();
    const FL = ln(PL);
    let NL = (() => { class t extends QN {} return t.\u0275fac = function(e) { return LL(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matCellDef", ""]
            ], features: [Ho([{ provide: QN, useExisting: t }]), Eo] }), t })();
    const LL = ln(NL);
    let BL = (() => { class t extends JN {} return t.\u0275fac = function(e) { return VL(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matHeaderCellDef", ""]
            ], features: [Ho([{ provide: JN, useExisting: t }]), Eo] }), t })();
    const VL = ln(BL);
    let zL = (() => { class t extends tL {} return t.\u0275fac = function(e) { return UL(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matFooterCellDef", ""]
            ], features: [Ho([{ provide: tL, useExisting: t }]), Eo] }), t })();
    const UL = ln(zL);
    let HL = (() => { class t extends nL {} return t.\u0275fac = function(e) { return jL(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matColumnDef", ""]
            ], inputs: { sticky: "sticky", name: ["matColumnDef", "name"] }, features: [Ho([{ provide: nL, useExisting: t }, { provide: "MAT_SORT_HEADER_COLUMN_DEF", useExisting: t }]), Eo] }), t })();
    const jL = ln(HL);
    let GL = (() => { class t extends rL { constructor(t, e) { super(t, e), e.nativeElement.classList.add(`mat-column-${t.cssClassFriendlyName}`) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(nL), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-header-cell"],
                ["th", "mat-header-cell", ""]
            ], hostAttrs: ["role", "columnheader", 1, "mat-header-cell"], features: [Eo] }), t })(), $L = (() => { class t extends aL { constructor(t, e) { super(t, e), e.nativeElement.classList.add(`mat-column-${t.cssClassFriendlyName}`) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(nL), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-footer-cell"],
                ["td", "mat-footer-cell", ""]
            ], hostAttrs: ["role", "gridcell", 1, "mat-footer-cell"], features: [Eo] }), t })(), WL = (() => { class t extends oL { constructor(t, e) { super(t, e), e.nativeElement.classList.add(`mat-column-${t.cssClassFriendlyName}`) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(nL), Sa(Wo)) }, t.\u0275dir = we({ type: t, selectors: [
                ["mat-cell"],
                ["td", "mat-cell", ""]
            ], hostAttrs: ["role", "gridcell", 1, "mat-cell"], features: [Eo] }), t })(), qL = (() => { class t extends dL {} return t.\u0275fac = function(e) { return YL(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matHeaderRowDef", ""]
            ], inputs: { columns: ["matHeaderRowDef", "columns"], sticky: ["matHeaderRowDefSticky", "sticky"] }, features: [Ho([{ provide: dL, useExisting: t }]), Eo] }), t })();
    const YL = ln(qL);
    let XL = (() => { class t extends pL {} return t.\u0275fac = function(e) { return KL(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matFooterRowDef", ""]
            ], inputs: { columns: ["matFooterRowDef", "columns"], sticky: ["matFooterRowDefSticky", "sticky"] }, features: [Ho([{ provide: pL, useExisting: t }]), Eo] }), t })();
    const KL = ln(XL);
    let ZL = (() => { class t extends fL {} return t.\u0275fac = function(e) { return QL(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matRowDef", ""]
            ], inputs: { columns: ["matRowDefColumns", "columns"], when: ["matRowDefWhen", "when"] }, features: [Ho([{ provide: fL, useExisting: t }]), Eo] }), t })();
    const QL = ln(ZL);
    let JL = (() => { class t extends _L {} return t.\u0275fac = function(e) { return tB(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-header-row"],
                ["tr", "mat-header-row", ""]
            ], hostAttrs: ["role", "row", 1, "mat-header-row"], exportAs: ["matHeaderRow"], features: [Ho([{ provide: _L, useExisting: t }]), Eo], decls: 1, vars: 0, consts: [
                ["cdkCellOutlet", ""]
            ], template: function(t, e) { 1 & t && Pa(0, 0) }, directives: [gL], encapsulation: 2 }), t })();
    const tB = ln(JL);
    let eB = (() => { class t extends bL {} return t.\u0275fac = function(e) { return iB(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-footer-row"],
                ["tr", "mat-footer-row", ""]
            ], hostAttrs: ["role", "row", 1, "mat-footer-row"], exportAs: ["matFooterRow"], features: [Ho([{ provide: bL, useExisting: t }]), Eo], decls: 1, vars: 0, consts: [
                ["cdkCellOutlet", ""]
            ], template: function(t, e) { 1 & t && Pa(0, 0) }, directives: [gL], encapsulation: 2 }), t })();
    const iB = ln(eB);
    let nB = (() => { class t extends yL {} return t.\u0275fac = function(e) { return sB(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-row"],
                ["tr", "mat-row", ""]
            ], hostAttrs: ["role", "row", 1, "mat-row"], exportAs: ["matRow"], features: [Ho([{ provide: yL, useExisting: t }]), Eo], decls: 1, vars: 0, consts: [
                ["cdkCellOutlet", ""]
            ], template: function(t, e) { 1 & t && Pa(0, 0) }, directives: [gL], encapsulation: 2 }), t })();
    const sB = ln(nB);
    let rB = (() => { class t extends AL {} return t.\u0275fac = function(e) { return aB(e || t) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-text-column"]
            ], features: [Eo], decls: 3, vars: 0, consts: [
                ["matColumnDef", ""],
                ["mat-header-cell", "", 3, "text-align", 4, "matHeaderCellDef"],
                ["mat-cell", "", 3, "text-align", 4, "matCellDef"],
                ["mat-header-cell", ""],
                ["mat-cell", ""]
            ], template: function(t, e) { 1 & t && (Ra(0, 0), Ca(1, RL, 2, 3, "th", 1), Ca(2, ML, 2, 3, "td", 2), Ma()) }, directives: [HL, BL, NL, GL, WL], encapsulation: 2 }), t })();
    const aB = ln(rB);
    let oB = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [IL, _S]
            ] }), t })();
    const lB = ["mat-sort-header", ""];

    function cB(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 3), Ba("@arrowPosition.start", (function() { return Qe(t), ja()._disableViewStateAnimation = !0 }))("@arrowPosition.done", (function() { return Qe(t), ja()._disableViewStateAnimation = !1 })), Oa(1, "div", 4), Ia(2, "div", 5), Oa(3, "div", 6), Oa(4, "div", 7), Oa(5, "div", 8), Ta(), Ta() } if (2 & t) { const t = ja();
            Da("@arrowOpacity", t._getArrowViewState())("@arrowPosition", t._getArrowViewState())("@allowChildren", t._getArrowDirectionState()), ps(2), Da("@indicator", t._getArrowDirectionState()), ps(1), Da("@leftPointer", t._getArrowDirectionState()), ps(1), Da("@rightPointer", t._getArrowDirectionState()) } }
    const hB = ["*"]; class dB {}
    const uB = xS(bS(dB));
    let mB = (() => { class t extends uB { constructor() { super(...arguments), this.sortables = new Map, this._stateChanges = new k, this.start = "asc", this._direction = "", this.sortChange = new jl } get direction() { return this._direction } set direction(t) { if (Sn() && t && "asc" !== t && "desc" !== t) throw function(t) { return Error(`${t} is not a valid sort direction ('asc' or 'desc').`) }(t);
                this._direction = t } get disableClear() { return this._disableClear } set disableClear(t) { this._disableClear = Vv(t) } register(t) { if (!t.id) throw Error("MatSortHeader must be provided with a unique id."); if (this.sortables.has(t.id)) throw Error(`Cannot have two MatSortables with the same id (${t.id}).`);
                this.sortables.set(t.id, t) } deregister(t) { this.sortables.delete(t.id) } sort(t) { this.active != t.id ? (this.active = t.id, this.direction = t.start ? t.start : this.start) : this.direction = this.getNextSortDirection(t), this.sortChange.emit({ active: this.active, direction: this.direction }) } getNextSortDirection(t) { if (!t) return ""; let e = function(t, e) { let i = ["asc", "desc"]; return "desc" == t && i.reverse(), e || i.push(""), i }(t.start || this.start, null != t.disableClear ? t.disableClear : this.disableClear),
                    i = e.indexOf(this.direction) + 1; return i >= e.length && (i = 0), e[i] } ngOnInit() { this._markInitialized() } ngOnChanges() { this._stateChanges.next() } ngOnDestroy() { this._stateChanges.complete() } } return t.\u0275fac = function(e) { return pB(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "matSort", ""]
            ], hostAttrs: [1, "mat-sort"], inputs: { disabled: ["matSortDisabled", "disabled"], start: ["matSortStart", "start"], direction: ["matSortDirection", "direction"], disableClear: ["matSortDisableClear", "disableClear"], active: ["matSortActive", "active"] }, outputs: { sortChange: "matSortChange" }, exportAs: ["matSort"], features: [Eo, Ro] }), t })();
    const pB = ln(mB), fB = pS.ENTERING + " " + mS.STANDARD_CURVE, gB = { indicator: Lw("indicator", [Hw("active-asc, asc", Uw({ transform: "translateY(0px)" })), Hw("active-desc, desc", Uw({ transform: "translateY(10px)" })), Gw("active-asc <=> active-desc", Bw(fB))]), leftPointer: Lw("leftPointer", [Hw("active-asc, asc", Uw({ transform: "rotate(-45deg)" })), Hw("active-desc, desc", Uw({ transform: "rotate(45deg)" })), Gw("active-asc <=> active-desc", Bw(fB))]), rightPointer: Lw("rightPointer", [Hw("active-asc, asc", Uw({ transform: "rotate(45deg)" })), Hw("active-desc, desc", Uw({ transform: "rotate(-45deg)" })), Gw("active-asc <=> active-desc", Bw(fB))]), arrowOpacity: Lw("arrowOpacity", [Hw("desc-to-active, asc-to-active, active", Uw({ opacity: 1 })), Hw("desc-to-hint, asc-to-hint, hint", Uw({ opacity: .54 })), Hw("hint-to-desc, active-to-desc, desc, hint-to-asc, active-to-asc, asc, void", Uw({ opacity: 0 })), Gw("* => asc, * => desc, * => active, * => hint, * => void", Bw("0ms")), Gw("* <=> *", Bw(fB))]), arrowPosition: Lw("arrowPosition", [Gw("* => desc-to-hint, * => desc-to-active", Bw(fB, jw([Uw({ transform: "translateY(-25%)" }), Uw({ transform: "translateY(0)" })]))), Gw("* => hint-to-desc, * => active-to-desc", Bw(fB, jw([Uw({ transform: "translateY(0)" }), Uw({ transform: "translateY(25%)" })]))), Gw("* => asc-to-hint, * => asc-to-active", Bw(fB, jw([Uw({ transform: "translateY(25%)" }), Uw({ transform: "translateY(0)" })]))), Gw("* => hint-to-asc, * => active-to-asc", Bw(fB, jw([Uw({ transform: "translateY(0)" }), Uw({ transform: "translateY(-25%)" })]))), Hw("desc-to-hint, asc-to-hint, hint, desc-to-active, asc-to-active, active", Uw({ transform: "translateY(0)" })), Hw("hint-to-desc, active-to-desc, desc", Uw({ transform: "translateY(-25%)" })), Hw("hint-to-asc, active-to-asc, asc", Uw({ transform: "translateY(25%)" }))]), allowChildren: Lw("allowChildren", [Gw("* <=> *", [Yw("@*", Ww(), { optional: !0 })])]) };
    let _B = (() => { class t { constructor() { this.changes = new k, this.sortButtonLabel = t => `Change sorting for ${t}` } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return new t }, token: t, providedIn: "root" }), t })();
    const bB = { provide: _B, deps: [
            [new rt, new ot, _B]
        ], useFactory: function(t) { return t || new _B } }; class yB {}
    const vB = bS(yB);
    let wB = (() => { class t extends vB { constructor(t, e, i, n, s, r) { if (super(), this._intl = t, this._sort = i, this._columnDef = n, this._focusMonitor = s, this._elementRef = r, this._showIndicatorHint = !1, this._arrowDirection = "", this._disableViewStateAnimation = !1, this.arrowPosition = "after", !i) throw Error("MatSortHeader must be placed within a parent element with the MatSort directive.");
                this._rerenderSubscription = q(i.sortChange, i._stateChanges, t.changes).subscribe(() => { this._isSorted() && this._updateArrowDirection(), !this._isSorted() && this._viewState && "active" === this._viewState.toState && (this._disableViewStateAnimation = !1, this._setAnimationTransitionState({ fromState: "active", toState: this._arrowDirection })), e.markForCheck() }), s && r && s.monitor(r, !0).subscribe(t => this._setIndicatorHintVisible(!!t)) } get disableClear() { return this._disableClear } set disableClear(t) { this._disableClear = Vv(t) } ngOnInit() {!this.id && this._columnDef && (this.id = this._columnDef.name), this._updateArrowDirection(), this._setAnimationTransitionState({ toState: this._isSorted() ? "active" : this._arrowDirection }), this._sort.register(this) } ngOnDestroy() { this._focusMonitor && this._elementRef && this._focusMonitor.stopMonitoring(this._elementRef), this._sort.deregister(this), this._rerenderSubscription.unsubscribe() } _setIndicatorHintVisible(t) { this._isDisabled() && t || (this._showIndicatorHint = t, this._isSorted() || (this._updateArrowDirection(), this._setAnimationTransitionState(this._showIndicatorHint ? { fromState: this._arrowDirection, toState: "hint" } : { fromState: "hint", toState: this._arrowDirection }))) } _setAnimationTransitionState(t) { this._viewState = t, this._disableViewStateAnimation && (this._viewState = { toState: t.toState }) } _handleClick() { if (this._isDisabled()) return;
                this._sort.sort(this), "hint" !== this._viewState.toState && "active" !== this._viewState.toState || (this._disableViewStateAnimation = !0); const t = this._isSorted() ? { fromState: this._arrowDirection, toState: "active" } : { fromState: "active", toState: this._arrowDirection };
                this._setAnimationTransitionState(t), this._showIndicatorHint = !1 } _isSorted() { return this._sort.active == this.id && ("asc" === this._sort.direction || "desc" === this._sort.direction) } _getArrowDirectionState() { return `${this._isSorted()?"active-":""}${this._arrowDirection}` } _getArrowViewState() { const t = this._viewState.fromState; return (t ? `${t}-to-` : "") + this._viewState.toState } _updateArrowDirection() { this._arrowDirection = this._isSorted() ? this._sort.direction : this.start || this._sort.start } _isDisabled() { return this._sort.disabled || this.disabled } _getAriaSortAttribute() { return this._isSorted() ? "asc" == this._sort.direction ? "ascending" : "descending" : null } _renderArrow() { return !this._isDisabled() || this._isSorted() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(_B), Sa(jr), Sa(mB, 8), Sa("MAT_SORT_HEADER_COLUMN_DEF", 8), Sa(Ew), Sa(Wo)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["", "mat-sort-header", ""]
            ], hostAttrs: [1, "mat-sort-header"], hostVars: 3, hostBindings: function(t, e) { 1 & t && Ba("click", (function() { return e._handleClick() }))("mouseenter", (function() { return e._setIndicatorHintVisible(!0) }))("mouseleave", (function() { return e._setIndicatorHintVisible(!1) })), 2 & t && (va("aria-sort", e._getAriaSortAttribute()), no("mat-sort-header-disabled", e._isDisabled())) }, inputs: { disabled: "disabled", arrowPosition: "arrowPosition", disableClear: "disableClear", id: ["mat-sort-header", "id"], start: "start" }, exportAs: ["matSortHeader"], features: [Eo], attrs: lB, ngContentSelectors: hB, decls: 4, vars: 7, consts: [
                [1, "mat-sort-header-container"],
                ["type", "button", 1, "mat-sort-header-button", "mat-focus-indicator"],
                ["class", "mat-sort-header-arrow", 4, "ngIf"],
                [1, "mat-sort-header-arrow"],
                [1, "mat-sort-header-stem"],
                [1, "mat-sort-header-indicator"],
                [1, "mat-sort-header-pointer-left"],
                [1, "mat-sort-header-pointer-right"],
                [1, "mat-sort-header-pointer-middle"]
            ], template: function(t, e) { 1 & t && ($a(), Ia(0, "div", 0), Ia(1, "button", 1), Wa(2), Ta(), Ca(3, cB, 6, 6, "div", 2), Ta()), 2 & t && (no("mat-sort-header-sorted", e._isSorted())("mat-sort-header-position-before", "before" == e.arrowPosition), ps(1), va("disabled", e._isDisabled() || null)("aria-label", e._intl.sortButtonLabel(e.id)), ps(2), Da("ngIf", e._renderArrow())) }, directives: [yd], styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-button{border:none;background:0 0;display:flex;align-items:center;padding:0;cursor:inherit;outline:0;font:inherit;color:currentColor;position:relative}[mat-sort-header].cdk-keyboard-focused .mat-sort-header-button,[mat-sort-header].cdk-program-focused .mat-sort-header-button{border-bottom:solid 1px currentColor}.mat-sort-header-button::-moz-focus-inner{border:0}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}.cdk-high-contrast-active .mat-sort-header-stem{width:0;border-left:solid 2px}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}.cdk-high-contrast-active .mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}.cdk-high-contrast-active .mat-sort-header-pointer-left,.cdk-high-contrast-active .mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}\n"], encapsulation: 2, data: { animation: [gB.indicator, gB.leftPointer, gB.rightPointer, gB.arrowOpacity, gB.arrowPosition, gB.allowChildren] }, changeDetection: 0 }), t })(), CB = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [bB], imports: [
                [Jd]
            ] }), t })();

    function xB(t, e) { if (1 & t && (Ia(0, "mat-option", 19), _o(1), Ta()), 2 & t) { const t = e.$implicit;
            Da("value", t), ps(1), yo(" ", t, " ") } }

    function SB(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "mat-form-field", 16), Ia(1, "mat-select", 17), Ba("selectionChange", (function(e) { return Qe(t), ja(2)._changePageSize(e.value) })), Ca(2, xB, 2, 2, "mat-option", 18), Ta(), Ta() } if (2 & t) { const t = ja(2);
            Da("color", t.color), ps(1), Da("value", t.pageSize)("disabled", t.disabled)("aria-label", t._intl.itemsPerPageLabel), ps(1), Da("ngForOf", t._displayedPageSizeOptions) } }

    function kB(t, e) { if (1 & t && (Ia(0, "div", 20), _o(1), Ta()), 2 & t) { const t = ja(2);
            ps(1), bo(t.pageSize) } }

    function EB(t, e) { if (1 & t && (Ia(0, "div", 12), Ia(1, "div", 13), _o(2), Ta(), Ca(3, SB, 3, 5, "mat-form-field", 14), Ca(4, kB, 2, 1, "div", 15), Ta()), 2 & t) { const t = ja();
            ps(2), yo(" ", t._intl.itemsPerPageLabel, " "), ps(1), Da("ngIf", t._displayedPageSizeOptions.length > 1), ps(1), Da("ngIf", t._displayedPageSizeOptions.length <= 1) } }

    function DB(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "button", 21), Ba("click", (function() { return Qe(t), ja().firstPage() })), Ci(), Ia(1, "svg", 7), Oa(2, "path", 22), Ta(), Ta() } if (2 & t) { const t = ja();
            Da("matTooltip", t._intl.firstPageLabel)("matTooltipDisabled", t._previousButtonsDisabled())("matTooltipPosition", "above")("disabled", t._previousButtonsDisabled()), va("aria-label", t._intl.firstPageLabel) } }

    function AB(t, e) { if (1 & t) { const t = Fa();
            Ci(), xi(), Ia(0, "button", 23), Ba("click", (function() { return Qe(t), ja().lastPage() })), Ci(), Ia(1, "svg", 7), Oa(2, "path", 24), Ta(), Ta() } if (2 & t) { const t = ja();
            Da("matTooltip", t._intl.lastPageLabel)("matTooltipDisabled", t._nextButtonsDisabled())("matTooltipPosition", "above")("disabled", t._nextButtonsDisabled()), va("aria-label", t._intl.lastPageLabel) } }
    let IB = (() => { class t { constructor() { this.changes = new k, this.itemsPerPageLabel = "Items per page:", this.nextPageLabel = "Next page", this.previousPageLabel = "Previous page", this.firstPageLabel = "First page", this.lastPageLabel = "Last page", this.getRangeLabel = (t, e, i) => { if (0 == i || 0 == e) return `0 of ${i}`; const n = t * e; return `${n+1} \u2013 ${n<(i=Math.max(i,0))?Math.min(n+e,i):n+e} of ${i}` } } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ factory: function() { return new t }, token: t, providedIn: "root" }), t })();
    const TB = { provide: IB, deps: [
            [new rt, new ot, IB]
        ], useFactory: function(t) { return t || new IB } }, OB = new Vt("MAT_PAGINATOR_DEFAULT_OPTIONS"); class RB {}
    const MB = bS(xS(RB));
    let PB = (() => { class t extends MB { constructor(t, e, i) { if (super(), this._intl = t, this._changeDetectorRef = e, this._pageIndex = 0, this._length = 0, this._pageSizeOptions = [], this._hidePageSize = !1, this._showFirstLastButtons = !1, this.page = new jl, this._intlChanges = t.changes.subscribe(() => this._changeDetectorRef.markForCheck()), i) { const { pageSize: t, pageSizeOptions: e, hidePageSize: n, showFirstLastButtons: s } = i;
                    null != t && (this._pageSize = t), null != e && (this._pageSizeOptions = e), null != n && (this._hidePageSize = n), null != s && (this._showFirstLastButtons = s) } } get pageIndex() { return this._pageIndex } set pageIndex(t) { this._pageIndex = Math.max(zv(t), 0), this._changeDetectorRef.markForCheck() } get length() { return this._length } set length(t) { this._length = zv(t), this._changeDetectorRef.markForCheck() } get pageSize() { return this._pageSize } set pageSize(t) { this._pageSize = Math.max(zv(t), 0), this._updateDisplayedPageSizeOptions() } get pageSizeOptions() { return this._pageSizeOptions } set pageSizeOptions(t) { this._pageSizeOptions = (t || []).map(t => zv(t)), this._updateDisplayedPageSizeOptions() } get hidePageSize() { return this._hidePageSize } set hidePageSize(t) { this._hidePageSize = Vv(t) } get showFirstLastButtons() { return this._showFirstLastButtons } set showFirstLastButtons(t) { this._showFirstLastButtons = Vv(t) } ngOnInit() { this._initialized = !0, this._updateDisplayedPageSizeOptions(), this._markInitialized() } ngOnDestroy() { this._intlChanges.unsubscribe() } nextPage() { if (!this.hasNextPage()) return; const t = this.pageIndex;
                this.pageIndex++, this._emitPageEvent(t) } previousPage() { if (!this.hasPreviousPage()) return; const t = this.pageIndex;
                this.pageIndex--, this._emitPageEvent(t) } firstPage() { if (!this.hasPreviousPage()) return; const t = this.pageIndex;
                this.pageIndex = 0, this._emitPageEvent(t) } lastPage() { if (!this.hasNextPage()) return; const t = this.pageIndex;
                this.pageIndex = this.getNumberOfPages() - 1, this._emitPageEvent(t) } hasPreviousPage() { return this.pageIndex >= 1 && 0 != this.pageSize } hasNextPage() { const t = this.getNumberOfPages() - 1; return this.pageIndex < t && 0 != this.pageSize } getNumberOfPages() { return this.pageSize ? Math.ceil(this.length / this.pageSize) : 0 } _changePageSize(t) { const e = this.pageIndex;
                this.pageIndex = Math.floor(this.pageIndex * this.pageSize / t) || 0, this.pageSize = t, this._emitPageEvent(e) } _nextButtonsDisabled() { return this.disabled || !this.hasNextPage() } _previousButtonsDisabled() { return this.disabled || !this.hasPreviousPage() } _updateDisplayedPageSizeOptions() { this._initialized && (this.pageSize || (this._pageSize = 0 != this.pageSizeOptions.length ? this.pageSizeOptions[0] : 50), this._displayedPageSizeOptions = this.pageSizeOptions.slice(), -1 === this._displayedPageSizeOptions.indexOf(this.pageSize) && this._displayedPageSizeOptions.push(this.pageSize), this._displayedPageSizeOptions.sort((t, e) => t - e), this._changeDetectorRef.markForCheck()) } _emitPageEvent(t) { this.page.emit({ previousPageIndex: t, pageIndex: this.pageIndex, pageSize: this.pageSize, length: this.length }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(IB), Sa(jr), Sa(OB, 8)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["mat-paginator"]
            ], hostAttrs: [1, "mat-paginator"], inputs: { disabled: "disabled", pageIndex: "pageIndex", length: "length", pageSize: "pageSize", pageSizeOptions: "pageSizeOptions", hidePageSize: "hidePageSize", showFirstLastButtons: "showFirstLastButtons", color: "color" }, outputs: { page: "page" }, exportAs: ["matPaginator"], features: [Eo], decls: 14, vars: 14, consts: [
                [1, "mat-paginator-outer-container"],
                [1, "mat-paginator-container"],
                ["class", "mat-paginator-page-size", 4, "ngIf"],
                [1, "mat-paginator-range-actions"],
                [1, "mat-paginator-range-label"],
                ["mat-icon-button", "", "type", "button", "class", "mat-paginator-navigation-first", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click", 4, "ngIf"],
                ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-previous", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click"],
                ["viewBox", "0 0 24 24", "focusable", "false", 1, "mat-paginator-icon"],
                ["d", "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"],
                ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-next", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click"],
                ["d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"],
                ["mat-icon-button", "", "type", "button", "class", "mat-paginator-navigation-last", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click", 4, "ngIf"],
                [1, "mat-paginator-page-size"],
                [1, "mat-paginator-page-size-label"],
                ["class", "mat-paginator-page-size-select", 3, "color", 4, "ngIf"],
                ["class", "mat-paginator-page-size-value", 4, "ngIf"],
                [1, "mat-paginator-page-size-select", 3, "color"],
                [3, "value", "disabled", "aria-label", "selectionChange"],
                [3, "value", 4, "ngFor", "ngForOf"],
                [3, "value"],
                [1, "mat-paginator-page-size-value"],
                ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-first", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click"],
                ["d", "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"],
                ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-last", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click"],
                ["d", "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div", 0), Ia(1, "div", 1), Ca(2, EB, 5, 3, "div", 2), Ia(3, "div", 3), Ia(4, "div", 4), _o(5), Ta(), Ca(6, DB, 3, 5, "button", 5), Ia(7, "button", 6), Ba("click", (function() { return e.previousPage() })), Ci(), Ia(8, "svg", 7), Oa(9, "path", 8), Ta(), Ta(), xi(), Ia(10, "button", 9), Ba("click", (function() { return e.nextPage() })), Ci(), Ia(11, "svg", 7), Oa(12, "path", 10), Ta(), Ta(), Ca(13, AB, 3, 5, "button", 11), Ta(), Ta(), Ta()), 2 & t && (ps(2), Da("ngIf", !e.hidePageSize), ps(3), yo(" ", e._intl.getRangeLabel(e.pageIndex, e.pageSize, e.length), " "), ps(1), Da("ngIf", e.showFirstLastButtons), ps(1), Da("matTooltip", e._intl.previousPageLabel)("matTooltipDisabled", e._previousButtonsDisabled())("matTooltipPosition", "above")("disabled", e._previousButtonsDisabled()), va("aria-label", e._intl.previousPageLabel), ps(3), Da("matTooltip", e._intl.nextPageLabel)("matTooltipDisabled", e._nextButtonsDisabled())("matTooltipPosition", "above")("disabled", e._nextButtonsDisabled()), va("aria-label", e._intl.nextPageLabel), ps(3), Da("ngIf", e.showFirstLastButtons)) }, directives: [yd, fk, TN, TE, cT, _d, rk], styles: [".mat-paginator{display:block}.mat-paginator-outer-container{display:flex}.mat-paginator-container{display:flex;align-items:center;justify-content:flex-end;min-height:56px;padding:0 8px;flex-wrap:wrap-reverse;width:100%}.mat-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-paginator-page-size{margin-right:0;margin-left:8px}.mat-paginator-page-size-label{margin:0 4px}.mat-paginator-page-size-select{margin:6px 4px 0 4px;width:56px}.mat-paginator-page-size-select.mat-form-field-appearance-outline{width:64px}.mat-paginator-page-size-select.mat-form-field-appearance-fill{width:64px}.mat-paginator-range-label{margin:0 32px 0 24px}.mat-paginator-range-actions{display:flex;align-items:center}.mat-paginator-icon{width:28px;fill:currentColor}[dir=rtl] .mat-paginator-icon{transform:rotate(180deg)}\n"], encapsulation: 2, changeDetection: 0 }), t })(), NB = (() => { class t {} return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [TB], imports: [
                [Jd, _k, hT, RN]
            ] }), t })();
    var LB = i("YS7c"), BB = i.n(LB); class VB { constructor(t, e, i) { this.name = t, this.drake = e, this.options = i, this.initEvents = !1 } }
    const zB = { Cancel: "cancel", Cloned: "cloned", Drag: "drag", DragEnd: "dragend", Drop: "drop", Out: "out", Over: "over", Remove: "remove", Shadow: "shadow", DropModel: "dropModel", RemoveModel: "removeModel" }, UB = Object.keys(zB).map(t => zB[t]), HB = BB.a || LB; class jB { constructor(t = HB) { this.build = t } }
    const GB = (t, e, i) => n => n.pipe(Gu(({ event: i, name: n }) => i === t && (void 0 === e || n === e)), L(({ name: t, args: e }) => i(t, e))), $B = (t, [e, i, n]) => ({ name: t, el: e, container: i, source: n });
    let WB = (() => { class t { constructor(t = null) { this.drakeFactory = t, this.dispatch$ = new k, this.drag = t => this.dispatch$.pipe(GB(zB.Drag, t, (t, [e, i]) => ({ name: t, el: e, source: i }))), this.dragend = t => this.dispatch$.pipe(GB(zB.DragEnd, t, (t, [e]) => ({ name: t, el: e }))), this.drop = t => this.dispatch$.pipe(GB(zB.Drop, t, (t, [e, i, n, s]) => ({ name: t, el: e, target: i, source: n, sibling: s }))), this.elContainerSource = t => e => this.dispatch$.pipe(GB(t, e, $B)), this.cancel = this.elContainerSource(zB.Cancel), this.remove = this.elContainerSource(zB.Remove), this.shadow = this.elContainerSource(zB.Shadow), this.over = this.elContainerSource(zB.Over), this.out = this.elContainerSource(zB.Out), this.cloned = t => this.dispatch$.pipe(GB(zB.Cloned, t, (t, [e, i, n]) => ({ name: t, clone: e, original: i, cloneType: n }))), this.dropModel = t => this.dispatch$.pipe(GB(zB.DropModel, t, (t, [e, i, n, s, r, a, o, l, c]) => ({ name: t, el: e, target: i, source: n, sibling: s, item: r, sourceModel: a, targetModel: o, sourceIndex: l, targetIndex: c }))), this.removeModel = t => this.dispatch$.pipe(GB(zB.RemoveModel, t, (t, [e, i, n, s, r, a]) => ({ name: t, el: e, container: i, source: n, item: s, sourceModel: r, sourceIndex: a }))), this.groups = {}, null === this.drakeFactory && (this.drakeFactory = new jB) } add(t) { if (this.find(t.name)) throw new Error('Group named: "' + t.name + '" already exists.'); return this.groups[t.name] = t, this.handleModels(t), this.setupEvents(t), t } find(t) { return this.groups[t] } destroy(t) { let e = this.find(t);
                e && (e.drake && e.drake.destroy(), delete this.groups[t]) } createGroup(t, e) { return this.add(new VB(t, this.drakeFactory.build([], e), e)) } handleModels({ name: t, drake: e, options: i }) { let n, s, r;
                e.on("remove", (i, n, r) => { if (!e.models) return; let a = e.models[e.containers.indexOf(r)];
                    a = a.slice(0); const o = a.splice(s, 1)[0];
                    this.dispatch$.next({ event: zB.RemoveModel, name: t, args: [i, n, r, o, a, s] }) }), e.on("drag", (t, i) => { e.models && (n = t, s = this.domIndexOf(t, i)) }), e.on("drop", (a, o, l, c) => { if (!e.models || !o) return;
                    r = this.domIndexOf(a, o); let h, d = e.models[e.containers.indexOf(l)],
                        u = e.models[e.containers.indexOf(o)]; if (o === l) d = d.slice(0), h = d.splice(s, 1)[0], d.splice(r, 0, h), u = d;
                    else { let t = n !== a; if (h = d[s], t) { if (!i.copyItem) throw new Error("If you have enabled `copy` on a group, you must provide a `copyItem` function.");
                            h = i.copyItem(h) } if (t || (d = d.slice(0), d.splice(s, 1)), u = u.slice(0), u.splice(r, 0, h), t) try { o.removeChild(a) } catch (L$) {} } this.dispatch$.next({ event: zB.DropModel, name: t, args: [a, o, l, c, h, d, u, s, r] }) }) } setupEvents(t) { if (t.initEvents) return;
                t.initEvents = !0; const e = t.name;
                UB.forEach(i => { t.drake.on(i, (...t) => { this.dispatch$.next({ event: i, name: e, args: t }) }) }) } domIndexOf(t, e) { return Array.prototype.indexOf.call(e.children, t) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(jB, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), qB = (() => { class t { constructor(t, e) { this.el = t, this.dragulaService = e, this.dragulaModelChange = new jl } get container() { return this.el && this.el.nativeElement } ngOnChanges(t) { if (t && t.dragula) { const { previousValue: e, currentValue: i } = t.dragula; let n = !!i;!!e && this.teardown(e), n && this.setup() } else if (t && t.dragulaModel) { const { previousValue: e, currentValue: i } = t.dragulaModel, { drake: n } = this.group; if (this.dragula && n) { n.models = n.models || []; let t = n.models.indexOf(e); - 1 !== t ? (n.models.splice(t, 1), i && n.models.splice(t, 0, i)) : i && n.models.push(i) } } } setup() { let t = this.dragulaService.find(this.dragula);
                t || (t = this.dragulaService.createGroup(this.dragula, {})), (t => { this.dragulaModel && (t.drake.models ? t.drake.models.push(this.dragulaModel) : t.drake.models = [this.dragulaModel]) })(t), t.drake.containers.push(this.container), this.subscribe(this.dragula), this.group = t } subscribe(t) { this.subs = new d, this.subs.add(this.dragulaService.dropModel(t).subscribe(({ source: t, target: e, sourceModel: i, targetModel: n }) => { t === this.el.nativeElement ? this.dragulaModelChange.emit(i) : e === this.el.nativeElement && this.dragulaModelChange.emit(n) })), this.subs.add(this.dragulaService.removeModel(t).subscribe(({ source: t, sourceModel: e }) => { t === this.el.nativeElement && this.dragulaModelChange.emit(e) })) } teardown(t) { this.subs && this.subs.unsubscribe(); const e = this.dragulaService.find(t); if (e) { const t = e.drake.containers.indexOf(this.el.nativeElement); if (-1 !== t && e.drake.containers.splice(t, 1), this.dragulaModel && e.drake && e.drake.models) { let t = e.drake.models.indexOf(this.dragulaModel); - 1 !== t && e.drake.models.splice(t, 1) } } } ngOnDestroy() { this.teardown(this.dragula) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(WB)) }, t.\u0275dir = we({ type: t, selectors: [
                ["", "dragula", ""]
            ], inputs: { dragula: "dragula", dragulaModel: "dragulaModel" }, outputs: { dragulaModelChange: "dragulaModelChange" }, features: [Ro] }), t })(), YB = (() => { class t { static forRoot() { return { ngModule: t, providers: [WB] } } } return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) } }), t })();
    const XB = (() => {
        function t() { return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this } return t.prototype = Object.create(Error.prototype), t })(); class KB { constructor(t, e, i, n) { this.waitFor = t, this.absoluteTimeout = e, this.withObservable = i, this.scheduler = n } call(t, e) { return e.subscribe(new ZB(t, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler)) } } class ZB extends N { constructor(t, e, i, n, s) { super(t), this.absoluteTimeout = e, this.waitFor = i, this.withObservable = n, this.scheduler = s, this.action = null, this.scheduleTimeout() } static dispatchTimeout(t) { const { withObservable: e } = t;
            t._unsubscribeAndRecycle(), t.add(F(t, e)) } scheduleTimeout() { const { action: t } = this;
            t ? this.action = t.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(ZB.dispatchTimeout, this.waitFor, this)) } _next(t) { this.absoluteTimeout || this.scheduleTimeout(), super._next(t) } _unsubscribe() { this.action = null, this.scheduler = null, this.withObservable = null } }

    function QB(t, e = Pv) { return function(t, e, i = Pv) { return n => { let s = aA(t),
                    r = s ? +t - i.now() : Math.abs(t); return n.lift(new KB(r, s, e, i)) } }(t, eD(new XB), e) } class JB { static InitIconList() { null == JB.IconNames && (JB.IconNames = new Array("apple", "google", "honhaiprecision", "gemtek", "lg", "samsung", "tplink", "xiaomi", "obihai", "avaya", "blackberry", "cisco", "dell", "hp", "htc", "microsoft", "windows", "gionee", "acer", "huawei", "ibm", "lenovo", "linksys", "meizu", "mikrotik", "motorola", "msi", "netgear", "sony", "toshiba", "zte", "hewlett packard")), null == JB.Name2File && (JB.Name2File = new Map, JB.Name2File.set("obihai", "phone"), JB.Name2File.set("avaya", "phone"), JB.Name2File.set("windows", "microsoft"), JB.Name2File.set("honhaiprecision", "foxconn"), JB.Name2File.set("hewlett-packard", "hp"), JB.Name2File.set("hewlett packard", "hp")) } static StringFormat(t, e) { var i = /%s/; return e.reduce((function(t, e) { return t.replace(i, e) }), t) } static roundToTwo(t) { return Math.round(100 * t) / 100 } static int2ip(t) { return (255 & t) + "." + (t >> 8 & 255) + "." + (t >> 16 & 255) + "." + (t >>> 24) } static Get2DigiNumber(t) { return t < 10 ? ("0" + t).slice(-2) : t } static ip2int(t) { return t.split(".").reduce((function(t, e) { return (t << 8) + parseInt(e, 10) }), 0) >>> 0 } static GetCurrentTimeSecondsGMT() { return (new Date).getTime() / 1e3 } static string2Bin(t) { for (var e = [], i = 0; i < t.length; i++) e.push(t.charCodeAt(i)); return e } static Str2ArrayBuffer(t) { for (var e = new ArrayBuffer(t.length), i = new Uint8Array(e), n = 0, s = t.length; n < s; n++) i[n] = t.charCodeAt(n); return e } static Hex2Array(t) { for (var e = []; t.length >= 8;) e.push(parseInt(t.substring(0, 8), 16)), t = t.substring(8, t.length); return e } static ArrayBuffer2Hex(t) { for (var e = "", i = 0; i < t.length; i++) { var n = t[i].toString(16);
                e += n = Array(8 - n.length + 1).join("0") + n } return e } static Char2Hex(t) { for (var e = Number(t).toString(16); e.length < 2;) e = "0" + e; return e.toUpperCase() } static Macbuff2Str(t) { let e = "";
            e += JB.Char2Hex(t[0]); for (var i = 1; i < 6; i++) e += ":", e += JB.Char2Hex(t[i]); return e } } class tV { constructor(t) { this.Clone(t) } getHex() { var t = new Uint8Array(this.m_dv.buffer); return JB.ArrayBuffer2Hex(t) } getUintArray() { return new Uint8Array(this.m_dv.buffer) } position(t) { this.m_nPos = t } getInt16(t) { return this.m_dv.getUint16(t, !0) } getInt(t) { return this.m_dv.getInt32(t, !0) } get(t) { return this.m_dv.getUint8(t) } getByteArray(t, e) { return new Uint8Array(this.m_dv.buffer, t, e) } getdv(t, e) { var i = this.m_dv.buffer.slice(t, t + e); return new tV(i) } getString(t, e) { return String.fromCharCode.apply(null, this.getByteArray(t, e)) } isSame(t) { if (t.m_dv.buffer.byteLength != this.m_dv.buffer.byteLength) return !1; for (var e = new Uint8Array(t.m_dv.buffer), i = new Uint8Array(this.m_dv.buffer), n = 0; n != e.byteLength; n++)
                if (e[n] != i[n]) return !1; return !0 } Clone(t) { this.m_dv = new DataView(t.slice(0)), this.m_nPos = 0 } putInt(t) { this.m_dv.setInt32(this.m_nPos, t, !0), this.m_nPos += 4 } put(t) { this.putArrayBuffer(t.m_dv.buffer) } putArrayBuffer(t) { new Uint8Array(this.m_dv.buffer).set(new Uint8Array(t), this.m_nPos), this.m_nPos += t.byteLength } putString(t) { this.putArrayBuffer(JB.Str2ArrayBuffer(t)) } }
    let eV = (() => { class t { constructor() { this.m_nTypeID = 0, this.m_nTotalSize = 0, this.ChildInit(), this.CoreIniBuffer() } CoreIniBuffer() { this.m_MemberBuf = new tV(new ArrayBuffer(this.m_nTotalSize)), this.m_MemberBuf.putInt(this.m_nTotalSize), this.m_MemberBuf.putInt(this.TypeID()) } TypeID() { return this.m_nTypeID } ChildInit() {} ReLoadBuffer() { return this.LoadBuffer(this.m_MemberBuf) } LoadBuffer(t) { this.m_MemberBuf = t; var e = this.m_MemberBuf.getInt(0); if (this.m_nTotalSize != e) return console.log("Wrong size " + e + " Looking for " + this.m_nTotalSize + " type :" + i), !1; var i = this.m_MemberBuf.getInt(4); return i == this.m_nTypeID && this.ChildLoadBuffer() } ChildLoadBuffer() { return !1 } WriteBuffer() { return !0 } } return t.IPCMESSAGE_ID_AD_MEDIUM = 1001, t.IPCMESSAGE_ID_URL = 0, t.IPCMESSAGE_ID_DEVICINFO = 4, t.IPCMESSAGE_ID_SNIFFREQUEST = 2, t.IPCMESSAGE_ID_MESSAGE = 5, t.IPCMESSAGE_ID_IDVALUE = 6, t.IPCMESSAGE_ID_PCINFO = 1, t.IPCMESSAGE_ID_GROUNDSETTING = 7, t.IPCMESSAGE_ID_MAC_ONOFF = 8, t.IPCMESSAGE_ID_SETNAME = 10, t.IPCMESSAGE_ID_STATUS = 11, t.IPCMESSAGE_ID_MAC_INT_VALUE = 12, t.IPCMESSAGE_ID_MESSAGE_TYPE_VALUE = 13, t.IPCMESSAGE_ID_PRO_ACCOUNT = 14, t.IPCMESSAGE_ID_PRO_ACCOUNT_LOGIN = 15, t.IPCMESSAGE_ID_PRO_MEMBER_NEW_ORDER = 16, t.IPCMESSAGE_ID_PRO_MEMBER_ORDER_STATUS = 17, t.IPCMESSAGE_ID_PRO_MEMBER_ACCOUNT_UPDATE = 18, t.IPCMESSAGE_ID_LOCATION_CHANGE = 19, t.IPCMESSAGE_ID_BLACKLIST_UPDATE = 20, t.IPCMESSAGE_ID_USER_ONOFFLINE = 21, t.IPCMESSAGE_ID_GOOGLE_LOGIN = 22, t.IPCMESSAGE_ID_USERSPEED = 29, t.IPCMESSAGE_ID_USERACTIVITY = 30, t.IPCMESSAGE_ID_PRO_ACCOUNT2 = 34, t.IPCMESSAGE_ID_WEBSOCK_LOGIN2 = 35, t.IPCMESSAGE_MAC_ONOFF_PC = 1, t.IPCMESSAGE_MAC_ONOFF_GATEWAY = 2, t.IPCMESSAGE_MAC_ONOFF_BLACKLIST = 3, t.IPCMESSAGE_ID_MAC_INT_SETSPEED = 1, t.IPCMESSAGE_ID_MAC_INT_OFFLINE = 2, t.IPCMESSAGE_ID_MAC_INT_CUTOFF = 3, t.IPCMESSAGE_ID_MAC_INT_SETMYUSER = 4, t.IPCMESSAGE_ID_MAC_INT_SETMONITOR = 5, t.IPCMESSAGE_ID_MAC_INT_SPEED = 6, t.IPCMESSAGE_ID_MAC_INT_USAGE = 7, t.IPCMESSAGE_ID_INT_SETDEFENDER = 1, t.IPCMESSAGE_ID_INT_SCANNETWORK = 2, t.IPCMESSAGE_ID_INT_PID = 3, t.IPCMESSAGE_ID_INT_NETWORKDOWN = 4, t.IPCMESSAGE_ID_INT_CUTOFFMETHOD = 5, t.NETCUTTYPE_CUTOFFMETHOD_BOTH = 0, t.NETCUTTYPE_CUTOFFMETHOD_GATE = 1, t.NETCUTTYPE_CUTOFFMETHOD_PC = 2, t.IPCMESSAGE_ID_INT_FAKEMAC = 6, t.IPCMESSAGE_ID_INT_REGREQUIREMENT = 7, t.IPCMESSAGE_ID_INT_SLOWSCAN = 8, t.IPCMESSAGE_ID_INT_RESETNETWORKNODES = 9, t.IPCMESSAGE_ID_INT_PROUSERFLAG = 10, t.IPCMESSAGE_ID_INT_ISROOT = 11, t.IPCMESSAGE_ID_INT_HASNETCARD = 12, t.IPCMESSAGE_ID_INT_SPEEDLIMIT_ALL = 13, t.IPCMESSAGE_ID_INT_ISPROACCOUNT = 14, t.IPCMESSAGE_ID_INT_LOGINFAILED = 15, t.IPCMESSAGE_ID_INT_RELOGIN = 16, t.IPCMESSAGE_ID_INT_GATEWAYIP = 18, t.IPCMESSAGE_ID_INT_EXTEND = 19, t.IPCMESSAGE_ID_INT_EXTEND_FAILED = 20, t.IPCMESSAGE_ID_INT_CHECKSIGN_FAILED = 21, t.IPCMESSAGE_ID_INT_FASTSCAN = 22, t.IPCMESSAGE_ID_INT_ENABLEGAME = 23, t.IPCMESSAGE_ID_INT_KEEPALIVE = 24, t.IPCMESSAGE_ID_INT_WEBTOKEN = 25, t.IPCMESSAGE_ID_INT_NETLOCK = 26, t.IPCMESSAGE_ID_INT_SERVICE_VERSION = 27, t.IPCMESSAGE_ID_INT_REQUESTPAGE = 28, t.IPCMESSAGE_ID_INT_WEBCLIENTREADY = 29, t.IPCMESSAGE_ID_INT_RESETUSERS = 30, t.IPCMESSAGE_ID_INT_TRAIL = 31, t.IPCMESSAGE_GAME_ACTION_DISALLOW = 0, t.IPCMESSAGE_GAME_ACTION_ALLOW = 1, t.IPCMESSAGE_GAME_ACTION_STARTGAME = 2, t.IPCMESSAGE_GAME_ACTION_DENYGAME = 3, t.IPCMESSAGE_MAX_MESSAGEBUFFER = 3e3, t.IF_NAMESIZE = 256, t.EVENT_NAMESIZE = 256, t.EVENT_FIX_MACSTR = 17, t.EVENT_MAX_IPADDRESS = 126, t.EVENT_MAX_BRANDNAME = 32, t.EVENT_MAX_HOSTNAME = 32, t.EVENT_UUID_SIZE = 32, t.NETCUT_SPEEDLIMIT_UNLIMIT = -1, t.NETCUT_SPEEDLIMIT_75 = 3, t.NETCUT_SPEEDLIMIT_50 = 2, t.NETCUT_SPEEDLIMIT_25 = 1, t.NETCUT_SPEEDLIMIT_CUTOFF = 0, t.IPCMESSAGE_LOGIN_TYPE_UUID = 0, t.IPCMESSAGE_LOGIN_TYPE_MAC = 0, t.IPCMESSAGE_LOGIN_TYPE_ARCAI = 1, t.IPCMESSAGE_LOGIN_TYPE_GOOGLE = 2, t })(), iV = (() => { class t extends eV { ChildInit() { this.m_nTotalSize = 333, this.m_sMacBuf = new tV(new ArrayBuffer(6)), this.m_nTypeID = eV.IPCMESSAGE_ID_PCINFO, this.m_nIndexId = 0, this.m_Previous = null, this.m_Next = null } isMatch(t) { if (null == t || "" == t) return !0; var e = new RegExp(t, "gi"); return -1 != this.m_sHostname.search(e) || -1 != this.m_sBrandName.search(e) || -1 != this.m_sIPStr.search(e) || -1 != this.m_sMacStr.search(e) || -1 != this.m_sNickname.search(e) } GetOnOffSpeedValue() { return this.m_nSpeedLimit != eV.NETCUT_SPEEDLIMIT_CUTOFF ? eV.NETCUT_SPEEDLIMIT_CUTOFF : eV.NETCUT_SPEEDLIMIT_UNLIMIT } GetName() { return "" != this.m_sNickname ? this.m_sNickname : this.m_sHostname } GetTitle() { var t = this.GetName(); return "" == t && (t = this.m_sIPStr + " " + this.m_sBrandName), t } static Speed2Slider(e) { var i, n, s; return eV.NETCUT_SPEEDLIMIT_UNLIMIT == e || e / 1024 >= 1024 ? (i = 100, n = t.sMBITS, s = t.sUnlimitd) : e / 1024 > 100 && e / 1024 < 1024 ? (i = Math.round(80 + (e / 1024 - 100) / (924 / 19)), n = t.sMBITS, s = Math.round(e / 1024).toString()) : e / 1024 > 50 && e / 1024 <= 100 ? (i = Math.round((e / 1024 - 50) / (50 / 19) + 60), n = t.sMBITS, s = Math.round(e / 1024).toString()) : e / 1024 > 1 && e / 1024 <= 50 ? (i = Math.round((e / 1024 - 1) / 1.6 + 30), n = t.sMBITS, s = Math.round(e / 1024).toString()) : (i = Math.round(e / 30), n = t.sKBITS, s = Math.round(e).toString()), { nSliderValue: i, sSpeedUnit: n, sSpeedValue: s } } static SliderSpeed2Speed(t) { var e, i, n = eV.NETCUT_SPEEDLIMIT_UNLIMIT; return 100 == t ? (n = eV.NETCUT_SPEEDLIMIT_UNLIMIT, i = this.sUnlimitd, e = this.sMBITS) : t >= 80 && t < 100 ? (i = (n = Math.round(924 / 19 * (t - 80) + 100)).toString(), n *= 1024, e = this.sMBITS) : t >= 60 && t < 80 ? (i = (n = Math.round(50 / 19 * (t - 60) + 50)).toString(), n *= 1024, e = this.sMBITS) : t >= 30 && t < 60 ? (i = (n = Math.round(1.6 * (t - 30) + 1)).toString(), n *= 1024, e = this.sMBITS) : (i = (n = Math.round(1024 / 30 * (t - 0) + 0)).toString(), e = this.sKBITS), { nSpeed: n, sSpeedValue: i, sSpeedUnit: e } } static GetSpeedImageNumberBySpeed(t) { return t == eV.NETCUT_SPEEDLIMIT_UNLIMIT ? 100 : t / 1024 > 50 ? 75 : t / 1024 >= 1 ? 50 : t <= 1024 && t > 0 ? 25 : 0 } GetSpeedLimit() { return this.m_nSpeedLimit } getOfflineStr() { return this.m_bOff ? "Offline" : "OnLine" } getBrand() { return this.m_sBrandName } SetImgs() { var e = t.m_sImgPath,
                    i = "base.png";
                this.m_bAttacker && (i = "warning.png"), this.m_attackImg = e + i; var n = "base.png";
                this.m_bDefender && (n = "protect.png"), this.m_protectImg = e + n; var s = "google",
                    r = this.getBrand().toLowerCase();
                r = (r = r.replace(/\\s/g, "")).replace(/[^A-Za-z0-9]/g, ""); for (var a = this.getOfflineStr().toLowerCase(), o = 0; o < JB.IconNames.length; o++) { var l = JB.IconNames[o].toLowerCase(); if (-1 != r.indexOf(l)) { s = l; break } } JB.Name2File.has(s) && (s = JB.Name2File.get(s)), "google" == s && -1 != this.m_sHostname.indexOf("Windows") && (s = "microsoft"), "google" == s && -1 != this.m_sHostname.toLowerCase().indexOf("-hp-") && (s = "hp"), this.m_IconImg = e + (s = s + "_" + a + ".png"), this.getOfflineStr().toLowerCase(); var c = "online" + t.GetSpeedImageNumberBySpeed(this.m_nSpeedLimit).toString() + ".png";
                this.m_OnOffImg = e + c, this.m_BlackListImg = e + (this.m_bIsBlackList ? "blacklist_on" : "blacklist_off.png"), this.m_TimerImg = e + this.getTimerStr().toLowerCase() + ".png", this.m_sAttackerStr = this.m_bAttacker ? "Yes" : "No", this.m_sDefenderStr = this.m_bDefender ? "Yes" : "No" } getTimerStr() { return this.m_nLeftSeconds > 0 ? "Timer_Offline" : 0 != this.m_nDailyStartHour || 0 != this.m_nDailyStartMinues || 0 != this.m_nDailyEndHour || 0 != this.m_nDailyEndMinutes ? "Timer_exist" : "Timer_Online" } SetCurrentScheduleOffLeftStr() { if (this.m_nLeftSeconds > 0) { var t, e = Math.floor(this.m_nLeftSeconds / 3600),
                        i = Math.floor(this.m_nLeftSeconds % 3600 / 60);
                    t = e > 0 ? JB.StringFormat("%s H", [e]) + " " + JB.StringFormat("%s M", [i]) : JB.StringFormat("%s Minutes", [i]), this.m_sScheDuleCountDownStr = t } else this.m_sScheDuleCountDownStr = "";
                this.SetImgs() } ChildLoadBuffer() { let t = this.m_MemberBuf; var e = 8;
                this.m_bOff = 1 == t.get(e++), this.m_bDefender = 1 == t.get(e++), this.m_bAttacker = 1 == t.get(e++), this.m_bIsGateWay = 1 == t.get(e++), this.m_bIsMyDevice = 1 == t.get(e++), this.m_bIsBlackList = 1 == t.get(e++), this.m_bIsMyUsers = 1 == t.get(e++), this.m_sMacBuf = t.getdv(e, 6), JB.Macbuff2Str(this.m_sMacBuf.getUintArray()), this.m_sMacStr = t.getString(e += 6, eV.EVENT_FIX_MACSTR), e += eV.EVENT_FIX_MACSTR; var i = t.getInt(e += eV.EVENT_MAX_IPADDRESS); if (this.m_sIPStr = t.getString(e - eV.EVENT_MAX_IPADDRESS, i), e += 4, i = t.getInt(e += eV.EVENT_MAX_BRANDNAME), this.m_sBrandName = t.getString(e - eV.EVENT_MAX_BRANDNAME, i), e += 4, i = t.getInt(e += eV.EVENT_MAX_HOSTNAME), this.m_sHostname = t.getString(e - eV.EVENT_MAX_HOSTNAME, i), e += 4, i = t.getInt(e += eV.EVENT_MAX_HOSTNAME), this.m_sNickname = t.getString(e - eV.EVENT_MAX_HOSTNAME, i), this.m_nSpeedLimit = t.getInt(e += 4), this.m_nSpeedLimit_view = 25 * this.m_nSpeedLimit, e += 4, this.m_nDailyStartHour = t.getInt(e += 4), this.m_nDailyStartMinues = t.getInt(e += 4), this.m_nDailyEndHour = t.getInt(e += 4), this.m_nDailyEndMinutes = t.getInt(e += 4), e += 4, this.m_nOneTimeStartTime = t.getInt(e += 4), e += 4, this.m_nOneTimeEndTime = t.getInt(e += 4), e += 4, this.m_nLeftSeconds = t.getInt(e += 4), e += 4, this.m_bOnline = 1 == t.get(e++), this.nLastOnlineTime = t.getInt(e), this.nLastOfflineTime = t.getInt(e += 4), this.m_bOnline) { var n = new Date(1e3 * this.nLastOnlineTime);
                    this.m_sOnOffLineTimeStamp = n.toLocaleString() } else n = new Date(1e3 * this.nLastOfflineTime), this.m_sOnOffLineTimeStamp = n.toLocaleString(); return this.SetCurrentScheduleOffLeftStr(), !0 } } return t.m_sImgPath = "assets/drawable/", t.sMBITS = "Mbits/sec", t.sKBITS = "Kbits/sec", t.sUnlimitd = "Unlimited", t })(); class nV extends eV { ChildInit() { this.m_nTotalSize = 297, this.m_nTypeID = eV.IPCMESSAGE_ID_USER_ONOFFLINE } ChildLoadBuffer() { var t = 8; let e = this.m_MemberBuf;
            this.m_nTimeStamp = e.getInt(t); var i = e.getInt(t += 4); return this.m_sGatename = e.getString(t += 4, i), t += eV.EVENT_MAX_HOSTNAME, i = e.getInt(t += 6), this.m_sUsername = e.getString(t += 4, i), i = e.getInt(t += eV.EVENT_MAX_HOSTNAME), this.m_sBrand = e.getString(t += 4, i), t += eV.EVENT_MAX_HOSTNAME, this.m_sMac = e.getString(t += 6, eV.EVENT_FIX_MACSTR), i = e.getInt(t += eV.EVENT_FIX_MACSTR), this.m_sIP = e.getString(t += 4, i), t += eV.EVENT_MAX_IPADDRESS, this.m_bOnline = 1 == e.get(t++), this.m_bMyuser = 1 == e.get(t++), this.m_nIndex = e.getInt(t), this.m_nTotalRecords = e.getInt(t += 4), this.m_nTotalPage = e.getInt(t += 4), this.m_nCurrentPage = e.getInt(t += 4), t += 4, !0 } GetReadableRecord() { let t = this.m_bOnline ? "Connected  " : "Left",
                e = this.m_bMyuser ? "Trused" : "Unknown/Guest",
                i = new Date(1e3 * this.m_nTimeStamp).toLocaleString(); return 0 == this.m_nTimeStamp && (i = "Time: __/__/____ __:__:__ __"), "  " + i + this.m_sGatename + " " + e + " User: " + this.m_sUsername + " " + this.m_sBrand + " " + this.m_sIP + " " + this.m_sMac + " " + t } IsToday() { return Math.floor(Date.now() / 1e3) - this.m_nTimeStamp < 86400 } WriteBuffer() { return !0 } } class sV extends eV { ChildInit() { this.m_nTotalSize = 22, this.m_nTypeID = eV.IPCMESSAGE_ID_MAC_INT_VALUE, this.m_sMacBuf = new tV(new ArrayBuffer(6)) } IsSame(t) { return this.m_nID == t.m_nID && this.m_nValue == t.m_nValue && !!this.m_sMacBuf.isSame(t.m_sMacBuf) } ChildLoadBuffer() { var t = 8; let e = this.m_MemberBuf; return this.m_nID = e.getInt(t), this.m_sMacBuf = e.getdv(t += 4, 6), this.m_nValue = e.getInt(t += 6), !0 } WriteBuffer() { return this.m_MemberBuf.position(8), this.m_MemberBuf.putInt(this.m_nID), this.m_MemberBuf.put(this.m_sMacBuf), this.m_MemberBuf.putInt(this.m_nValue), !0 } } class rV { constructor(t) { this.m_usermap = new Map, this.m_id = t, this.ResetList() } ResetList() { this.m_userlist = null, this.m_tail = this.m_userlist, this.m_usermap.clear() } GetALL(t) { let e = 1,
                i = [],
                n = this.m_userlist; for (; null != n;)(null == t || n.isMatch(t)) && (n.m_nIndexId = e, e++, i.push(n)), n = n.m_Next; return i } adduser(t) { this.insertBefore(t, null) } removeuser(t) { if (this.m_usermap.has(t.m_sMacStr)) { let e = this.m_usermap.get(t.m_sMacStr);
                null != e.m_Previous && (e.m_Previous.m_Next = e.m_Next), null != e.m_Next && (e.m_Next.m_Previous = e.m_Previous), null != this.m_tail && this.m_tail.m_sMacStr == e.m_sMacStr && (this.m_tail = e.m_Previous), null != this.m_userlist && this.m_userlist.m_sMacStr == e.m_sMacStr && (this.m_userlist = e.m_Next), e.m_Previous = null, e.m_Next = null, this.m_usermap.delete(e.m_sMacStr) } } insertBefore(t, e) { if (!this.m_usermap.has(t.m_sMacStr))
                if (this.m_usermap.set(t.m_sMacStr, t), this.m_usermap.has(e)) { let i = this.m_usermap.get(e);
                    null != i.m_Previous && (i.m_Previous.m_Next = t, t.m_Previous = i.m_Previous), t.m_Next = i, i.m_Previous = t } else null == this.m_userlist ? (t.m_Previous = this.m_userlist, t.m_Next = null, this.m_userlist = t, this.m_tail = this.m_userlist) : (this.m_tail.m_Next = t, t.m_Previous = this.m_tail, t.m_Next = null, this.m_tail = t) } } class aV extends eV { ChildInit() { this.m_nTotalSize = 16, this.m_nTypeID = eV.IPCMESSAGE_ID_IDVALUE } IsSame(t) { return this.m_nID == t.m_nID && this.m_nValue == t.m_nValue } ChildLoadBuffer() { var t = 8; let e = this.m_MemberBuf; return this.m_nID = e.getInt(t), this.m_nValue = e.getInt(t += 4), !0 } WriteBuffer() { return this.m_MemberBuf.position(8), this.m_MemberBuf.putInt(this.m_nID), this.m_MemberBuf.putInt(this.m_nValue), !0 } } class oV extends eV { ChildInit() { this.m_nTotalSize = 1036, this.m_nTypeID = eV.IPCMESSAGE_ID_STATUS } ChildLoadBuffer() { var t = 8; let e = this.m_MemberBuf; var i = e.getInt(t); return this.m_sMessage = e.getString(t += 4, i), !0 } WriteBuffer() { return !0 } } class lV extends eV { ChildInit() { this.m_nTotalSize = 1036, this.m_nTypeID = eV.IPCMESSAGE_ID_MESSAGE } ChildLoadBuffer() { var t = 8; let e = this.m_MemberBuf; var i = e.getInt(t); return this.m_sMessage = e.getString(t += 4, i), !0 } WriteBuffer() { return !0 } }

    function cV(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "section", 5), Ia(1, "div", 6), _o(2, "Got it, don't show for a week:"), Ta(), Ia(3, "div", 7), Ia(4, "mat-checkbox", 8), Ba("change", (function() { return Qe(t), ja().OnCookieCheck() })), Ta(), Ta(), Ta() } if (2 & t) { const t = ja();
            ps(4), Da("checked", t.m_cookieChecked) } }
    let hV = (() => { class t { constructor(t, e) { this.cookieService = t, this.dialogRef = e, this.m_sTitle = "", this.m_cookieChecked = !1 } OnCookieCheck() { if (this.m_cookieChecked = !this.m_cookieChecked, 0 != this.m_cookie.length) { var t = new Date;
                    t.setTime(t.getTime() + 6048e5), this.cookieService.set(this.m_cookie, this.m_cookieChecked ? "y" : "n", t) } this.dialogRef.close(this.m_sMessage) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Av), Sa(RA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["dialog-message"]
            ], decls: 8, vars: 3, consts: [
                ["mat-dialog-title", "", 2, "color", "#FFFFFF"],
                ["mat-dialog-content", "", 2, "color", "#FFFFFF"],
                ["mat-dialog-actions", "", 2, "margin", "auto"],
                ["mat-button", "", 2, "color", "#87CEEB", "margin", "auto", 3, "click"],
                ["style", "color: #87CEEB; margin: auto;", 4, "ngIf"],
                [2, "color", "#87CEEB", "margin", "auto"],
                [2, "float", "left", "color", "#87CEEB"],
                [2, "float", "right"],
                ["align", "end", "disabled", "false", 3, "checked", "change"]
            ], template: function(t, e) { 1 & t && (Ia(0, "h1", 0), _o(1), Ta(), Ia(2, "div", 1), _o(3), Ta(), Ia(4, "div", 2), Ia(5, "button", 3), Ba("click", (function() { return e.dialogRef.close(e.m_sMessage) })), _o(6, "OK"), Ta(), Ca(7, cV, 5, 1, "section", 4), Ta()), 2 & t && (ps(1), bo(e.m_sTitle), ps(2), bo(e.m_sMessage), ps(4), Da("ngIf", 0 != e.m_cookie.length)) }, directives: [zA, UA, HA, fk, yd, Ak], encapsulation: 2 }), t })(); class dV extends eV { ChildInit() { this.m_nTotalSize = 578, this.m_nTypeID = eV.IPCMESSAGE_ID_PRO_ACCOUNT2 } GetBuyLink(t) { var e = this.m_nProID; return 1 == t ? "http://order.arcai.com/paypal/?product=netcut_one_time_1month_membership&buyerid=" + e : "http://order.arcai.com/paypal/?product=netcut_one_time_1year_membership&buyerid=" + e } GetExpireTime() { return new Date(1e3 * this.m_nExpireTime).toLocaleString() } ChildLoadBuffer() { var t = 8;
            this.m_nProID = this.m_MemberBuf.getInt(t), t += 4, this.m_bExpired = null == this.m_MemberBuf.get(t++), this.m_bLoginOK = 1 == this.m_MemberBuf.get(t++), this.m_nExpireTime = this.m_MemberBuf.getInt(t), this.m_nAccountType = this.m_MemberBuf.getInt(t += 8), this.m_sUUID = this.m_MemberBuf.getString(t += 4, dV.EVENT_UUID_SIZE); var e = this.m_MemberBuf.getInt(t += dV.EVENT_UUID_SIZE); return this.m_sArcaiLogin = this.m_MemberBuf.getString(t += 4, e = e > 256 ? 256 : e), e = this.m_MemberBuf.getInt(t += 256), this.m_sGoogleLogin = this.m_MemberBuf.getString(t += 4, e = e > 256 ? 256 : e), t += 256, !0 } WriteBuffer() { return !0 } } class uV extends eV { ChildInit() { this.m_nTotalSize = 22, this.m_nTypeID = eV.IPCMESSAGE_ID_USERSPEED, this.m_sMacBuf = new tV(new ArrayBuffer(6)) } IsSame(t) { return !!this.m_sMacBuf.isSame(t.m_sMacBuf) } ChildLoadBuffer() { var t = 8; let e = this.m_MemberBuf; return this.m_sMacBuf = e.getdv(t, 6), this.m_nSpeed = e.getInt(t += 6), this.m_nUsage = e.getInt(t += 4), !0 } WriteBuffer() { return this.m_MemberBuf.position(8), this.m_MemberBuf.put(this.m_sMacBuf), this.m_MemberBuf.putInt(this.m_nSpeed), this.m_MemberBuf.putInt(this.m_nUsage), !0 } }
    let mV = (() => { class t extends eV { ChildInit() { this.m_nTotalSize = 555, this.m_nTypeID = eV.IPCMESSAGE_ID_USERACTIVITY, this.m_sMacBuf = new tV(new ArrayBuffer(6)) } ID() { return this.m_sActivityName.length > 0 ? this.m_sMacStr + this.m_sActivityName + this.m_sStartTime : this.m_sDomain.length > 0 ? this.m_sMacStr + this.m_sDomain + this.m_sStartTime : this.m_sMacStr + this.m_sIP + this.m_sStartTime } setPos(t) { this.m_nPosIndex = t } GetPosition() { return this.m_nPosIndex % 2 == 0 ? "left" : "right" } GetTrafficTitle() { if (this.m_sActivityName.length > 0) return this.m_sActivityName; var t = (this.m_bTCP ? "TCP" : "UDP") + " Service Port: " + this.m_nServicePort + "User Port:" + this.m_nUserPort; return this.m_sDomain.length > 0 ? this.m_sDomain + " " + t : this.m_sIP + " " + t } IsSame(t) { return this.ID() == t.ID() } IsActive() { var t = 1e3 * this.m_nLastAccessTime; return Date.now() - t < 6e4 } SetDomainList() { this.m_DomainList = this.m_sDomain.split(" ") } SetImgs() { var e = t.m_sImgPath,
                    i = "base",
                    n = this.m_sActivityName.toLowerCase();
                n.length > 0 && (i = n), this.m_sActivityImage = e + i + ".png" } ChildLoadBuffer() { var t = 8; let e = this.m_MemberBuf;
                this.m_sMacBuf = e.getdv(t, 6), this.m_sMacStr = JB.Macbuff2Str(this.m_sMacBuf.getUintArray()), this.m_nServiceIP = e.getInt(t += 6), t += 4, this.m_bTCP = 1 == e.get(t++), this.m_nServicePort = e.getInt16(t), this.m_nUserPort = e.getInt16(t += 2); var i = e.getInt(t += 2);
                this.m_sDomain = e.getString(t += 4, i), i = e.getInt(t += eV.EVENT_NAMESIZE), this.m_sActivityName = e.getString(t += 4, i), this.m_nStartTime = e.getInt(t += eV.EVENT_NAMESIZE), this.m_nLastAccessTime = e.getInt(t += 4), this.m_nDataUsage = e.getInt(t += 4); var n = new Date(1e3 * this.m_nStartTime); if (this.m_sStartTime = JB.Get2DigiNumber(n.getHours()) + ":" + JB.Get2DigiNumber(n.getMinutes()), n = new Date(1e3 * this.m_nLastAccessTime), this.m_sLastTime = JB.Get2DigiNumber(n.getHours()) + ":" + JB.Get2DigiNumber(n.getMinutes()), this.m_nUsedMinutes = Math.round((this.m_nLastAccessTime - this.m_nStartTime) / 60), this.m_sIP = JB.int2ip(this.m_nServiceIP), this.m_nDataUsage < 1024) this.m_sDataUsage = this.m_nDataUsage.toString() + " kb";
                else { var s = JB.roundToTwo(this.m_nDataUsage / 1024);
                    this.m_sDataUsage = s.toString() + " mb" } return this.m_sRawTitle = this.m_sIP + " " + (this.m_bTCP ? "TCP" : "UDP") + " Service Port: " + this.m_nServicePort + "User Port:" + this.m_nUserPort, this.SetImgs(), this.SetDomainList(), !0 } WriteBuffer() { return this.m_MemberBuf.position(8), !0 } } return t.m_sImgPath = "assets/a/", t })(), pV = (() => { class t { constructor() {} connect(t) { return this.subject = this.create(t), console.log("Successfully connected: " + t), this.subject } create(t) { let e = new WebSocket(t);
                e.binaryType = "arraybuffer"; let i = v.create(t => (e.onmessage = t.next.bind(t), e.onerror = t.error.bind(t), e.onclose = t.complete.bind(t), e.close.bind(e))); return k.create({ next: t => { e.readyState === WebSocket.OPEN && e.send(t) } }, i) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), fV = (() => { class t { constructor() {} eventEmitter(t, e, i = null, n = null) { gtag("event", t, { event_label: i, event_category: e, value: n }) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), gV = (() => { class t { constructor(t, e, i, n, s) { this.cookieService = t, this.http = e, this.wsService = i, this.googleAnalyticsService = n, this.dialog = s, this.userchangemap = new Map, this.m_nLastVersion = 102, this.m_bCannotConnect = !1, this.m_bHasService = !1, this.m_bNeedSetup = !1, this.m_bNeedUpgrade = !1, this.userlist = new Map, this.m_AC = new dV, this.m_nBuildVersion = -1, this.m_MessageBuildVersion = new k, this.m_bRootEnabled = !1, this.m_MessageRootEnabled = new k, this.m_bResetUser = new k, this.m_bSlowScan = !1, this.m_MessageSlowScan = new Pu(new aV), this.m_bFakeMacAddress = !1, this.m_MessageFakeMac = new Pu(new aV), this.m_MessageCutMethod = new Pu(new aV), this.m_MessageDefender = new Pu(new aV), this.m_MessageFastScan = new Pu(new aV), this.m_MAC_INTMessage = new Pu(new sV), this.m_UserSpeed = new Pu(new uV), this.m_UserActivity = new Pu(new mV), this.m_bNetLock = !1, this.m_MessageNetLock = new Pu(new aV), this.m_MessageTotalSpeed = new Pu(new aV), this.m_MessageProAccount = new k, this.m_MessageProAccountID = new k, this.m_nProAccountDisable = new k, this.m_bAdBlocked = new k, this.m_bFreeCutTimeout = new k, this.m_nLastFreeCutTime = 0, this.m_bTestedAbBlock = !1, this.m_bAdBlockTestResult = !1, this.m_nBuyAction = new k, this.m_Status = new Pu(new oV), this.m_RecordsHistory = new k, this.m_sFilterName = "", this.initVersionCheck(), this.usermap = new Map, this.NewUsers = new rV("newuserlist"), this.BlackUsers = new rV("blacklist"), this.MyUsers = new rV("myuserlist"), this.userlist.set("newuserlist", this.NewUsers), this.userlist.set("blacklist", this.BlackUsers), this.userlist.set("myuserlist", this.MyUsers), this._blacklistuser = new Pu([]), this.blacklistuser = this._blacklistuser.asObservable(), this._myusers = new Pu([]), this.myusers = this._myusers.asObservable(), this._users = new Pu([]), this.users = this._users.asObservable(), this.m_MessageBuildVersion.subscribe(t => this.OnBuildVersionChange(t.m_nValue)), this.m_MessageRootEnabled.subscribe(t => this.OnRootStatusChange(1 == t.m_nValue)), this.m_MessageSlowScan.subscribe(t => this.OnSlowSCanChange(1 == t.m_nValue)), this.m_MessageFakeMac.subscribe(t => this.OnFakeMacChange(1 == t.m_nValue)), this.m_MessageDefender.subscribe(t => this.OnDefenderChange(1 == t.m_nValue)), this.m_MessageFastScan.subscribe(t => this.OnFastScanChange(1 == t.m_nValue)), this.m_MessageNetLock.subscribe((function(t) { this.m_bNetLock = 1 == t.m_nValue })), this.m_MessageProAccountID.subscribe(t => this.OnNewACInfo(t)), this.DetectAdBlocker(), this.Connect2Service(), this.Connect2Server() } OnNewACInfo(t) { this.m_AC.LoadBuffer(t.m_MemberBuf) } Connect2Server() {} Connect2Service() { this.messages = this.wsService.connect("ws://127.0.0.1:4623/").pipe(L(t => t.data)), this.messages.subscribe(t => { var e = new tV(t);
                    this.OnNewMessage(e) }, t => this.OnSocketError(), () => this.OnSocketError()) } OnSocketError() { this.m_bHasService ? (this.m_bNeedSetup = !1, this.AddStatus("Connect Service failed"), this.ResetUsers()) : this.m_bNeedSetup = !0, this.Connect2Service() } AddStatus(t) { var e = new oV;
                e.m_sMessage = t, this.m_Status.next(e) } OnBuildVersionChange(t) { this.m_nBuildVersion = t, this.m_nBuildVersion < 102 && (this.ShowServerMessage("You are running 3.0." + this.m_nBuildVersion + " Please update netcut to 3.0.102"), this.m_bNeedSetup = !0, this.m_bNeedUpgrade = !0) } OnRootStatusChange(t) { this.m_bRootEnabled = t; var e = "Netcut running under ";
                this.AddStatus(e += t ? "Admin" : "Normal user privileges, you need to reinstall netcut under admin privileges") } OnSlowSCanChange(t) { this.m_bSlowScan = t } OnFakeMacChange(t) { this.m_bFakeMacAddress = t } OnFastScanChange(t) { this.m_bFastScan = t } OnDefenderChange(t) { this.m_bDefender = t } FilterUserByName(t) { this.m_sFilterName = t, this.ReloadUser() } ResetUsers() { this.usermap.clear(), this.userchangemap.clear(), this.NewUsers.ResetList(), this.BlackUsers.ResetList(), this.MyUsers.ResetList(), this.ReloadUser(), this.m_bResetUser.next(!0) } ReloadUser() { this._users.next(this.NewUsers.GetALL(this.m_sFilterName)), this._blacklistuser.next(this.BlackUsers.GetALL(this.m_sFilterName)), this._myusers.next(this.MyUsers.GetALL(this.m_sFilterName)) } OnNewMessage(t) { var e = t.getInt(0),
                    i = t.getInt(4); switch (i) {
                    case eV.IPCMESSAGE_ID_MAC_INT_VALUE:
                        var n = new sV;
                        n.LoadBuffer(t) && this.OnNewMacIDMessage(n); break;
                    case eV.IPCMESSAGE_ID_PRO_ACCOUNT2:
                        var s = new dV;
                        s.LoadBuffer(t) && this.m_MessageProAccountID.next(s); break;
                    case eV.IPCMESSAGE_ID_PCINFO:
                        var r = new iV;
                        r.LoadBuffer(t) && (this.OnNewNetWorkNodeMessage(r), this.m_bHasService = !0, this.m_nBuildVersion >= 102 && (this.m_bNeedSetup = !1)); break;
                    case eV.IPCMESSAGE_ID_USERSPEED:
                        var a = new uV;
                        a.LoadBuffer(t) && this.m_UserSpeed.next(a); break;
                    case eV.IPCMESSAGE_ID_USERACTIVITY:
                        var o = new mV;
                        o.LoadBuffer(t) && this.m_UserActivity.next(o); break;
                    case eV.IPCMESSAGE_ID_IDVALUE:
                        var l = new aV;
                        l.LoadBuffer(t) && this.OnNewIDValueMessage(l); break;
                    case eV.IPCMESSAGE_ID_STATUS:
                        (h = new oV).LoadBuffer(t) && this.m_Status.next(h); break;
                    case eV.IPCMESSAGE_ID_USER_ONOFFLINE:
                        var c = new nV;
                        c.LoadBuffer(t) && this.m_RecordsHistory.next(c); break;
                    case eV.IPCMESSAGE_ID_MESSAGE:
                        var h;
                        (h = new lV).LoadBuffer(t) && this.ShowServerMessage(h.m_sMessage); break;
                    default:
                        console.log("my Total Len: " + e + " type :" + i) } } ShowServerMessage(t) { if (this.m_LastMessage != t) { this.m_LastMessage = t; let e = this.dialog.open(hV);
                    e.componentInstance.m_sMessage = this.m_LastMessage, e.afterClosed().subscribe(t => this.FinishShowServerMessage(t)) } } FinishShowServerMessage(t) { t == this.m_LastMessage && (this.m_LastMessage = "") } NewBuyAction(t) { this.m_nBuyAction.next(t) } IsPro() { return !this.m_AC.m_bExpired || (this.m_nProAccountDisable.next(0), !1) } SetAdblocked() { this.m_bTestedAbBlock = !0, this.m_bAdBlockTestResult = !0 } DetectAdBlocker() { if (!this.m_bTestedAbBlock) { var t = !1,
                        e = document.createElement("div");
                    e.innerHTML = "&nbsp;", e.className = "adsbox", document.body.appendChild(e), window.setTimeout((function() { 0 === e.offsetHeight && (t = !0), e.remove(), this.m_bTestedAbBlock = !0, this.m_bAdBlockTestResult = t }).bind(this), 100) } return this.m_bAdBlockTestResult } initVersionCheck() { setTimeout(() => { window.location.reload() }, 216e5) } IsAdBlocked() { return !(!this.m_AC.m_bExpired || !this.m_bAdBlockTestResult && void 0 !== window.canRunAds && 0 != window.canRunAds || (this.m_bAdBlocked.next(!0), 0)) } IfFreeCutTimeout() { if (!this.m_AC.m_bExpired) return !1;
                this.cookieService.check("nLastFreeCutTime") && (this.m_nLastFreeCutTime = parseInt(this.cookieService.get("nLastFreeCutTime"))); var t = Date.now(); return t - this.m_nLastFreeCutTime > 6e4 ? (this.m_nLastFreeCutTime = t, this.cookieService.set("nLastFreeCutTime", this.m_nLastFreeCutTime.toString()), !1) : (this.m_bFreeCutTimeout.next(!0), !0) } EnableTrail() { let t = new aV;
                t.m_nID = eV.IPCMESSAGE_ID_INT_TRAIL, t.m_nValue = 1, this.SendIPCMessage(t) } SetUserSpeed(t, e) { if (!this.usermap.get(t)) return; let i = this.usermap.get(t); if (this.IsAdBlocked()) setTimeout(() => { i.ReLoadBuffer(), this.OnNewNetWorkNodeMessage(i), this.RebuildUser(i) }, 1800);
                else if (e != eV.NETCUT_SPEEDLIMIT_UNLIMIT && this.IfFreeCutTimeout()) setTimeout(() => { i.ReLoadBuffer(), this.OnNewNetWorkNodeMessage(i), this.RebuildUser(i) }, 1800);
                else { this.googleAnalyticsService.eventEmitter("Set_speed", "NET", e.toString(), e), i.m_bIsMyUsers && e != eV.NETCUT_SPEEDLIMIT_UNLIMIT && this.SetUserMyUser(t, !1); var n = new sV; if (n.m_sMacBuf.Clone(i.m_sMacBuf.m_dv.buffer), n.m_nID = eV.IPCMESSAGE_ID_MAC_INT_SETSPEED, this.m_nBuildVersion < 99) { const t = new ArrayBuffer(4); var s = new DataView(t);
                        s.setUint16(0, e, !0), s.setUint16(2, 0, !0), n.m_nValue = s.getInt32(0, !0) } else n.m_nValue = e;
                    this.SendIPCMessage(n) } } ActionOnID(t, e) { switch (t) {
                    case eV.IPCMESSAGE_ID_INT_NETLOCK:
                        this.googleAnalyticsService.eventEmitter("NET_LOCK", "NET", e.toString(), e); break;
                    case eV.IPCMESSAGE_ID_INT_SPEEDLIMIT_ALL:
                        this.googleAnalyticsService.eventEmitter("SPEED_ALL", "NET", e.toString(), e); break;
                    case eV.IPCMESSAGE_ID_INT_SCANNETWORK:
                        this.googleAnalyticsService.eventEmitter("SCAN", "NET", "", e) } var i = new aV;
                i.m_nID = t, i.m_nValue = e, this.SendIPCMessage(i) } SendIPCMessage(t) { t.WriteBuffer(), this.OnSendMessages(t.m_MemberBuf.m_dv.buffer) } SetUserMyUser(t, e) { if (!this.usermap.get(t)) return; let i = this.usermap.get(t); var n = new sV;
                n.m_sMacBuf.Clone(i.m_sMacBuf.m_dv.buffer), n.m_nID = eV.IPCMESSAGE_ID_MAC_INT_SETMYUSER, n.m_nValue = e ? 1 : 0, n.WriteBuffer(), this.OnSendMessages(n.m_MemberBuf.m_dv.buffer) } SetUserOnline(t, e) { let i = this.usermap.get(t).GetOnOffSpeedValue();
                e && (i = eV.NETCUT_SPEEDLIMIT_UNLIMIT), this.SetUserSpeed(t, i) } GetUserbyMac(t) { return this.usermap.get(t) } BindUser(t) { return this.userchangemap.has(t) || this.userchangemap.set(t, new k), this.userchangemap.get(t) } moveuser(t, e, i, n) { if (null == this.GetUserbyMac(t)) return; let s = this.GetUserbyMac(t);
                this.userlist.has(e) && this.userlist.has(i) && (this.userlist.get(e).removeuser(s), this.userlist.get(i).insertBefore(s, n), this.ReloadUser()) } OnNewStatus(t) {} OnComputerOnOffLine(t) {} OnNewMacIDMessage(t) { switch (this.m_MAC_INTMessage.next(t), t.m_nID) {
                    case eV.IPCMESSAGE_ID_MAC_INT_OFFLINE:
                        var e = JB.Macbuff2Str(t.m_sMacBuf.getUintArray()); if (null == this.GetUserbyMac(e)) return;
                        this.OnComputerOnOffLine(this.GetUserbyMac(e)) } } OnNewIDValueMessage(t) { switch (t.m_nID) {
                    case eV.IPCMESSAGE_ID_INT_SERVICE_VERSION:
                        this.m_MessageBuildVersion.next(t), this.googleAnalyticsService.eventEmitter("Version", "Online", t.m_nValue.toString(), t.m_nValue); break;
                    case eV.IPCMESSAGE_ID_INT_SETDEFENDER:
                        this.m_MessageDefender.next(t); break;
                    case eV.IPCMESSAGE_ID_INT_NETLOCK:
                        this.m_MessageNetLock.next(t); break;
                    case eV.IPCMESSAGE_ID_INT_SPEEDLIMIT_ALL:
                        this.m_MessageTotalSpeed.next(t); break;
                    case eV.IPCMESSAGE_ID_INT_ISPROACCOUNT:
                        1 != t.m_nValue && this.m_nProAccountDisable.next(t.m_nValue); break;
                    case eV.IPCMESSAGE_ID_INT_FASTSCAN:
                        this.m_MessageFastScan.next(t); break;
                    case eV.IPCMESSAGE_ID_INT_CUTOFFMETHOD:
                        this.m_MessageCutMethod.next(t); break;
                    case eV.IPCMESSAGE_ID_INT_FAKEMAC:
                        this.m_MessageFakeMac.next(t); break;
                    case eV.IPCMESSAGE_ID_INT_SLOWSCAN:
                        this.m_MessageSlowScan.next(t); break;
                    case eV.IPCMESSAGE_ID_INT_ISROOT:
                        this.m_MessageRootEnabled.next(t); break;
                    case eV.IPCMESSAGE_ID_INT_NETWORKDOWN:
                        this.ShowServerMessage("Network down, please reconnect your computer to network"), this.ResetUsers(); break;
                    case eV.IPCMESSAGE_ID_INT_RESETUSERS:
                        this.ResetUsers() } } RebuildUser(t) { do { if (t.m_bOff) { this.MyUsers.removeuser(t), this.NewUsers.removeuser(t), this.BlackUsers.adduser(t); break } if (t.m_bIsMyUsers || t.m_bIsMyDevice || t.m_bIsGateWay) { this.BlackUsers.removeuser(t), this.NewUsers.removeuser(t), this.MyUsers.adduser(t); break } this.MyUsers.removeuser(t), this.BlackUsers.removeuser(t), this.NewUsers.adduser(t) } while (0);
                this.ReloadUser() } OnNewNetWorkNodeMessage(t) { var e = !1; if (this.usermap.has(t.m_sMacStr)) { let i = this.usermap.get(t.m_sMacStr);
                    t.m_bOff != i.m_bOff && (e = !0), t.m_bIsMyUsers == i.m_bIsMyUsers && t.m_bIsMyDevice == i.m_bIsMyDevice && t.m_bIsGateWay == i.m_bIsGateWay || (e = !0), i.LoadBuffer(t.m_MemberBuf) } else this.usermap.set(t.m_sMacStr, t), e = !0;
                this.userchangemap.has(t.m_sMacStr) || this.userchangemap.set(t.m_sMacStr, new k), this.userchangemap.get(t.m_sMacStr).next(t), e && this.RebuildUser(t) } OnSendMessages(t) { this.messages.next(t) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(Av), Xt(Mb), Xt(pV), Xt(fV), Xt(LA)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), _V = (() => { class t { constructor() { this.m_nActiveTabIndex = new k } SetActiveTabIndex(t) { this.m_nActiveTabIndex.next(t) } } return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), bV = (() => { class t { constructor(t) { this.dialogRef = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(RA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["dialog-netlock"]
            ], decls: 9, vars: 0, consts: [
                ["mat-dialog-title", "", 2, "color", "#FFFFFF"],
                ["mat-dialog-content", "", 2, "color", "#FFFFFF"],
                ["mat-dialog-actions", "", 2, "margin", "auto"],
                ["mat-button", "", 2, "display", "inline-block", "margin", "auto", "color", "#87CEEB", 3, "click"]
            ], template: function(t, e) { 1 & t && (Ia(0, "h1", 0), _o(1, "Lock/Unlock WIFI"), Ta(), Ia(2, "div", 1), _o(3, "Lock will stop NEW user access your WIFI, Unlock will resume normal"), Ta(), Ia(4, "div", 2), Ia(5, "button", 3), Ba("click", (function() { return e.dialogRef.close(!0) })), _o(6, "Lock"), Ta(), Ia(7, "button", 3), Ba("click", (function() { return e.dialogRef.close(!1) })), _o(8, "Unlock"), Ta(), Ta()) }, directives: [zA, UA, HA, fk], encapsulation: 2 }), t })(), yV = (() => { class t { constructor(t) { this.dialogRef = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(RA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["dialog-search"]
            ], decls: 13, vars: 0, consts: [
                ["mat-dialog-title", "", 2, "color", "#FFFFFF"],
                ["mat-dialog-content", "", 2, "color", "#87CEEB"],
                [2, "width", "100%"],
                ["matInput", "", "placeholder", "Name Or IP or mac or Brand", 3, "keyup", "keyup.enter"],
                ["box", ""],
                ["mat-dialog-actions", ""],
                ["mat-button", "", 2, "color", "#87CEEB", 3, "click"],
                ["autofocus", "", "mat-button", "", 2, "color", "#87CEEB", 3, "click"]
            ], template: function(t, e) { if (1 & t) { const t = Fa();
                    Ia(0, "h1", 0), _o(1, "Search Users"), Ta(), Ia(2, "div", 1), _o(3, "Input name,brand,IP,mac to display match users"), Ta(), Ia(4, "div", 1), Ia(5, "mat-form-field", 2), Ia(6, "input", 3, 4), Ba("keyup", (function() { return 0 }))("keyup.enter", (function() { Qe(t); const i = xa(7); return e.dialogRef.close(i.value) })), Ta(), Ta(), Ta(), Ia(8, "div", 5), Ia(9, "button", 6), Ba("click", (function() { Qe(t); const i = xa(7); return e.dialogRef.close(i.value) })), _o(10, "Search"), Ta(), Ia(11, "button", 7), Ba("click", (function() { return e.dialogRef.close(null) })), _o(12, "Cancel"), Ta(), Ta() } }, directives: [zA, UA, TE, VE, HA, fk], encapsulation: 2 }), t })();
    const vV = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "*", transform: "translate3d(0, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .2 }), Uw({ transform: "translate3d(0, -30px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .4 }), Uw({ transform: "translate3d(0, -30px, 0)", easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", offset: .43 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", offset: .53 }), Uw({ transform: "translate3d(0, -15px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .7 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "cubic-bezier(0.755, 0.05, 0.855, 0.06)", offset: .8 }), Uw({ transform: "translate3d(0, -4px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .9 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function wV(t) { return Lw(t && t.anchor || "bounce", [Gw(`0 ${t&&t.direction||"<=>"} 1`, [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "transform-origin": "center bottom" }), qw(vV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function CV(t) { return Lw(t && t.anchor || "bounceOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ visibility: "hidden" }), Vw([Uw({ "transform-origin": "center bottom" }), qw(vV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const xV = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "*", opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 0, easing: "ease", offset: .25 }), Uw({ opacity: 1, easing: "ease", offset: .5 }), Uw({ opacity: 0, easing: "ease", offset: .75 }), Uw({ opacity: 1, easing: "ease", offset: 1 })]))]);

    function SV(t) { return Lw(t && t.anchor || "flash", [Gw(`0 ${t&&t.direction||"<=>"} 1`, [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(xV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function kV(t) { return Lw(t && t.anchor || "flashOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ visibility: "hidden" }), Vw([qw(xV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const EV = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "*", transform: "scale3d(1, 1, 1)", easing: "ease", offset: 0 }), Uw({ transform: "scale3d({{scale}}, {{scale}}, {{scale}})", easing: "ease", offset: .5 }), Uw({ transform: "scale3d(1, 1, 1)", easing: "ease", offset: 1 })]))]);

    function DV(t) { return Lw(t && t.anchor || "pulse", [Gw(`0 ${t&&t.direction||"<=>"} 1`, [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(EV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, scale: t && t.scale || 1.05 } })]) }

    function AV(t) { return Lw(t && t.anchor || "pulseOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ visibility: "hidden" }), Vw([qw(EV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, scale: t && t.scale || 1.05 } })]) }
    const IV = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "*", transform: "scale3d(1, 1, 1)", easing: "ease", offset: 0 }), Uw({ transform: "scale3d(1.25, 0.75, 1)", easing: "ease", offset: .3 }), Uw({ transform: "scale3d(0.75, 1.25, 1)", easing: "ease", offset: .4 }), Uw({ transform: "scale3d(1.15, 0.85, 1)", easing: "ease", offset: .5 }), Uw({ transform: "scale3d(0.95, 1.05, 1)", easing: "ease", offset: .65 }), Uw({ transform: "scale3d(1.05, 0.95, 1)", easing: "ease", offset: .75 }), Uw({ transform: "scale3d(1, 1, 1)", easing: "ease", offset: 1 })]))]);

    function TV(t) { return Lw(t && t.anchor || "rubberBand", [Gw(`0 ${t&&t.direction||"<=>"} 1`, [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(IV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function OV(t) { return Lw(t && t.anchor || "rubberBandOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ visibility: "hidden" }), Vw([qw(IV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const RV = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "*", transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: .1 }), Uw({ transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: .2 }), Uw({ transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: .3 }), Uw({ transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: .4 }), Uw({ transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: .5 }), Uw({ transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: .6 }), Uw({ transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: .7 }), Uw({ transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: .8 }), Uw({ transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: .9 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function MV(t) { return Lw(t && t.anchor || "shake", [Gw(`0 ${t&&t.direction||"<=>"} 1`, [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(RV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "10px" } })]) }

    function PV(t) { return Lw(t && t.anchor || "shakeOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ visibility: "hidden" }), Vw([qw(RV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "10px" } })]) }
    const FV = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "*", transform: "rotate3d(0, 0, 1, 0deg)", easing: "ease", offset: 0 }), Uw({ transform: "rotate3d(0, 0, 1, 15deg)", easing: "ease", offset: .2 }), Uw({ transform: "rotate3d(0, 0, 1, -10deg)", easing: "ease", offset: .4 }), Uw({ transform: "rotate3d(0, 0, 1, 5deg)", easing: "ease", offset: .6 }), Uw({ transform: "rotate3d(0, 0, 1, -5deg)", easing: "ease", offset: .8 }), Uw({ transform: "rotate3d(0, 0, 1, 0deg)", easing: "ease", offset: 1 })]))]);

    function NV(t) { return Lw(t && t.anchor || "swing", [Gw(`0 ${t&&t.direction||"<=>"} 1`, [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "transform-origin": "top center" }), qw(FV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function LV(t) { return Lw(t && t.anchor || "swingOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ visibility: "hidden" }), Vw([Uw({ "transform-origin": "top center" }), qw(FV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const BV = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "*", transform: "scale3d(1, 1, 1)", easing: "ease", offset: 0 }), Uw({ transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)", easing: "ease", offset: .1 }), Uw({ transform: "scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)", easing: "ease", offset: .2 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)", easing: "ease", offset: .3 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)", easing: "ease", offset: .4 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)", easing: "ease", offset: .5 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)", easing: "ease", offset: .6 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)", easing: "ease", offset: .7 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)", easing: "ease", offset: .8 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)", easing: "ease", offset: .9 }), Uw({ transform: "scale3d(1, 1, 1)", easing: "ease", offset: 1 })]))]);

    function VV(t) { return Lw(t && t.anchor || "tada", [Gw(`0 ${t&&t.direction||"<=>"} 1`, [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(BV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function zV(t) { return Lw(t && t.anchor || "tadaOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ visibility: "hidden" }), Vw([qw(BV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const UV = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "*", transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg)", easing: "ease", offset: .15 }), Uw({ transform: "translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg)", easing: "ease", offset: .3 }), Uw({ transform: "translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg)", easing: "ease", offset: .45 }), Uw({ transform: "translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg)", easing: "ease", offset: .6 }), Uw({ transform: "translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg)", easing: "ease", offset: .75 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function HV(t) { return Lw(t && t.anchor || "wobble", [Gw(`0 ${t&&t.direction||"<=>"} 1`, [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(UV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function jV(t) { return Lw(t && t.anchor || "wobbleOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ visibility: "hidden" }), Vw([qw(UV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const GV = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "*", transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: .111 }), Uw({ transform: "skewX(-12.5deg) skewY(-12.5deg)", easing: "ease", offset: .222 }), Uw({ transform: "skewX(6.25deg) skewY(6.25deg)", easing: "ease", offset: .333 }), Uw({ transform: "skewX(-3.125deg) skewY(-3.125deg)", easing: "ease", offset: .444 }), Uw({ transform: "skewX(1.5625deg) skewY(1.5625deg)", easing: "ease", offset: .555 }), Uw({ transform: "skewX(-0.78125deg) skewY(-0.78125deg)", easing: "ease", offset: .666 }), Uw({ transform: "skewX(0.390625deg) skewY(0.390625deg)", easing: "ease", offset: .777 }), Uw({ transform: "skewX(-0.1953125deg) skewY(-0.1953125deg)", easing: "ease", offset: .888 }), Uw({ transform: "skewX(0deg) skewY(0deg)", easing: "ease", offset: 1 })]))]);

    function $V(t) { return Lw(t && t.anchor || "jello", [Gw(`0 ${t&&t.direction||"<=>"} 1`, [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "transform-origin": "center" }), qw(GV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function WV(t) { return Lw(t && t.anchor || "jelloOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ visibility: "hidden" }), Vw([Uw({ "transform-origin": "center" }), qw(GV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const qV = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "scale3d(0.3, 0.3, 0.3)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .2 }), Uw({ transform: "scale3d(0.9, 0.9, 0.9)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .4 }), Uw({ transform: "scale3d(1.03, 1.03, 1.03)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ transform: "scale3d(0.97, 0.97, 0.97)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .8 }), Uw({ transform: "scale3d(1, 1, 1)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })]))]));

    function YV(t) { return Lw(t && t.anchor || "bounceIn", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(qV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 750 } })]) }

    function XV(t) { return Lw(t && t.anchor || "bounceInOnEnter", [Gw(":enter", $w([Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(qV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []]), { params: { delay: t && t.delay || 0, duration: t && t.duration || 750 } })]) }
    const KV = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d(0, -{{translate}}, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ transform: "translate3d(0, 25px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ transform: "translate3d(0, -10px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .75 }), Uw({ transform: "translate3d(0, 5px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .9 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })]))]));

    function ZV(t) { return Lw(t && t.anchor || "bounceInDown", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(KV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "3000px" } })]) }

    function QV(t) { return Lw(t && t.anchor || "bounceInDownOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(KV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "3000px" } })]) }
    const JV = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d(-{{translate}}, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ transform: "translate3d(25px, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ transform: "translate3d(-10px, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .75 }), Uw({ transform: "translate3d(5px, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .9 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })]))]));

    function tz(t) { return Lw(t && t.anchor || "bounceInLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(JV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "3000px" } })]) }

    function ez(t) { return Lw(t && t.anchor || "bounceInLeftOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(JV), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "3000px" } })]) }
    const iz = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d({{translate}}, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ transform: "translate3d(-25px, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ transform: "translate3d(10px, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .75 }), Uw({ transform: "translate3d(-5px, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .9 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })]))]));

    function nz(t) { return Lw(t && t.anchor || "bounceInRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(iz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "3000px" } })]) }

    function sz(t) { return Lw(t && t.anchor || "bounceInRightOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(iz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "3000px" } })]) }
    const rz = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d(0, {{translate}}, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ transform: "translate3d(0, -20px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ transform: "translate3d(0, 10px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .75 }), Uw({ transform: "translate3d(0, -5px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .9 }), Uw({ transform: "translate3d(0, -5px, 0)", easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 0 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: .6 }), Uw({ opacity: 1, easing: "cubic-bezier(0.215, 0.61, 0.355, 1)", offset: 1 })]))]));

    function az(t) { return Lw(t && t.anchor || "bounceInUp", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(rz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "3000px" } })]) }

    function oz(t) { return Lw(t && t.anchor || "bounceInUpOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(rz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "3000px" } })]) }
    const lz = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "scale3d(1, 1, 1)", easing: "ease", offset: 0 }), Uw({ transform: "scale3d(0.9, 0.9, 0.9)", easing: "ease", offset: .2 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1)", easing: "ease", offset: .5 }), Uw({ transform: "scale3d(1.1, 1.1, 1.1)", easing: "ease", offset: .55 }), Uw({ transform: "scale3d(0.3, 0.3, 0.3)", easing: "ease", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 1, easing: "ease", offset: .55 }), Uw({ opacity: 0, easing: "ease", offset: 1 })]))]));

    function cz(t) { return Lw(t && t.anchor || "bounceOut", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(lz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 750 } })]) }

    function hz(t) { return Lw(t && t.anchor || "bounceOutOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(lz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 750 } })]) }
    const dz = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(0, 10px, 0)", easing: "ease", offset: .2 }), Uw({ transform: "translate3d(0, -20px, 0)", easing: "ease", offset: .4 }), Uw({ transform: "translate3d(0, -20px, 0)", easing: "ease", offset: .45 }), Uw({ transform: "translate3d(0, {{translate}}, 0)", easing: "ease", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 1, easing: "ease", offset: .45 }), Uw({ opacity: 0, easing: "ease", offset: 1 })]))]));

    function uz(t) { return Lw(t && t.anchor || "bounceOutDown", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(dz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function mz(t) { return Lw(t && t.anchor || "bounceOutDownOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(dz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const pz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(20px, 0, 0)", easing: "ease", offset: .2 }), Uw({ opacity: 0, transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: 1 })]))]);

    function fz(t) { return Lw(t && t.anchor || "bounceOutLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(pz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function gz(t) { return Lw(t && t.anchor || "bounceOutLeftOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(pz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const _z = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(-20px, 0, 0)", easing: "ease", offset: .2 }), Uw({ opacity: 0, transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: 1 })]))]);

    function bz(t) { return Lw(t && t.anchor || "bounceOutRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(_z), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function yz(t) { return Lw(t && t.anchor || "bounceOutRightOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(_z), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const vz = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(0, -10px, 0)", easing: "ease", offset: .2 }), Uw({ transform: "translate3d(0, 20px, 0)", easing: "ease", offset: .4 }), Uw({ transform: "translate3d(0, 20px, 0)", easing: "ease", offset: .45 }), Uw({ transform: "translate3d(0, -{{translate}}, 0)", easing: "ease", offset: 1 })])), $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 1, easing: "ease", offset: .45 }), Uw({ opacity: 0, easing: "ease", offset: 1 })]))])]));

    function wz(t) { return Lw(t && t.anchor || "bounceOutUp", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(vz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function Cz(t) { return Lw(t && t.anchor || "bounceOutUpOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(vz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const xz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, easing: "ease", offset: 0 }), Uw({ opacity: 1, easing: "ease", offset: 1 })]))]);

    function Sz(t) { return Lw(t && t.anchor || "fadeIn", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(xz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function kz(t) { return Lw(t && t.anchor || "fadeInOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(xz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const Ez = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d(0, -{{translate}}, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function Dz(t) { return Lw(t && t.anchor || "fadeInDown", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Ez), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function Az(t) { return Lw(t && t.anchor || "fadeInDownOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Ez), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const Iz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d(0, -{{translate}}, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function Tz(t) { return Lw(t && t.anchor || "fadeInDownBig", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Iz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function Oz(t) { return Lw(t && t.anchor || "fadeInDownBigOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Iz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const Rz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function Mz(t) { return Lw(t && t.anchor || "fadeInLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Rz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function Pz(t) { return Lw(t && t.anchor || "fadeInLeftOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Rz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const Fz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function Nz(t) { return Lw(t && t.anchor || "fadeInLeftBig", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Fz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function Lz(t) { return Lw(t && t.anchor || "fadeInLeftBigOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Fz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const Bz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function Vz(t) { return Lw(t && t.anchor || "fadeInRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Bz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function zz(t) { return Lw(t && t.anchor || "fadeInRightOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Bz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const Uz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function Hz(t) { return Lw(t && t.anchor || "fadeInRightBig", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Uz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function jz(t) { return Lw(t && t.anchor || "fadeInRightBigOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Uz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const Gz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d(0, {{translate}}, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function $z(t) { return Lw(t && t.anchor || "fadeInUp", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Gz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function Wz(t) { return Lw(t && t.anchor || "fadeInUpOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Gz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const qz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d(0, {{translate}}, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function Yz(t) { return Lw(t && t.anchor || "fadeInUpBig", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(qz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function Xz(t) { return Lw(t && t.anchor || "fadeInUpBigOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(qz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const Kz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 0, easing: "ease", offset: 1 })]))]);

    function Zz(t) { return Lw(t && t.anchor || "fadeOut", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Kz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function Qz(t) { return Lw(t && t.anchor || "fadeOutOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Kz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const Jz = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "translate3d(0, {{translate}}, 0)", easing: "ease", offset: 1 })]))]);

    function tU(t) { return Lw(t && t.anchor || "fadeOutDown", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Jz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function eU(t) { return Lw(t && t.anchor || "fadeOutDownOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Jz), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const iU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "translate3d(0, {{translate}}, 0)", easing: "ease", offset: 1 })]))]);

    function nU(t) { return Lw(t && t.anchor || "fadeOutDownBig", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(iU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function sU(t) { return Lw(t && t.anchor || "fadeOutDownBigOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(iU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const rU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: 1 })]))]);

    function aU(t) { return Lw(t && t.anchor || "fadeOutLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(rU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function oU(t) { return Lw(t && t.anchor || "fadeOutLeftOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(rU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const lU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: 1 })]))]);

    function cU(t) { return Lw(t && t.anchor || "fadeOutLeftBig", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(lU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function hU(t) { return Lw(t && t.anchor || "fadeOutLeftBigOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(lU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const dU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: 1 })]))]);

    function uU(t) { return Lw(t && t.anchor || "fadeOutRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(dU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function mU(t) { return Lw(t && t.anchor || "fadeOutRightOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(dU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const pU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: 1 })]))]);

    function fU(t) { return Lw(t && t.anchor || "fadeOutRightBig", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(pU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function gU(t) { return Lw(t && t.anchor || "fadeOutRightBigOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(pU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const _U = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "translate3d(0, -{{translate}}, 0)", easing: "ease", offset: 1 })]))]);

    function bU(t) { return Lw(t && t.anchor || "fadeOutUp", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(_U), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function yU(t) { return Lw(t && t.anchor || "fadeOutUpOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(_U), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const vU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "translate3d(0, -{{translate}}, 0)", easing: "ease", offset: 1 })]))]);

    function wU(t) { return Lw(t && t.anchor || "fadeOutUpBig", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(vU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }

    function CU(t) { return Lw(t && t.anchor || "fadeOutUpBigOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(vU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "2000px" } })]) }
    const xU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg)", easing: "ease-out", offset: 0 }), Uw({ transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg)", easing: "ease-out", offset: .4 }), Uw({ transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg)", easing: "ease-out", offset: .5 }), Uw({ transform: "perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)", easing: "ease-in", offset: .8 }), Uw({ transform: "perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)", easing: "ease-in", offset: 1 })]))]);

    function SU(t) { return Lw(t && t.anchor || "flip", [Gw("0 <=> 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(xU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function kU(t) { return Lw(t && t.anchor || "flipOnEnter", [Gw(":enter", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(xU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const EU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", transform: "perspective(400px) rotate3d(1, 0, 0, {{degrees}}deg)", opacity: 0, easing: "ease-in", offset: 0 }), Uw({ transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)", opacity: .5, easing: "ease-in", offset: .4 }), Uw({ transform: "perspective(400px) rotate3d(1, 0, 0, 10deg)", opacity: 1, easing: "ease-in", offset: .6 }), Uw({ transform: "perspective(400px) rotate3d(1, 0, 0, -5deg)", easing: "ease", offset: .8 }), Uw({ transform: "perspective(400px)", easing: "ease", offset: 1 })]))]);

    function DU(t) { return Lw(t && t.anchor || "flipInX", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(EU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 90 } })]) }

    function AU(t) { return Lw(t && t.anchor || "flipInXOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(EU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 90 } })]) }
    const IU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", transform: "perspective(400px) rotate3d(0, 1, 0, {{degrees}}deg)", opacity: 0, easing: "ease-in", offset: 0 }), Uw({ transform: "perspective(400px) rotate3d(0, 1, 0, -20deg)", opacity: .5, easing: "ease-in", offset: .4 }), Uw({ transform: "perspective(400px) rotate3d(0, 1, 0, 10deg)", opacity: 1, easing: "ease-in", offset: .6 }), Uw({ transform: "perspective(400px) rotate3d(0, 1, 0, -5deg)", easing: "ease", offset: .8 }), Uw({ transform: "perspective(400px)", easing: "ease", offset: 1 })]))]);

    function TU(t) { return Lw(t && t.anchor || "flipInY", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(IU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 90 } })]) }

    function OU(t) { return Lw(t && t.anchor || "flipInYOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(IU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 90 } })]) }
    const RU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "perspective(400px)", opacity: 1, easing: "ease", offset: 0 }), Uw({ transform: "perspective(400px) rotate3d(1, 0, 0, -20deg)", opacity: 1, easing: "ease", offset: .3 }), Uw({ transform: "perspective(400px) rotate3d(1, 0, 0, {{degrees}}deg)", opacity: 0, easing: "ease", offset: 1 })]))]);

    function MU(t) { return Lw(t && t.anchor || "flipOutX", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(RU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 750, degrees: t && t.degrees || 90 } })]) }

    function PU(t) { return Lw(t && t.anchor || "flipOutXOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(RU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 750, degrees: t && t.degrees || 90 } })]) }
    const FU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "perspective(400px)", opacity: 1, easing: "ease", offset: 0 }), Uw({ transform: "perspective(400px) rotate3d(0, 1, 0, -15deg)", opacity: 1, easing: "ease", offset: .3 }), Uw({ transform: "perspective(400px) rotate3d(0, 1, 0, {{degrees}}deg)", opacity: 0, easing: "ease", offset: 1 })]))]);

    function NU(t) { return Lw(t && t.anchor || "flipOutY", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(FU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 750, degrees: t && t.degrees || 90 } })]) }

    function LU(t) { return Lw(t && t.anchor || "flipOutYOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ "backface-visibility": "visible" }), qw(FU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 750, degrees: t && t.degrees || 90 } })]) }
    const BU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d({{translate}}, 0, 0) skewX(-30deg)", easing: "ease-out", offset: 0 }), Uw({ opacity: 1, transform: "skewX(20deg)", easing: "ease-out", offset: .6 }), Uw({ opacity: 1, transform: "skewX(-5deg)", easing: "ease-out", offset: .8 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0)", easing: "ease-out", offset: 1 })]))]);

    function VU(t) { return Lw(t && t.anchor || "lightSpeedIn", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(BU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function zU(t) { return Lw(t && t.anchor || "lightSpeedInOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(BU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const UU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease-in", offset: 0 }), Uw({ opacity: 0, transform: "translate3d({{translate}}, 0, 0) skewX(30deg)", easing: "ease-in", offset: 1 })]))]);

    function HU(t) { return Lw(t && t.anchor || "lightSpeedOut", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(UU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function jU(t) { return Lw(t && t.anchor || "lightSpeedOutOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(UU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const GU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "rotate({{degrees}}deg)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "rotate(0deg)", easing: "ease", offset: 1 })]))]);

    function $U(t) { return Lw(t && t.anchor || "rotateIn", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "center" }), Vw([qw(GU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -200 } })]) }

    function WU(t) { return Lw(t && t.anchor || "rotateInOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "center" }), Vw([qw(GU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -200 } })]) }
    const qU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "rotate3d(0, 0, 1, 0deg)", easing: "ease", offset: 1 })]))]);

    function YU(t) { return Lw(t && t.anchor || "rotateInDownLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "left bottom" }), Vw([qw(qU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -45 } })]) }

    function XU(t) { return Lw(t && t.anchor || "rotateInDownLeftOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "left bottom" }), Vw([qw(qU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -45 } })]) }
    const KU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "rotate3d(0, 0, 1, 0deg)", easing: "ease", offset: 1 })]))]);

    function ZU(t) { return Lw(t && t.anchor || "rotateInDownRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "right bottom" }), Vw([qw(KU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 45 } })]) }

    function QU(t) { return Lw(t && t.anchor || "rotateInDownRightOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "right bottom" }), Vw([qw(KU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 45 } })]) }
    const JU = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "rotate3d(0, 0, 1, 0deg)", easing: "ease", offset: 1 })]))]);

    function tH(t) { return Lw(t && t.anchor || "rotateInUpLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "left bottom" }), Vw([qw(JU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 45 } })]) }

    function eH(t) { return Lw(t && t.anchor || "rotateInUpLeftOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "left bottom" }), Vw([qw(JU), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 45 } })]) }
    const iH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "rotate3d(0, 0, 1, 0deg)", easing: "ease", offset: 1 })]))]);

    function nH(t) { return Lw(t && t.anchor || "rotateInUpRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "right bottom" }), Vw([qw(iH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -90 } })]) }

    function sH(t) { return Lw(t && t.anchor || "rotateInUpRightOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "right bottom" }), Vw([qw(iH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -90 } })]) }
    const rH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "rotate({{degrees}}deg)", easing: "ease", offset: 1 })]))]);

    function aH(t) { return Lw(t && t.anchor || "rotateOut", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "center" }), Vw([qw(rH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 200 } })]) }

    function oH(t) { return Lw(t && t.anchor || "rotateOutOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "center" }), Vw([qw(rH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 200 } })]) }
    const lH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 1 })]))]);

    function cH(t) { return Lw(t && t.anchor || "rotateOutDownLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "left bottom" }), Vw([qw(lH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 45 } })]) }

    function hH(t) { return Lw(t && t.anchor || "rotateOutDownLeftOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "left bottom" }), Vw([qw(lH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 45 } })]) }
    const dH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 1 })]))]);

    function uH(t) { return Lw(t && t.anchor || "rotateOutDownRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "right bottom" }), Vw([qw(dH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -45 } })]) }

    function mH(t) { return Lw(t && t.anchor || "rotateOutDownRightOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "right bottom" }), Vw([qw(dH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -45 } })]) }
    const pH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 1 })]))]);

    function fH(t) { return Lw(t && t.anchor || "rotateOutUpLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "left bottom" }), Vw([qw(pH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -45 } })]) }

    function gH(t) { return Lw(t && t.anchor || "rotateOutUpLeftOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "left bottom" }), Vw([qw(pH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -45 } })]) }
    const _H = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 1 })]))]);

    function bH(t) { return Lw(t && t.anchor || "rotateOutUpRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "right bottom" }), Vw([qw(_H), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 90 } })]) }

    function yH(t) { return Lw(t && t.anchor || "rotateOutUpRightOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Uw({ "transform-origin": "right bottom" }), Vw([qw(_H), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 90 } })]) }
    const vH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", transform: "translate3d(0, -{{translate}}, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function wH(t) { return Lw(t && t.anchor || "slideInDown", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ visibility: "visible" }), qw(vH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function CH(t) { return Lw(t && t.anchor || "slideInDownOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(vH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const xH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", transform: "translate3d(-{{translate}}, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function SH(t) { return Lw(t && t.anchor || "slideInLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ visibility: "visible" }), qw(xH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function kH(t) { return Lw(t && t.anchor || "slideInLeftOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(xH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const EH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", transform: "translate3d({{translate}}, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function DH(t) { return Lw(t && t.anchor || "slideInRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ visibility: "visible" }), qw(EH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function AH(t) { return Lw(t && t.anchor || "slideInRightOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(EH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const IH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", transform: "translate3d(0, {{translate}}, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 1 })]))]);

    function TH(t) { return Lw(t && t.anchor || "slideInUp", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Uw({ visibility: "visible" }), qw(IH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function OH(t) { return Lw(t && t.anchor || "slideInUpOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(IH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const RH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(0, {{translate}}, 0)", visibility: "hidden", easing: "ease", offset: 1 })]))]);

    function MH(t) { return Lw(t && t.anchor || "slideOutDown", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(RH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function PH(t) { return Lw(t && t.anchor || "slideOutDownOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(RH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const FH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(-{{translate}}, 0, 0)", visibility: "hidden", easing: "ease", offset: 1 })]))]);

    function NH(t) { return Lw(t && t.anchor || "slideOutLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(FH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function LH(t) { return Lw(t && t.anchor || "slideOutLeftOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(FH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const BH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d({{translate}}, 0, 0)", visibility: "hidden", easing: "ease", offset: 1 })]))]);

    function VH(t) { return Lw(t && t.anchor || "slideOutRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(BH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function zH(t) { return Lw(t && t.anchor || "slideOutRightOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(BH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const UH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "translate3d(0, 0, 0)", easing: "ease", offset: 0 }), Uw({ transform: "translate3d(0, -{{translate}}, 0)", visibility: "hidden", easing: "ease", offset: 1 })]))]);

    function HH(t) { return Lw(t && t.anchor || "slideOutUp", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(UH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }

    function jH(t) { return Lw(t && t.anchor || "slideOutUpOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(UH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, translate: t && t.translate || "100%" } })]) }
    const GH = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 0, easing: "ease", offset: 0 }), Uw({ opacity: 1, easing: "ease", offset: .5 }), Uw({ opacity: 1, easing: "ease", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", transform: "scale3d(0.3, 0.3, 0.3)", easing: "ease", offset: 0 }), Uw({ transform: "scale3d(1, 1, 1)", easing: "ease", offset: 1 })]))]));

    function $H(t) { return Lw(t && t.anchor || "zoomIn", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(GH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function WH(t) { return Lw(t && t.anchor || "zoomInOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(GH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const qH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)", easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)", offset: .6 }), Uw({ opacity: 1, transform: "scale3d(1, 1, 1) translate3d(0, 0, 0)", easing: "cubic-bezier(0.175, 0.885, 0.32, 1)", offset: 1 })]))]);

    function YH(t) { return Lw(t && t.anchor || "zoomInDown", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(qH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function XH(t) { return Lw(t && t.anchor || "zoomInDownOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(qH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const KH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "scale3d(0.1, 0.1, 0.1) translate3d(-3000px, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0)", easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)", offset: .6 }), Uw({ opacity: 1, transform: "scale3d(1, 1, 1) translate3d(0, 0, 0)", easing: "cubic-bezier(0.175, 0.885, 0.32, 1)", offset: 1 })]))]);

    function ZH(t) { return Lw(t && t.anchor || "zoomInLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(KH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function QH(t) { return Lw(t && t.anchor || "zoomInLeftOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(KH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const JH = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0)", easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)", offset: .6 }), Uw({ opacity: 1, transform: "scale3d(1, 1, 1) translate3d(0, 0, 0)", easing: "cubic-bezier(0.175, 0.885, 0.32, 1)", offset: 1 })]))]);

    function tj(t) { return Lw(t && t.anchor || "zoomInRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(JH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function ej(t) { return Lw(t && t.anchor || "zoomInRightOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(JH), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const ij = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)", easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)", offset: .6 }), Uw({ opacity: 1, transform: "scale3d(1, 1, 1) translate3d(0, 0, 0)", easing: "cubic-bezier(0.175, 0.885, 0.32, 1)", offset: 1 })]))]);

    function nj(t) { return Lw(t && t.anchor || "zoomInUp", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(ij), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function sj(t) { return Lw(t && t.anchor || "zoomInUpOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(ij), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const rj = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "scale3d(1, 1, 1)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "scale3d(0.3, 0.3, 0.3)", easing: "ease", offset: .5 }), Uw({ opacity: 0, easing: "ease", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ transform: "scale3d(1, 1, 1)", easing: "ease", offset: 0 }), Uw({ transform: "scale3d(0.3, 0.3, 0.3)", easing: "ease", offset: .5 })]))]));

    function aj(t) { return Lw(t && t.anchor || "zoomOut", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(rj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function oj(t) { return Lw(t && t.anchor || "zoomOutOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(rj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const lj = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ "transform-origin": "center bottom", opacity: 1, transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)", easing: "ease", offset: .4 }), Uw({ "transform-origin": "center bottom", opacity: 0, transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0)", easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)", offset: 1 })]))]);

    function cj(t) { return Lw(t && t.anchor || "zoomOutDown", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(lj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function hj(t) { return Lw(t && t.anchor || "zoomOutDownOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(lj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const dj = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0)", easing: "ease", offset: .4 }), Uw({ opacity: 0, transform: "scale3d(0.1, 0.1, 0.1) translate3d(-2000px, 0, 0)", easing: "ease", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ "transform-origin": "center center", offset: 0 }), Uw({ "transform-origin": "left center", offset: .4 })]))]));

    function uj(t) { return Lw(t && t.anchor || "zoomOutLeft", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(dj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function mj(t) { return Lw(t && t.anchor || "zoomOutLeftOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(dj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const pj = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0)", easing: "ease", offset: .4 }), Uw({ opacity: 0, transform: "scale3d(0.1, 0.1, 0.1) translate3d(2000px, 0, 0)", easing: "ease", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ "transform-origin": "center center", offset: 0 }), Uw({ "transform-origin": "right center", offset: .4 })]))]));

    function fj(t) { return Lw(t && t.anchor || "zoomOutRight", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(pj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function gj(t) { return Lw(t && t.anchor || "zoomOutRightOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(pj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const _j = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ "transform-origin": "center bottom", opacity: 1, transform: "scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)", easing: "ease", offset: .4 }), Uw({ "transform-origin": "center bottom", opacity: 0, transform: "scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0)", easing: "cubic-bezier(0.55, 0.055, 0.675, 0.19)", offset: 1 })]))]);

    function bj(t) { return Lw(t && t.anchor || "zoomOutUp", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(_j), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function yj(t) { return Lw(t && t.anchor || "zoomOutUpOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(_j), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const vj = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, "transform-origin": "top left", transform: "translate3d(0, 0, 0)", easing: "ease-in-out", offset: 0 }), Uw({ opacity: 1, "transform-origin": "top left", transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out", offset: .2 }), Uw({ opacity: 1, "transform-origin": "top left", transform: "rotate3d(0, 0, 1, 60deg)", easing: "ease-in-out", offset: .4 }), Uw({ opacity: 1, "transform-origin": "top left", transform: "rotate3d(0, 0, 1, 80deg)", easing: "ease-in-out", offset: .6 }), Uw({ opacity: 1, "transform-origin": "top left", transform: "rotate3d(0, 0, 1, 60deg)", easing: "ease-in-out", offset: .8 }), Uw({ opacity: 0, "transform-origin": "top left", transform: "translate3d(0, 700px, 0)", easing: "ease-in-out", offset: 1 })]))]);

    function wj(t) { return Lw(t && t.anchor || "hinge", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(vj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 2e3 } })]) }

    function Cj(t) { return Lw(t && t.anchor || "hingeOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(vj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 2e3 } })]) }
    const xj = $w(Vw([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ "transform-origin": "center bottom", transform: "scale(0.1) rotate(30deg)", easing: "ease", offset: 0 }), Uw({ "transform-origin": "center bottom", transform: "rotate(-10deg)", easing: "ease", offset: .5 }), Uw({ "transform-origin": "center bottom", transform: "rotate(3deg)", easing: "ease", offset: .7 }), Uw({ "transform-origin": "center bottom", transform: "scale(1)", easing: "ease", offset: 1 })])), Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, offset: 0 }), Uw({ opacity: 1, offset: 1 })]))]));

    function Sj(t) { return Lw(t && t.anchor || "jackInTheBox", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(xj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }

    function kj(t) { return Lw(t && t.anchor || "jackInTheBoxOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(xj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3 } })]) }
    const Ej = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ visibility: "visible", opacity: 0, transform: "translate3d({{translate}}, 0, 0) rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 0 }), Uw({ opacity: 1, transform: "translate3d(0, 0, 0) rotate3d(0, 0, 1, 0deg)", easing: "ease", offset: 1 })]))]);

    function Dj(t) { return Lw(t && t.anchor || "rollIn", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Ej), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -120, translate: t && t.translate || "-100%" } })]) }

    function Aj(t) { return Lw(t && t.anchor || "rollInOnEnter", [Gw(":enter", [Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Ej), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || -120, translate: t && t.translate || "-100%" } })]) }
    const Ij = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ opacity: 1, transform: "translate3d(0, 0, 0) rotate3d(0, 0, 1, 0deg)", easing: "ease", offset: 0 }), Uw({ opacity: 0, transform: "translate3d({{translate}}, 0, 0) rotate3d(0, 0, 1, {{degrees}}deg)", easing: "ease", offset: 1 })]))]);

    function Tj(t) { return Lw(t && t.anchor || "rollOut", [Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Ij), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 120, translate: t && t.translate || "100%" } })]) }

    function Oj(t) { return Lw(t && t.anchor || "rollOutOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Ij), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 1e3, degrees: t && t.degrees || 120, translate: t && t.translate || "100%" } })]) }

    function Rj(t) { return Lw(t && t.anchor || "collapse", [Hw("1", Uw({ height: "0", visibility: "hidden", overflow: "hidden" })), Hw("0", Uw({ height: "*", visibility: "*", overflow: "hidden" })), Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Vw([Yw("@*", Ww(), { optional: !0 }), Bw("{{duration}}ms {{delay}}ms ease-in")]), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 200 } }), Gw("1 => 0", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Vw([Yw("@*", Ww(), { optional: !0 }), Bw("{{duration}}ms {{delay}}ms ease-out")]), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 200 } })]) }
    const Mj = $w(Bw("{{duration}}ms {{delay}}ms", jw([Uw({ height: "0", visibility: "hidden", overflow: "hidden", easing: "ease-out", offset: 0 }), Uw({ height: "*", visibility: "*", overflow: "hidden", easing: "ease-out", offset: 1 })]))), Pj = $w(Bw("{{duration}}ms {{delay}}ms", jw([Uw({ height: "0", opacity: 0, visibility: "hidden", overflow: "hidden", easing: "ease-out", offset: 0 }), Uw({ height: "*", opacity: "*", visibility: "*", overflow: "hidden", easing: "ease-out", offset: 1 })]))), Fj = $w(Bw("{{duration}}ms {{delay}}ms", jw([Uw({ height: "*", visibility: "*", overflow: "hidden", easing: "ease-in", offset: 0 }), Uw({ height: "0", visibility: "hidden", overflow: "hidden", easing: "ease-in", offset: 1 })]))), Nj = $w(Bw("{{duration}}ms {{delay}}ms", jw([Uw({ height: "*", opacity: "*", visibility: "*", overflow: "hidden", easing: "ease-in", offset: 0 }), Uw({ height: "0", opacity: 0, visibility: "hidden", overflow: "hidden", easing: "ease-in", offset: 1 })])));

    function Lj(t) { return Lw(t && t.anchor || "expandOnEnter", [Gw(":enter", $w([Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Mj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []]), { params: { delay: t && t.delay || 0, duration: t && t.duration || 200 } })]) }

    function Bj(t) { return Lw(t && t.anchor || "collapseOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Fj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 200 } })]) }

    function Vj(t) { return Lw(t && t.anchor || "fadeInExpandOnEnter", [Gw(":enter", $w([Uw({ visibility: "hidden" }), ...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Pj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []]), { params: { delay: t && t.delay || 0, duration: t && t.duration || 200 } })]) }

    function zj(t) { return Lw(t && t.anchor || "fadeOutCollapseOnLeave", [Gw(":leave", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([qw(Nj), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 200 } })]) }

    function Uj(t) { return Lw(t && t.anchor || "rotate", [Hw("0", Uw({ transform: "rotate(0deg)" })), Hw("1", Uw({ transform: "rotate({{degrees}}deg)" }), { params: { degrees: t && t.degrees || 180 } }), Gw("0 => 1", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Vw([Yw("@*", Ww(), { optional: !0 }), Bw("{{duration}}ms {{delay}}ms ease")]), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 200 } }), Gw("1 => 0", [...t && "before" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : [], Vw([Vw([Yw("@*", Ww(), { optional: !0 }), Bw("{{duration}}ms {{delay}}ms ease")]), ...t && t.animateChildren && "together" !== t.animateChildren ? [] : [Yw("@*", Ww(), { optional: !0 })]]), ...t && "after" === t.animateChildren ? [Yw("@*", Ww(), { optional: !0 })] : []], { params: { delay: t && t.delay || 0, duration: t && t.duration || 200 } })]) }
    const Hj = $w([Bw("{{duration}}ms {{delay}}ms", jw([Uw({ filter: "hue-rotate(0deg)", offset: 0 }), Uw({ filter: "hue-rotate(-360deg)", offset: 1 })]))]);

    function jj(t) { return Lw(t && t.anchor || "hueRotate", [Gw("0 <=> 1", Vw([Yw("@*", Ww(), { optional: !0 }), qw(Hj)]), { params: { delay: t && t.delay || 0, duration: t && t.duration || 3e3 } })]) }
    let Gj = (() => { class t { constructor(t) { this.m_UITabService = t, this.m_UITabService.m_nActiveTabIndex.subscribe(t => this.OnActivePageID(t)) } ngOnInit() {} OnActivePageID(t) { t == this.pageid && this.LoadAd() } LoadAd() { setTimeout(() => { try {
                        (window.adsbygoogle = window.adsbygoogle || []).push({}) } catch (L$) {} }, 2e3) } ngAfterViewInit() { this.LoadAd() } ngOnDestroy() {} } return t.\u0275fac = function(e) { return new(e || t)(Sa(_V)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["google-adsense"]
            ], inputs: { data: "data", pageid: "pageid" }, decls: 3, vars: 1, consts: [
                ["data-ad-client", "ca-pub-3867491161552624", "data-ad-format", "auto", 1, "adsbygoogle", 2, "display", "block"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div"), Oa(1, "ins", 0), Ta(), Oa(2, "br")), 2 & t && (ps(1), va("data-ad-slot", e.data)) }, encapsulation: 2 }), t })(); class $j extends eV { constructor() { super(...arguments), this.m_nDailyType = 1, this.m_nDailyStartHour = 0, this.m_nDailyStartMinues = 0, this.m_nDailyEndHour = 0, this.m_nDailyEndMinutes = 0, this.m_nOneTimeType = 0, this.m_nOneTimeStartTime = 0, this.m_nOneTimeEndTime = 0, this.m_nLeftSeconds = 0 } ChildInit() { this.m_nTotalSize = 75, this.m_nTypeID = eV.IPCMESSAGE_ID_GROUNDSETTING } ChildLoadBuffer() { return !0 } WriteBuffer() { return this.m_MemberBuf.position(8), this.m_MemberBuf.put(this.m_sMacBuf), this.m_MemberBuf.putString(this.m_sMacStr), this.m_MemberBuf.putInt(this.m_nDailyType), this.m_MemberBuf.putInt(this.m_nDailyStartHour), this.m_MemberBuf.putInt(this.m_nDailyStartMinues), this.m_MemberBuf.putInt(this.m_nDailyEndHour), this.m_MemberBuf.putInt(this.m_nDailyEndMinutes), this.m_MemberBuf.putInt(this.m_nOneTimeType), this.m_MemberBuf.putInt(this.m_nOneTimeStartTime), this.m_MemberBuf.putInt(0), this.m_MemberBuf.putInt(this.m_nOneTimeEndTime), this.m_MemberBuf.putInt(0), this.m_MemberBuf.putInt(this.m_nLeftSeconds), !0 } }

    function Wj(t, e) { if (1 & t && (Ia(0, "mat-option", 11), _o(1), Ta()), 2 & t) { const t = e.$implicit;
            Da("value", t), ps(1), yo(" ", t, " ") } }

    function qj(t, e) { if (1 & t && (Ia(0, "mat-option", 11), _o(1), Ta()), 2 & t) { const t = e.$implicit;
            Da("value", t), ps(1), yo(" ", t, " ") } }

    function Yj(t, e) { if (1 & t && (Ia(0, "mat-option", 11), _o(1), Ta()), 2 & t) { const t = e.$implicit;
            Da("value", t), ps(1), yo(" ", t, " ") } }

    function Xj(t, e) { if (1 & t && (Ia(0, "mat-option", 11), _o(1), Ta()), 2 & t) { const t = e.$implicit;
            Da("value", t), ps(1), yo(" ", t, " ") } }
    let Kj = (() => { class t { constructor(t, e) { this.dialogRef = t, this.m_NetCutMessageService = e, this.Hour24 = [], this.Minute60 = [], this.m_nOneTimeMinutes = 0 } ngOnInit() { for (var t = 0; t <= 24; t++) this.Hour24.push(t); for (t = 0; t <= 59; t++) this.Minute60.push(t);
                this.m_GroundSetting = new $j, this.m_GroundSetting.m_sMacBuf = this.m_NetCutDriver.m_sMacBuf, this.m_GroundSetting.m_sMacStr = this.m_NetCutDriver.m_sMacStr, this.m_GroundSetting.m_nDailyStartHour = this.m_NetCutDriver.m_nDailyStartHour, this.m_GroundSetting.m_nDailyStartMinues = this.m_NetCutDriver.m_nDailyStartMinues, this.m_GroundSetting.m_nDailyEndHour = this.m_NetCutDriver.m_nDailyEndHour, this.m_GroundSetting.m_nDailyEndMinutes = this.m_NetCutDriver.m_nDailyEndMinutes, 0 != this.m_NetCutDriver.m_nOneTimeEndTime && (this.m_nOneTimeMinutes = Math.floor((this.m_NetCutDriver.m_nOneTimeEndTime - JB.GetCurrentTimeSecondsGMT()) / 60)) } OnAddOneTime() { this.m_nOneTimeMinutes += 10, this.m_nOneTimeMinutes < 0 && (this.m_nOneTimeMinutes = 0) } OnRemoveOneTime() { this.m_nOneTimeMinutes -= 10, this.m_nOneTimeMinutes < 0 && (this.m_nOneTimeMinutes = 0) } ResetTimer() { this.m_nOneTimeMinutes = 0, this.m_GroundSetting.m_nDailyStartHour = 0, this.m_GroundSetting.m_nDailyStartMinues = 0, this.m_GroundSetting.m_nDailyEndHour = 0, this.m_GroundSetting.m_nDailyEndMinutes = 0, this.SetNewTimer(), this.dialogRef.close() } SetNewTimer() { this.m_GroundSetting.m_nLeftSeconds = 60 * this.m_nOneTimeMinutes, this.m_GroundSetting.m_nOneTimeStartTime = JB.GetCurrentTimeSecondsGMT(), this.m_GroundSetting.m_nOneTimeEndTime = JB.GetCurrentTimeSecondsGMT() + 60 * this.m_nOneTimeMinutes, this.m_NetCutMessageService.IsAdBlocked() || (this.m_NetCutMessageService.SendIPCMessage(this.m_GroundSetting), this.dialogRef.close()) } OnDragOverRange(t) { t.stopPropagation() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(RA), Sa(gV)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["dialog-schdule"]
            ], decls: 46, vars: 10, consts: [
                ["mat-dialog-title", "", 2, "color", "#FFFFFF"],
                [1, "user-detail-row"],
                [1, "user-detail-row-name"],
                ["placeholder", "Hour", "name", "StartHour", 3, "ngModel", "ngModelChange"],
                [3, "value", 4, "ngFor", "ngForOf"],
                ["placeholder", "Minute", "name", "StartHour", 3, "ngModel", "ngModelChange"],
                [2, "border", "1px solid #2ab934"],
                [2, "text-align", "center"],
                ["mat-button", "", 2, "font-size", "200%", "display", "inline-block", "margin", "auto", "color", "#87CEEB", 3, "click"],
                ["mat-dialog-actions", "", 2, "margin", "auto"],
                ["mat-button", "", 2, "display", "inline-block", "margin", "auto", "color", "#87CEEB", 3, "click"],
                [3, "value"]
            ], template: function(t, e) { 1 & t && (Ia(0, "h1", 0), _o(1), Ta(), Ia(2, "mat-card"), Ia(3, "p"), _o(4, "Daily offline schedule:"), Ta(), Ia(5, "div", 1), Ia(6, "span"), Ia(7, "span", 2), _o(8, "Start:"), Ta(), Ia(9, "mat-form-field"), Ia(10, "mat-select", 3), Ba("ngModelChange", (function(t) { return e.m_GroundSetting.m_nDailyStartHour = t })), Ca(11, Wj, 2, 2, "mat-option", 4), Ta(), Ta(), Ia(12, "mat-form-field"), Ia(13, "mat-select", 5), Ba("ngModelChange", (function(t) { return e.m_GroundSetting.m_nDailyStartMinues = t })), Ca(14, qj, 2, 2, "mat-option", 4), Ta(), Ta(), Ta(), Ta(), Oa(15, "p"), Ia(16, "div", 1), Ia(17, "span"), Ia(18, "span", 2), _o(19, "End:"), Ta(), Ia(20, "mat-form-field"), Ia(21, "mat-select", 3), Ba("ngModelChange", (function(t) { return e.m_GroundSetting.m_nDailyEndHour = t })), Ca(22, Yj, 2, 2, "mat-option", 4), Ta(), Ta(), Ia(23, "mat-form-field"), Ia(24, "mat-select", 5), Ba("ngModelChange", (function(t) { return e.m_GroundSetting.m_nDailyEndMinutes = t })), Ca(25, Xj, 2, 2, "mat-option", 4), Ta(), Ta(), Ta(), Ta(), Oa(26, "hr", 6), Ia(27, "p"), _o(28, "One Time offline Timer(minutes):"), Ta(), Ia(29, "div", 7), Ia(30, "button", 8), Ba("click", (function() { return e.OnAddOneTime() })), _o(31, "+"), Ta(), Ta(), Oa(32, "p"), Ia(33, "div", 7), _o(34), Ta(), Oa(35, "p"), Ia(36, "div", 7), Ia(37, "button", 8), Ba("click", (function() { return e.OnRemoveOneTime() })), _o(38, "-"), Ta(), Ta(), Ta(), Ia(39, "div", 9), Ia(40, "button", 10), Ba("click", (function() { return e.dialogRef.close() })), _o(41, "Cancel"), Ta(), Ia(42, "button", 10), Ba("click", (function() { return e.ResetTimer() })), _o(43, "Reset"), Ta(), Ia(44, "button", 10), Ba("click", (function() { return e.SetNewTimer() })), _o(45, "Set"), Ta(), Ta()), 2 & t && (ps(1), yo("Schedule offline for ", e.m_NetCutDriver.GetTitle(), ""), ps(9), Da("ngModel", e.m_GroundSetting.m_nDailyStartHour), ps(1), Da("ngForOf", e.Hour24), ps(2), Da("ngModel", e.m_GroundSetting.m_nDailyStartMinues), ps(1), Da("ngForOf", e.Minute60), ps(7), Da("ngModel", e.m_GroundSetting.m_nDailyEndHour), ps(1), Da("ngForOf", e.Hour24), ps(2), Da("ngModel", e.m_GroundSetting.m_nDailyEndMinutes), ps(1), Da("ngForOf", e.Minute60), ps(9), yo(" ", e.m_nOneTimeMinutes, " ")) }, directives: [zA, GR, TE, cT, Rg, z_, _d, fk, HA, rk], encapsulation: 2 }), t })(); class Zj extends eV { constructor() { super(...arguments), this.m_sHostname = "" } ChildInit() { this.m_nTotalSize = 273, this.m_nTypeID = eV.IPCMESSAGE_ID_SETNAME } ChildLoadBuffer() { return !0 } WriteBuffer() { this.m_MemberBuf.position(8), this.m_MemberBuf.put(this.m_sMacBuf); var t = this.m_MemberBuf.m_nPos + 255; return this.m_MemberBuf.putString(this.m_sHostname), this.m_MemberBuf.position(t), this.m_MemberBuf.putInt(this.m_sHostname.length), !0 } }

    function Qj(t, e) { 1 & t && (Ia(0, "span"), _o(1, "Network Gateway"), Ta()) }

    function Jj(t, e) { 1 & t && (Ia(0, "span"), _o(1, "This computer"), Ta()) }

    function tG(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "span"), Ia(1, "div", 2), Ia(2, "div", 7), Ia(3, "img", 10), Ba("click", (function() { return Qe(t), ja().OnOnOffLine() })), Ta(), Ia(4, "img", 10), Ba("click", (function() { return Qe(t), ja().OnTimer() })), Ta(), Ta(), Ia(5, "div", 11), Ia(6, "input", 12, 13), Ba("ngModelChange", (function(e) { return Qe(t), ja().m_nSliderValue = e }))("input", (function() { Qe(t); const e = xa(7); return ja().OnSliderMove(e.value) }))("change", (function() { Qe(t); const e = xa(7); return ja().OnSliderChange(e.value) })), Ta(), Ta(), Ta(), Ia(8, "div", 2), Ia(9, "mat-form-field"), Ia(10, "input", 14, 15), Ba("mousedown", (function() { return Qe(t), ja().OnStartInput() }))("keyup.enter", (function() { Qe(t); const e = xa(11); return ja().SetSpeedValue(e.value) }))("blur", (function() { Qe(t); const e = xa(11); return ja().SetSpeedValue(e.value) }))("mouseout", (function() { Qe(t); const e = xa(11); return ja().SetSpeedValue(e.value) })), Ta(), Ta(), Ia(12, "mat-form-field"), Ia(13, "mat-select", 16), Ba("valueChange", (function(e) { return Qe(t), ja().m_sSpeedUnit = e })), Ia(14, "mat-option", 17), _o(15), Ta(), Ia(16, "mat-option", 17), _o(17), Ta(), Ta(), Ta(), Ta(), Ta() } if (2 & t) { const t = ja();
            ps(3), qa("src", t.m_NetCutDriver.m_OnOffImg, Zn), ps(1), qa("src", t.m_NetCutDriver.m_TimerImg, Zn), ps(2), Da("ngModel", t.m_nSliderValue), ps(3), io("width", 168, "px"), Da("@rubberBand", t.animationState), ps(1), qa("value", t.m_sSpeedValue), ps(2), io("width", 168, "px"), Da("@rubberBand", t.animationState), ps(1), Da("value", t.m_sSpeedUnit), ps(1), qa("value", t.sKBITS), ps(1), yo(" ", t.sKBITS, " "), ps(1), qa("value", t.sMBITS), ps(1), yo(" ", t.sMBITS, " ") } }

    function eG(t, e) { if (1 & t && (Ia(0, "div", 2), Ia(1, "span"), Ia(2, "span", 7), _o(3, " Timer: "), Ta(), _o(4), Ta(), Ta()), 2 & t) { const t = ja();
            ps(4), yo(" ", t.m_NetCutDriver.m_sScheDuleCountDownStr, " ") } }

    function iG(t, e) { if (1 & t && (Ia(0, "div"), Oa(1, "chart-root", 18), Oa(2, "activity-root", 19), Ta()), 2 & t) { const t = ja();
            ps(1), qa("id", t.m_NetCutDriver.m_sMacStr), Da("m_NetCutDriver", t.m_NetCutDriver), ps(1), Da("m_NetCutDriver", t.m_NetCutDriver) } }

    function nG(t, e) { 1 & t && (Ia(0, "span"), Ia(1, "font", 22), _o(2, "Away:"), Ta(), Ta()) }

    function sG(t, e) { 1 & t && _o(0, "Joined:") }

    function rG(t, e) { if (1 & t && (Ia(0, "span"), Ia(1, "div", 2), Ia(2, "span"), Ia(3, "span", 7), Ca(4, nG, 3, 0, "span", 20), Ca(5, sG, 1, 0, "ng-template", null, 21, dc), Ta(), _o(7), Ta(), Ta(), Ta()), 2 & t) { const t = xa(6),
                e = ja();
            ps(4), Da("ngIf", !e.m_NetCutDriver.m_bOnline)("ngIfElse", t), ps(3), yo(" ", e.m_NetCutDriver.m_sOnOffLineTimeStamp, " ") } }
    let aG = (() => { class t { constructor(t, e, i) { this.cookieService = t, this.m_NetCutMessageService = e, this.dialog = i, this.sMBITS = "Mbits/sec", this.sKBITS = "Kbits/sec", this.sUnlimitd = "Unlimited", this.m_sTest = "test", this.m_bHasSpeed = !1, this.m_nSliderValue = 100, this.m_sSpeedValue = this.sUnlimitd, this.m_sSpeedUnit = this.sMBITS, this.SpeedUnitNames = [], this.m_sLastSpeedValue = "", this.animationState = !1, this.animationWithState = !1 } animate() { this.animationState = !1, setTimeout(() => { this.animationState = !0, this.animationWithState = !this.animationWithState }, 1) } OnDragOverRange(t) { return t.stopPropagation(), t.stopImmediatePropagation(), t.preventDefault(), !1 } OnUserUpdate() { var t = iV.Speed2Slider(this.m_NetCutDriver.m_nSpeedLimit);
                this.m_sSpeedUnit = t.sSpeedUnit, this.m_sSpeedValue = t.sSpeedValue, this.m_nSliderValue = t.nSliderValue, this.m_sLastSpeedValue = this.m_sSpeedValue } ngOnInit() { this.SpeedUnitNames.push(this.sKBITS), this.SpeedUnitNames.push(this.sMBITS), this._subscription = this.m_NetCutMessageService.BindUser(this.m_NetCutDriver.m_sMacStr).subscribe(t => { this.m_NetCutDriver.LoadBuffer(t.m_MemberBuf), this.OnUserUpdate() }), this.OnUserUpdate(), this.m_NetCutMessageService.m_UserSpeed.pipe(Gu(t => t.m_sMacBuf.isSame(this.m_NetCutDriver.m_sMacBuf))).subscribe(t => { this.m_bHasSpeed = !0 }) } OnChangeSpeedUnit() { this.m_sSpeedUnit = this.m_sSpeedUnit == this.sMBITS ? this.sKBITS : this.sMBITS } OnStartInput() { this.m_sSpeedValue == this.sUnlimitd && (this.m_sSpeedValue = "") } SetSpeedValue(t) { this.m_sLastSpeedValue != t && ("" != t ? (this.m_sLastSpeedValue = t, "" == t && (t = this.sUnlimitd), this.OnSetUserSpeed(t == this.sUnlimitd ? eV.NETCUT_SPEEDLIMIT_UNLIMIT : this.m_sSpeedUnit == this.sMBITS ? 1024 * parseInt(t) : parseInt(t))) : this.OnUserUpdate()) } SetSpeedUnit(t) { this.m_sSpeedUnit != t && (this.m_sSpeedUnit = t, this.animate()) } OnSliderMove(t) { var e = iV.SliderSpeed2Speed(t),
                    i = e.nSpeed; return this.SetSpeedUnit(e.sSpeedUnit), this.m_sSpeedValue = e.sSpeedValue, i == eV.NETCUT_SPEEDLIMIT_UNLIMIT && (i = eV.NETCUT_SPEEDLIMIT_UNLIMIT, this.animate()), 0 == i && this.animate(), this.m_NetCutDriver.m_OnOffImg = "assets/drawable/online" + iV.GetSpeedImageNumberBySpeed(e.nSpeed).toString() + ".png", e } OnSliderChange(t) { var e = this.OnSliderMove(t);
                this.OnSetUserSpeed(e.nSpeed) } OnSetUserSpeed(t) { if (this.m_NetCutDriver.m_nSpeedLimit == t) return; let e = t; if (e == eV.NETCUT_SPEEDLIMIT_CUTOFF && "y" != this.cookieService.get("bNoMessageForCut")) { let t = this.dialog.open(hV);
                    t.componentInstance.m_sMessage = "Reminder: COVID-19 , netCut help you manage home internet Speed , To see what's it's speed , use speed control to 50% or 75%. ", t.componentInstance.m_cookie = "bNoMessageForCut" } this.m_NetCutMessageService.SetUserSpeed(this.m_NetCutDriver.m_sMacStr, e) } OnTimer() { this.dialog.open(Kj).componentInstance.m_NetCutDriver = this.m_NetCutDriver } OnOnOffLine() { let t = this.m_NetCutDriver.GetOnOffSpeedValue();
                this.OnSetUserSpeed(t) } copyTextToClipboard(t) { var e = document.createElement("textarea");
                e.style.position = "fixed", e.style.top = "0", e.style.left = "0", e.style.width = "2em", e.style.height = "2em", e.style.padding = "0", e.style.border = "none", e.style.outline = "none", e.style.boxShadow = "none", e.style.background = "transparent", e.value = t, document.body.appendChild(e), e.select(); var i = t + " "; try { i += document.execCommand("copy") ? "has been copied to clipboard" : "not beable to copy to clipboard, you can copy it here", console.log("Copying text command was " + i) } catch (n) { console.log("Oops, unable to copy") } this.dialog.open(hV).componentInstance.m_sMessage = i, document.body.removeChild(e) } OnHostNameChange(t) { if (this.m_NetCutDriver.GetName() == t) return;
                this.m_sTest = t; let e = new Zj;
                e.m_sMacBuf = this.m_NetCutDriver.m_sMacBuf, e.m_sHostname = t, this.m_NetCutMessageService.SendIPCMessage(e) } OnClickInput(t, e) { t.stopPropagation() } OnClickShowHide(t, e) { var i = "inline",
                    n = document.getElementById(e);
                n.style ? i = n.style.display : window.getComputedStyle && (i = window.getComputedStyle(n, null).getPropertyValue("display")), document.getElementById(e).style.display = "none" != i ? "none" : "inline", t.stopPropagation() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Av), Sa(gV), Sa(LA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["user-detail"]
            ], inputs: { m_NetCutDriver: "m_NetCutDriver" }, decls: 40, vars: 15, consts: [
                [1, "user-detail-card"],
                [4, "ngIf"],
                [1, "user-detail-row"],
                [1, "example-full-width"],
                ["matInput", "", "placeholder", "name", 3, "value", "keyup.enter", "blur", "mouseout"],
                ["HOSTNAME", ""],
                ["class", "user-detail-row", 4, "ngIf"],
                [1, "user-detail-row-name"],
                ["src", "./assets/drawable/copy.png", 1, "netcut_button", 3, "click"],
                [3, "src"],
                [1, "netcut_button", 3, "src", "click"],
                [1, "user-detail-row-value"],
                ["type", "range", "min", "0", "max", "100", "step", "1", 1, "speedslider", 3, "ngModel", "ngModelChange", "input", "change"],
                ["SPEED", ""],
                ["matInput", "", "placeholder", "Bandwidth", "size", "10", 2, "color", "#0099CC", 3, "value", "mousedown", "keyup.enter", "blur", "mouseout"],
                ["SPEEDVALUE", ""],
                [3, "value", "valueChange"],
                [3, "value"],
                [3, "m_NetCutDriver", "id"],
                [3, "m_NetCutDriver"],
                [4, "ngIf", "ngIfElse"],
                ["elseBlock", ""],
                ["color", "#F44336"]
            ], template: function(t, e) { if (1 & t) { const t = Fa();
                    Ia(0, "mat-card", 0), Ca(1, Qj, 2, 0, "span", 1), Ca(2, Jj, 2, 0, "span", 1), Ia(3, "div", 2), Ia(4, "mat-form-field", 3), Ia(5, "input", 4, 5), Ba("keyup.enter", (function() { Qe(t); const i = xa(6); return e.OnHostNameChange(i.value) }))("blur", (function() { Qe(t); const i = xa(6); return e.OnHostNameChange(i.value) }))("mouseout", (function() { Qe(t); const i = xa(6); return e.OnHostNameChange(i.value) })), Ta(), Ta(), Ta(), Ca(7, tG, 18, 15, "span", 1), Ca(8, eG, 5, 1, "div", 6), Ca(9, iG, 3, 3, "div", 1), Ia(10, "div", 2), Ia(11, "span"), Ia(12, "span", 7), _o(13, " IP: "), Ta(), _o(14), Ta(), Ta(), Ia(15, "div", 2), Ia(16, "span"), Ia(17, "span", 7), _o(18, "MAC:"), Ta(), _o(19), Ia(20, "img", 8), Ba("click", (function() { return e.copyTextToClipboard(e.m_NetCutDriver.m_sMacStr) })), Ta(), Ta(), Ta(), Ia(21, "div", 2), Ia(22, "span"), Ia(23, "span", 7), _o(24, "Brand:"), Ta(), _o(25), Oa(26, "img", 9), Ta(), Ta(), Ia(27, "div", 2), Ia(28, "span"), Ia(29, "span", 7), _o(30, "Attacker:"), Ta(), _o(31), Oa(32, "img", 9), Ta(), Ta(), Ia(33, "div", 2), Ia(34, "span"), Ia(35, "span", 7), _o(36, "Protect:"), Ta(), _o(37), Oa(38, "img", 9), Ta(), Ta(), Ca(39, rG, 8, 3, "span", 1), Ta() } 2 & t && (ps(1), Da("ngIf", e.m_NetCutDriver.m_bIsGateWay), ps(1), Da("ngIf", e.m_NetCutDriver.m_bIsMyDevice), ps(3), qa("value", e.m_NetCutDriver.GetName()), ps(2), Da("ngIf", !e.m_NetCutDriver.m_bIsGateWay && !e.m_NetCutDriver.m_bIsMyDevice), ps(1), Da("ngIf", "" != e.m_NetCutDriver.m_sScheDuleCountDownStr), ps(1), Da("ngIf", e.m_bHasSpeed && -1 != e.m_NetCutDriver.m_nSpeedLimit), ps(5), yo(" ", e.m_NetCutDriver.m_sIPStr, " "), ps(5), yo(" ", e.m_NetCutDriver.m_sMacStr, " "), ps(6), yo(" ", e.m_NetCutDriver.m_sBrandName, " "), ps(1), qa("src", e.m_NetCutDriver.m_IconImg, Zn), ps(5), yo(" ", e.m_NetCutDriver.m_sAttackerStr, " "), ps(1), qa("src", e.m_NetCutDriver.m_attackImg, Zn), ps(5), yo(" ", e.m_NetCutDriver.m_sDefenderStr, " "), ps(1), qa("src", e.m_NetCutDriver.m_protectImg, Zn), ps(1), Da("ngIf", !e.m_NetCutDriver.m_bIsGateWay && !e.m_NetCutDriver.m_bIsMyDevice)) }, encapsulation: 2, data: { animation: [TV(), sz({ anchor: "enter1" }), sz({ anchor: "enter2", delay: 100 }), sz({ anchor: "enter3", delay: 200, animateChildren: "none" }), CV(), kV(), AV(), OV(), PV(), LV(), zV(), jV(), WV(), kU(), XV(), oz(), hz(), mz(), QV(), Cz(), ez(), sz(), gz(), yz(), kz(), Wz(), Az(), Pz(), zz(), Xz(), Oz(), Lz(), jz(), Qz(), yU(), eU(), oU(), mU(), CU(), sU(), hU(), gU(), AU(), OU(), PU(), LU(), zU(), jU(), WU(), eH(), sH(), XU(), QU(), oH(), gH(), yH(), hH(), mH(), AH(), OH(), CH(), kH(), jH(), PH(), LH(), zH(), WH(), sj(), XH(), QH(), ej(), oj(), yj(), hj(), mj(), gj(), Cj(), kj(), Aj(), Oj(), Lj({ duration: 400 }), Bj({ duration: 400 }), Vj({ duration: 400 }), zj({ duration: 400 })] } }), t })(), oG = (() => { class t { constructor(t, e) { this.m_NetCutMessageService = t, this.m_UITabService = e, this.m_bAdBlocked = new k, this.m_UITabService.m_nActiveTabIndex.subscribe(t => this.OnActivePageID(t)) } ngOnInit() {} OnActivePageID(t) { t == this.pageid && this.LoadAd() } LoadAdInit() { setTimeout(() => { try { window.googletag.display(this.m_ad_id) } catch (L$) { L$.message.includes("window.googletag.display is not a function") && this.m_NetCutMessageService.SetAdblocked() } }, 2e3) } LoadAd() { setTimeout(() => { try { window.googletag.cmd.push(window.googletag.pubads().refresh()), console.error("Banner Push Done") } catch (L$) { console.error(L$) } }, 2e3) } ngAfterViewInit() { this.LoadAdInit() } ngOnDestroy() { console.error("Banner destory") } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gV), Sa(_V)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["google-admanager"]
            ], inputs: { m_ad_id: "m_ad_id", pageid: "pageid" }, decls: 3, vars: 1, consts: [
                [2, "display", "inline-block"],
                [2, "height", "280px", "width", "336px", 3, "id"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div", 0), Oa(1, "div", 1), Ta(), Oa(2, "br")), 2 & t && (ps(1), qa("id", e.m_ad_id)) }, encapsulation: 2 }), t })();

    function lG(t, e) { 1 & t && Oa(0, "span") }

    function cG(t, e) { 1 & t && (Ia(0, "div", 31), Oa(1, "google-adsense", 32), Ta()), 2 & t && (ps(1), Da("data", 6704263514)("pageid", 0)) }

    function hG(t, e) { 1 & t && Oa(0, "span") }

    function dG(t, e) { 1 & t && (Ia(0, "div", 33), Oa(1, "google-adsense", 32), Ta()), 2 & t && (ps(1), Da("data", 4109620305)("pageid", 0)) }

    function uG(t, e) { if (1 & t && (Ia(0, "div", 34), Oa(1, "user-detail", 35), Ta()), 2 & t) { const t = e.$implicit;
            Da("id", t.m_sMacStr), ps(1), qa("id", t.m_sMacStr), Da("m_NetCutDriver", t) } }

    function mG(t, e) { 1 & t && (Ia(0, "span"), Ia(1, "div", 33), Oa(2, "google-admanager", 37), Ta(), Ta()), 2 & t && (ps(2), Da("m_ad_id", "div-gpt-ad-1548880300696-0")("pageid", 0)) }

    function pG(t, e) { if (1 & t && (Ia(0, "div", 34), Oa(1, "user-detail", 35), Ca(2, mG, 3, 2, "span", 36), Ta()), 2 & t) { const t = e.$implicit,
                i = ja();
            Da("id", t.m_sMacStr), ps(1), qa("id", t.m_sMacStr), Da("m_NetCutDriver", t), ps(1), Da("ngIf", i.m_NetCutMessageService.m_AC.m_bExpired && 1 == t.m_nIndexId) } }

    function fG(t, e) { 1 & t && (Ia(0, "span"), Ia(1, "div", 33), Oa(2, "google-adsense", 32), Ta(), Ta()), 2 & t && (ps(2), Da("data", 3029653807)("pageid", 0)) }

    function gG(t, e) { if (1 & t && (Ia(0, "div", 34), Oa(1, "user-detail", 35), Ca(2, fG, 3, 2, "span", 36), Ta()), 2 & t) { const t = e.$implicit,
                i = ja();
            Da("id", t.m_sMacStr), ps(1), qa("id", t.m_sMacStr), Da("m_NetCutDriver", t), ps(1), Da("ngIf", i.m_NetCutMessageService.m_AC.m_bExpired && t.m_nIndexId % 2 == 0) } }
    let _G = (() => { class t { constructor(t, e, i, n) { this.m_NetCutMessageService = t, this.dragulaService = e, this.dialog = i, this.snackBar = n, this.m_sLabelMyUsers = "myuserlist", this.m_sLabelUnknownUsers = "newuserlist", this.m_sLabelBlacklistUsers = "blacklist", this.m_bHasJailUser = !0, this.m_sNetLockImg = "assets/drawable/net_unlock.png", this.m_sTotalSpeedImg = "assets/drawable/totalspeed100.png", this.m_sScanImg = "assets/drawable/scan.png", this.m_sSearchImg = "assets/drawable/search.png", this.m_nTotalSpeed = eV.NETCUT_SPEEDLIMIT_UNLIMIT, this.m_nTotalSpeedDriver = eV.NETCUT_SPEEDLIMIT_UNLIMIT, this.m_bNetLock = !1, this.styleTotalSpeedUI = "none", this.styleMyUserlisttips = "block", this.styleNewUserlisttips = "block", this.styleJailedlisttips = "block", this.m_nMyUserCount = 0, this.m_nNewUserCount = 0, this.m_nJailUserCount = 0, this.m_sStatus = "", this.sMBITS = "Mbits/sec", this.sKBITS = "Kbits/sec", this.sUnlimitd = "Unlimited", this.m_sSpeedValue = this.sUnlimitd, this.m_sSpeedUnit = this.sMBITS, this.animationState = !1, this.animationWithState = !1, t.m_MessageNetLock.subscribe(t => this.OnNetLockChange(1 == t.m_nValue)), e.drop().subscribe(({ el: t, target: e, source: i, sibling: n }) => { this.onDrop([t, e, i, n]) }) } SetSpeedValue(t) { this.m_sLastSpeedValue != t && ("" != t ? (this.m_sLastSpeedValue = t, this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_SPEEDLIMIT_ALL, t == this.sUnlimitd ? eV.NETCUT_SPEEDLIMIT_UNLIMIT : this.m_sSpeedUnit == this.sMBITS ? 1024 * parseInt(t) : parseInt(t))) : this.OnTotalSpeedChange(this.m_nTotalSpeedDriver)) } OnStartInput() { this.m_sSpeedValue == this.sUnlimitd && (this.m_sSpeedValue = "") } OnClickDefender(t) { console.log(t), this.m_NetCutMessageService.m_bDefender = !!t.target.checked, this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_SETDEFENDER, this.m_NetCutMessageService.m_bDefender ? 1 : 0) } OnScan() { this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_SCANNETWORK, 1) } OnTotalSpeed() { this.styleTotalSpeedUI = "none" != this.styleTotalSpeedUI ? "none" : "block" } animate() { this.animationState = !1, setTimeout(() => { this.animationState = !0, this.animationWithState = !this.animationWithState }, 1) } OnSliderMove(t) { var e = iV.SliderSpeed2Speed(t); return e.nSpeed == eV.NETCUT_SPEEDLIMIT_UNLIMIT && this.animate(), 0 == e.nSpeed && this.animate(), this.m_sSpeedUnit != e.sSpeedUnit && this.animate(), this.m_sSpeedUnit = e.sSpeedUnit, this.m_sSpeedValue = e.sSpeedValue, this.m_sTotalSpeedImg = "assets/drawable/totalspeed" + iV.GetSpeedImageNumberBySpeed(e.nSpeed).toString() + ".png", e } OnTotalSpeedChange(t) { if (null != t) { this.m_nTotalSpeedDriver = t; var e = iV.Speed2Slider(t);
                    this.m_nTotalSpeed = e.nSliderValue, this.m_sSpeedUnit = e.sSpeedUnit, this.m_sSpeedValue = e.sSpeedValue, this.m_sTotalSpeedImg = "assets/drawable/totalspeed" + iV.GetSpeedImageNumberBySpeed(t).toString() + ".png" } } OnSetTotalSpeed(t) { var e = this.OnSliderMove(t);
                this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_SPEEDLIMIT_ALL, e.nSpeed) } SearchName(t) { this.m_sSearchImg = null != t ? "assets/drawable/search_name.png" : "assets/drawable/search.png", this.m_NetCutMessageService.FilterUserByName(t) } OnSearch() { "" != this.m_NetCutMessageService.m_sFilterName && this.SearchName(null), this.dialog.open(yV).afterClosed().subscribe(t => this.SearchName(t)) } OnNetLock() { this.dialog.open(bV).afterClosed().subscribe(t => { this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_NETLOCK, t ? 1 : 0) }) } ShowDefaultBlaclist(t) { this.m_nJailUserCount = t, this.styleJailedlisttips = 0 == t ? "block" : "none" } ShowDefaultNewUser(t) { this.m_nNewUserCount = t, this.styleNewUserlisttips = 0 == t ? "block" : "none" } ShowDefaultMyUser(t) { this.m_nMyUserCount = t, this.styleMyUserlisttips = 0 == t ? "block" : "none" } ngOnInit() { this.m_UnknownNetworkusers = this.m_NetCutMessageService.users, this.m_Mynetworkusers = this.m_NetCutMessageService.myusers, this.m_JailNetworkusers = this.m_NetCutMessageService.blacklistuser, this.m_Mynetworkusers.subscribe(t => this.ShowDefaultMyUser(t.length)), this.m_UnknownNetworkusers.subscribe(t => this.ShowDefaultNewUser(t.length)), this.m_JailNetworkusers.subscribe(t => this.ShowDefaultBlaclist(t.length)), this.m_NetCutMessageService.m_MessageTotalSpeed.subscribe(t => this.OnTotalSpeedChange(t.m_nValue)) } OnNetLockChange(t) { this.m_bNetLock = t, this.m_sNetLockImg = t ? "assets/drawable/net_lock.png" : "assets/drawable/net_unlock.png" } OnNoBlackListUser(t) { document.getElementById("OnNoBlacklistUsers").style.display = t ? "none" : "block" } onDrop(t) { let [e, i, n, s] = t; if (console.log("onDrop:"), console.log(e.id), console.log(i.id), console.log(n.id), this.m_NetCutMessageService.moveuser(e.id, n.id, i.id, null == s ? null : s.id), i != n) switch (i.id) {
                    case this.m_sLabelBlacklistUsers:
                        this.m_NetCutMessageService.SetUserMyUser(e.id, !1), this.m_NetCutMessageService.SetUserOnline(e.id, !1); break;
                    case this.m_sLabelMyUsers:
                        this.m_NetCutMessageService.SetUserMyUser(e.id, !0), this.m_NetCutMessageService.SetUserOnline(e.id, !0); break;
                    case this.m_sLabelUnknownUsers:
                        this.m_NetCutMessageService.SetUserMyUser(e.id, !1), this.m_NetCutMessageService.SetUserOnline(e.id, !0) } } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gV), Sa(WB), Sa(LA), Sa(GN)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["users-component"]
            ], decls: 75, vars: 48, consts: [
                ["id", "navbar", 1, "tab"],
                ["id", "toolbar"],
                [1, "switch"],
                ["type", "checkbox", "id", "togBtn", 3, "checked", "change"],
                [1, "slider", "round"],
                [1, "netcut_button", 3, "src", "click"],
                [4, "ngIf", "ngIfElse"],
                ["elseADsense1", ""],
                [1, "totalspeedui"],
                [1, "user-detail-row"],
                [1, "totalspeedslider"],
                ["type", "range", "min", "0", "max", "100", "step", "1", 1, "speedslider", 2, "width", "100%", 3, "value", "input", "change"],
                ["TOTALSPEED", ""],
                ["src", "assets/drawable/totalspeed0.png", 1, "netcut_button", 2, "float", "left", 3, "click"],
                ["src", "assets/drawable/totalspeed100.png", 1, "netcut_button", 2, "float", "right", 3, "click"],
                ["src", "assets/drawable/totalspeed0.png", 2, "float", "left", 3, "click"],
                ["src", "assets/drawable/totalspeed100.png", 2, "float", "right", 3, "click"],
                [2, "padding-left", "100px"],
                ["matInput", "", "placeholder", "Whole network Bandwidth", "size", "10", 2, "color", "#0099CC", 3, "value", "mousedown", "keyup.enter", "blur", "mouseout"],
                ["SPEEDVALUE", ""],
                [3, "value", "valueChange"],
                [3, "value"],
                [2, "width", "100%"],
                ["id", "main"],
                [1, "container", 3, "id", "dragula"],
                [1, "user-details-card-default"],
                ["id", "OnNoBlacklistUsers", 1, "user-details-card-default"],
                ["elseADsense", ""],
                [3, "id", 4, "ngFor", "ngForOf"],
                ["id", "OnNoUsers", 1, "user-details-card-default"],
                ["id", "OnNoTrustUsers", 1, "user-details-card-default"],
                [1, "top-card-ad"],
                [3, "data", "pageid"],
                [1, "user-detail-card-ad"],
                [3, "id"],
                [3, "m_NetCutDriver", "id"],
                [4, "ngIf"],
                [3, "m_ad_id", "pageid"]
            ], template: function(t, e) { if (1 & t) { const t = Fa();
                    Ia(0, "mat-sidenav-container"), Ia(1, "div", 0), Ia(2, "div", 1), Ia(3, "div"), Ia(4, "label", 2), Ia(5, "input", 3), Ba("change", (function(t) { return e.OnClickDefender(t) })), Ta(), Oa(6, "div", 4), Ta(), Ta(), Ia(7, "div"), Ia(8, "img", 5), Ba("click", (function() { return e.OnNetLock() })), Ta(), Ta(), Ia(9, "div"), Ia(10, "img", 5), Ba("click", (function() { return e.OnTotalSpeed() })), Ta(), Ta(), Ia(11, "div"), Ia(12, "img", 5), Ba("click", (function() { return e.OnScan() })), Ta(), Ta(), Ia(13, "div"), Ia(14, "img", 5), Ba("click", (function() { return e.OnSearch() })), Ta(), Ta(), Ta(), Ca(15, lG, 1, 0, "span", 6), Ca(16, cG, 2, 2, "ng-template", null, 7, dc), Ta(), Ia(18, "div", 8), Ia(19, "div", 9), Ia(20, "span"), Ia(21, "div", 10), Ia(22, "input", 11, 12), Ba("input", (function() { Qe(t); const i = xa(23); return e.OnSliderMove(i.value) }))("change", (function() { Qe(t); const i = xa(23); return e.OnSetTotalSpeed(i.value) })), Ta(), Ta(), Ia(24, "span"), Ia(25, "div", 10), Ia(26, "img", 13), Ba("click", (function() { return e.OnSetTotalSpeed(0) })), Ta(), Ia(27, "img", 14), Ba("click", (function() { return e.OnSetTotalSpeed(100) })), Ta(), Ta(), Ta(), Ia(28, "span"), Ia(29, "div", 10), Ia(30, "div", 15), Ba("click", (function() { return e.OnSetTotalSpeed(0) })), _o(31, "Cut OFF ALL"), Ta(), Ia(32, "div", 16), Ba("click", (function() { return e.OnSetTotalSpeed(100) })), _o(33, "Resume ALL"), Ta(), Ta(), Ta(), Ta(), Ia(34, "span", 17), Ia(35, "mat-form-field"), Ia(36, "input", 18, 19), Ba("mousedown", (function() { return e.OnStartInput() }))("keyup.enter", (function() { Qe(t); const i = xa(37); return e.SetSpeedValue(i.value) }))("blur", (function() { Qe(t); const i = xa(37); return e.SetSpeedValue(i.value) }))("mouseout", (function() { Qe(t); const i = xa(37); return e.SetSpeedValue(i.value) })), Ta(), Ta(), Ia(38, "mat-form-field"), Ia(39, "mat-select", 20), Ba("valueChange", (function(t) { return e.m_sSpeedUnit = t })), Ia(40, "mat-option", 21), _o(41), Ta(), Ia(42, "mat-option", 21), _o(43), Ta(), Ta(), Ta(), Ta(), Ta(), Ta(), Oa(44, "hr", 22), Ia(45, "div", 23), Ia(46, "article"), Ia(47, "div", 24), Ia(48, "div", 25), _o(49), Ta(), Ia(50, "div", 26), _o(51, "Drag and Drop User here to manage speed"), Ta(), Ca(52, hG, 1, 0, "span", 6), Ca(53, dG, 2, 2, "ng-template", null, 27, dc), Ca(55, uG, 2, 3, "div", 28), Ul(56, "async"), Ta(), Ta(), Ia(57, "article"), Ia(58, "div", 24), Ia(59, "div", 25), _o(60), Ta(), Ia(61, "div", 29), _o(62, "Any unknown / New users. "), Ta(), Ia(63, "p"), _o(64, "Yup, check for strangers here"), Ta(), Ca(65, pG, 3, 4, "div", 28), Ul(66, "async"), Ta(), Ta(), Ia(67, "article"), Ia(68, "div", 24), Ia(69, "div", 25), _o(70), Ta(), Ia(71, "div", 30), _o(72, "Put trusted users here, give them a name to easy remember, netcut will put gateway and your OWN PC here"), Ta(), Ca(73, gG, 3, 4, "div", 28), Ul(74, "async"), Ta(), Ta(), Ta(), Ta() } if (2 & t) { const t = xa(17),
                        i = xa(54);
                    ps(5), Da("checked", e.m_NetCutMessageService.m_bDefender), ps(3), Da("src", e.m_sNetLockImg, Zn), ps(2), Da("src", e.m_sTotalSpeedImg, Zn), ps(2), Da("src", e.m_sScanImg, Zn), ps(2), Da("src", e.m_sSearchImg, Zn), ps(1), Da("ngIf", !e.m_NetCutMessageService.m_AC.m_bExpired)("ngIfElse", t), ps(3), io("display", e.styleTotalSpeedUI), ps(4), qa("value", e.m_nTotalSpeed), ps(13), io("width", 168, "px"), Da("@rubberBand", e.animationState), ps(1), qa("value", e.m_sSpeedValue), ps(2), io("width", 168, "px"), Da("@rubberBand", e.animationState), ps(1), Da("value", e.m_sSpeedUnit), ps(1), qa("value", e.sKBITS), ps(1), yo(" ", e.sKBITS, " "), ps(1), qa("value", e.sMBITS), ps(1), yo(" ", e.sMBITS, " "), ps(4), qa("id", e.m_sLabelBlacklistUsers), Da("dragula", "first-bag"), ps(2), yo("policing :", e.m_nJailUserCount, ""), ps(1), io("display", e.styleJailedlisttips), ps(2), Da("ngIf", !e.m_NetCutMessageService.m_AC.m_bExpired)("ngIfElse", i), ps(3), Da("ngForOf", Hl(56, 42, e.m_JailNetworkusers)), ps(3), qa("id", e.m_sLabelUnknownUsers), Da("dragula", "first-bag"), ps(2), yo("other network Users: ", e.m_nNewUserCount, " "), ps(1), io("display", e.styleNewUserlisttips), ps(4), Da("ngForOf", Hl(66, 44, e.m_UnknownNetworkusers)), ps(3), qa("id", e.m_sLabelMyUsers), Da("dragula", "first-bag"), ps(2), yo("trusted users:", e.m_nMyUserCount, " "), ps(1), io("display", e.styleMyUserlisttips), ps(2), Da("ngForOf", Hl(74, 46, e.m_Mynetworkusers)) } }, directives: [SO, yd, TE, VE, cT, rk, qB, _d, Gj, aG, oG], pipes: [Fd], encapsulation: 2, data: { animation: [TV(), Qz()] } }), t })();

    function bG(t, e) { 1 & t && (Ia(0, "p"), _o(1, " Netcut need to be reinstall under local administrator privileges, Click "), Ia(2, "a", 7), _o(3, " Here see how"), Ta(), Ta()) }
    let yG = (() => { class t { constructor(t, e) { this.m_NetCutMessageService = t, this.dialog = e, this.m_sTest = "test", this.m_nCutMethod = 0, this.m_NetCutMessageService.m_MessageCutMethod.subscribe(t => this.OnCutMethodChange(t.m_nValue)) } OnCutMethodChange(t) { this.m_nCutMethod = t } IsEnabledCutOffMethod(t) { return t == this.m_nCutMethod } OnClickFastScan(t) { this.m_NetCutMessageService.IsPro() && (this.m_NetCutMessageService.m_bFastScan = t, this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_FASTSCAN, this.m_NetCutMessageService.m_bFastScan ? 1 : 0)) } OnClickFakeMac(t) { this.m_NetCutMessageService.IsPro() && (this.m_NetCutMessageService.m_bFakeMacAddress = t, this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_FAKEMAC, this.m_NetCutMessageService.m_bFakeMacAddress ? 1 : 0)) } OnClickCutMethodScan(t) {-1 != t && this.m_NetCutMessageService.IsPro() && (this.m_nCutMethod = t, this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_CUTOFFMETHOD, this.m_nCutMethod)) } OnClickSlowScan(t) { this.m_NetCutMessageService.IsPro() && (this.m_NetCutMessageService.m_bSlowScan = t, this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_SLOWSCAN, this.m_NetCutMessageService.m_bSlowScan ? 1 : 0)) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gV), Sa(LA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["options"]
            ], decls: 44, vars: 7, consts: [
                [1, "tabpage"],
                [2, "font-size", "75%"],
                [1, "option-section"],
                [2, "float", "left", "color", "white"],
                [2, "float", "right"],
                ["align", "end", "disabled", "false", 3, "checked", "change"],
                [4, "ngIf"],
                ["href", "http://www.arcai.com/run-as-administrators/"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div", 0), Ia(1, "p", 1), _o(2, " Fast scan mode ultimate scan speed "), Ta(), Ia(3, "section", 2), Ia(4, "div", 3), _o(5, "Fast Scan:"), Ta(), Ia(6, "div", 4), Ia(7, "mat-checkbox", 5), Ba("change", (function(t) { return e.OnClickFastScan(t.checked) })), Ta(), Ta(), Ta(), Oa(8, "hr"), Ia(9, "p", 1), _o(10, " Cut off method "), Ta(), Ia(11, "section", 2), Ia(12, "div", 3), _o(13, "Cut affect Gateway and User:"), Ta(), Ia(14, "div", 4), Ia(15, "mat-checkbox", 5), Ba("change", (function(t) { return e.OnClickCutMethodScan(t.checked ? 0 : -1) })), Ta(), Ta(), Ta(), Ia(16, "section", 2), Ia(17, "div", 3), _o(18, "Cut affect Gateway:"), Ta(), Ia(19, "div", 4), Ia(20, "mat-checkbox", 5), Ba("change", (function(t) { return e.OnClickCutMethodScan(t.checked ? 1 : -1) })), Ta(), Ta(), Ta(), Ia(21, "section", 2), Ia(22, "div", 3), _o(23, "Cut affect User:"), Ta(), Ia(24, "div", 4), Ia(25, "mat-checkbox", 5), Ba("change", (function(t) { return e.OnClickCutMethodScan(t.checked ? 2 : -1) })), Ta(), Ta(), Ta(), Oa(26, "hr"), Ia(27, "p", 1), _o(28, " Use random MAC during cut off "), Ta(), Ia(29, "section", 2), Ia(30, "div", 3), _o(31, "Fake MAC Address:"), Ta(), Ia(32, "div", 4), Ia(33, "mat-checkbox", 5), Ba("change", (function(t) { return e.OnClickFakeMac(t.checked) })), Ta(), Ta(), Ta(), Oa(34, "hr"), Ia(35, "p", 1), _o(36, " Slow query rate, refrain packet storm "), Ta(), Ia(37, "section", 2), Ia(38, "div", 3), _o(39, "Slow Scan:"), Ta(), Ia(40, "div", 4), Ia(41, "mat-checkbox", 5), Ba("change", (function(t) { return e.OnClickSlowScan(t.checked) })), Ta(), Ta(), Ta(), Oa(42, "hr"), Ca(43, bG, 4, 0, "p", 6), Ta()), 2 & t && (ps(7), Da("checked", e.m_NetCutMessageService.m_bFastScan), ps(8), Da("checked", e.IsEnabledCutOffMethod(0)), ps(5), Da("checked", e.IsEnabledCutOffMethod(1)), ps(5), Da("checked", e.IsEnabledCutOffMethod(2)), ps(8), Da("checked", e.m_NetCutMessageService.m_bFakeMacAddress), ps(8), Da("checked", e.m_NetCutMessageService.m_bSlowScan), ps(2), Da("ngIf", !e.m_NetCutMessageService.m_bRootEnabled)) }, directives: [Ak, yd], encapsulation: 2 }), t })(); class vG extends eV { constructor() { super(...arguments), this.m_sUser = "", this.m_sPass = "" } ChildInit() { this.m_nTotalSize = 526, this.m_nTypeID = eV.IPCMESSAGE_ID_PRO_ACCOUNT_LOGIN } ChildLoadBuffer() { return !0 } WriteBuffer() { this.m_MemberBuf.position(8); var t = this.m_MemberBuf.m_nPos + 255; return this.m_MemberBuf.putString(this.m_sUser), this.m_MemberBuf.position(t), this.m_MemberBuf.putInt(this.m_sUser.length), t = this.m_MemberBuf.m_nPos + 255, this.m_MemberBuf.putString(this.m_sPass), this.m_MemberBuf.position(t), this.m_MemberBuf.putInt(this.m_sPass.length), !0 } }
    let wG = (() => { class t { constructor(t, e) { this.dialogRef = t, this.m_NetCutMessageService = e, this.m_Login = new vG } Forget() { window.open("http://www.arcai.com/wp-login.php?action=lostpassword", "_blank") } Register() { window.open("http://www.arcai.com/wp-login.php?action=register", "_blank") } Login() { this.m_NetCutMessageService.SendIPCMessage(this.m_Login), this.dialogRef.close() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(RA), Sa(gV)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["dialog-login"]
            ], decls: 31, vars: 3, consts: [
                [2, "color", "#FFFFFF"],
                [1, "option-section"],
                [1, "option-detail-row-name"],
                ["matInput", "", "placeholder", "username", 3, "ngModel", "ngModelChange"],
                ["login", ""],
                ["type", "password", "matInput", "", "placeholder", "password", 3, "ngModel", "ngModelChange"],
                ["pass", ""],
                [2, "float", "right"],
                ["align", "end", "disabled", "false", 3, "checked", "change"],
                ["mat-dialog-actions", "", 2, "margin", "auto"],
                ["mat-button", "", 2, "display", "inline-block", "margin", "auto", "color", "#87CEEB", 3, "click"]
            ], template: function(t, e) { if (1 & t) { const t = Fa();
                    Ia(0, "p", 0), _o(1, "Login into arcai.com to transfer/restore Pro members between devices"), Ta(), Ia(2, "mat-card"), Ia(3, "section", 1), Ia(4, "span"), Ia(5, "span", 2), _o(6, "Username:"), Ta(), Ia(7, "span"), Ia(8, "mat-form-field"), Ia(9, "input", 3, 4), Ba("ngModelChange", (function(t) { return e.m_Login.m_sUser = t })), Ta(), Ta(), Ta(), Ta(), Ta(), Ia(11, "section", 1), Ia(12, "span"), Ia(13, "span", 2), _o(14, "Password:"), Ta(), Ia(15, "span"), Ia(16, "mat-form-field"), Ia(17, "input", 5, 6), Ba("ngModelChange", (function(t) { return e.m_Login.m_sPass = t })), Ta(), Ta(), Ia(19, "div", 7), Ia(20, "mat-checkbox", 8), Ba("change", (function(e) { return Qe(t), xa(18).type = e.checked ? "text" : "password" })), _o(21, " Show "), Ta(), Ta(), Ta(), Ta(), Ta(), Ta(), Ia(22, "div", 9), Ia(23, "button", 10), Ba("click", (function() { return e.Login() })), _o(24, "Login"), Ta(), Ia(25, "button", 10), Ba("click", (function() { return e.Forget() })), _o(26, "Forget Pass"), Ta(), Ia(27, "button", 10), Ba("click", (function() { return e.Register() })), _o(28, "Register"), Ta(), Ia(29, "button", 10), Ba("click", (function() { return e.dialogRef.close() })), _o(30, "Cancel"), Ta(), Ta() } 2 & t && (ps(9), Da("ngModel", e.m_Login.m_sUser), ps(8), Da("ngModel", e.m_Login.m_sPass), ps(3), Da("checked", !1)) }, directives: [GR, TE, VE, kg, Rg, z_, Ak, HA, fk], encapsulation: 2 }), t })();

    function CG(t, e) { 1 & t && (Ia(0, "span"), Ia(1, "p", 5), _o(2, "Your Pro account is expired! Pro Function is disabled"), Ta(), Ta()) }

    function xG(t, e) { 1 & t && (Ia(0, "span"), Ia(1, "p", 5), _o(2, "Your Broswer is blocking ads, speed control is disabled. please allow ads for this page"), Ta(), Ia(3, "p", 5), _o(4, " Or buy Pro account membership "), Ta(), Ta()) }

    function SG(t, e) { if (1 & t && (Ia(0, "span"), Ia(1, "h2"), _o(2), Ta(), Ia(3, "div", 6), _o(4, "Free user Speed Control every 60 seconds"), Ta(), Ia(5, "p", 5), _o(6, " Or buy Pro account membership "), Ta(), Ta()), 2 & t) { const t = ja();
            ps(2), yo("Wait ", t.countdown_second, " seconds to set new speed limit.") } }
    let kG = (() => { class t { constructor(t, e, i) { this.data = t, this.m_NetCutMessageService = e, this.dialogRef = i, this.countdown_second = 60 - Math.floor((Date.now() - e.m_nLastFreeCutTime) / 1e3), setTimeout(() => { this.CountDown() }, 1e3) } CountDown() { this.countdown_second--, this.countdown_second > 0 && setTimeout(() => { this.CountDown() }, 1e3), 3 == this.data && 0 == this.countdown_second && this.Cancel() } OnBuy(t) { this.m_NetCutMessageService.NewBuyAction(t), this.dialogRef.close() } Cancel() { this.dialogRef.close() } OnRefresh() { let t = new aV;
                t.m_nID = eV.IPCMESSAGE_ID_INT_RELOGIN, t.m_nValue = 1, this.m_NetCutMessageService.SendIPCMessage(t), this.dialogRef.close() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(MA), Sa(gV), Sa(RA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["dialog-expired"]
            ], decls: 27, vars: 5, consts: [
                [4, "ngIf"],
                [1, "option-section"],
                ["mat-button", "", 2, "display", "inline-block", "margin", "auto", "color", "#87CEEB", 3, "click"],
                [1, "user-detail-card-ad"],
                [3, "data", "pageid"],
                [2, "color", "#FFFFFF"],
                [2, "background-color", "coral", "color", "white"]
            ], template: function(t, e) { 1 & t && (Ca(0, CG, 3, 0, "span", 0), Ca(1, xG, 5, 0, "span", 0), Ca(2, SG, 7, 1, "span", 0), Ia(3, "mat-card"), Ia(4, "p"), _o(5, " Buy to extend Pro membership, Remove AD, Full Access "), Oa(6, "br"), _o(7, " Remember to Click Refresh Button after payment "), Ta(), Oa(8, "p"), Ia(9, "section", 1), Ia(10, "span"), Ia(11, "button", 2), Ba("click", (function() { return e.OnBuy(1) })), _o(12, "Buy one Month for 1$"), Ta(), Ta(), Ta(), Ia(13, "section", 1), Ia(14, "span"), Ia(15, "button", 2), Ba("click", (function() { return e.OnBuy(2) })), _o(16, "Buy One Year 9.9$ (15% off)"), Ta(), Ta(), Ta(), Ia(17, "section", 1), Ia(18, "span"), Ia(19, "button", 2), Ba("click", (function() { return e.OnRefresh() })), _o(20, "Refresh"), Ta(), Ta(), Ta(), Ia(21, "section", 1), Ia(22, "span"), Ia(23, "button", 2), Ba("click", (function() { return e.Cancel() })), _o(24, "Close"), Ta(), Ta(), Ta(), Ta(), Ia(25, "div", 3), Oa(26, "google-adsense", 4), Ta()), 2 & t && (Da("ngIf", 1 == e.data), ps(1), Da("ngIf", 2 == e.data), ps(1), Da("ngIf", 3 == e.data), ps(24), Da("data", 4109620305)("pageid", 0)) }, directives: [yd, GR, fk, Gj], encapsulation: 2 }), t })(); class EG extends eV { constructor() { super(...arguments), this.m_sIDToken = "" } ChildInit() { this.m_nTotalSize = 2060, this.m_nTypeID = eV.IPCMESSAGE_ID_GOOGLE_LOGIN } ChildLoadBuffer() { return !0 } WriteBuffer() { this.m_MemberBuf.position(8); var t = this.m_MemberBuf.m_nPos + 2048; return this.m_MemberBuf.putString(this.m_sIDToken), this.m_MemberBuf.position(t), this.m_MemberBuf.putInt(this.m_sIDToken.length), !0 } } class DG { constructor(t) { this.lazyLoad = !1, this.providers = new Map; for (let e = 0; e < t.length; e++) { let i = t[e];
                this.providers.set(i.id, i.provider), this.lazyLoad = this.lazyLoad || i.lazyLoad } } }
    let AG = (() => { class t { constructor(t) { this._user = null, this._authState = new aD(1), this._readyState = new Pu([]), this.initialized = !1, this.providers = t.providers, t.lazyLoad || this.initialize() } get authState() { return this._authState.asObservable() } get readyState() { return this._readyState.asObservable() } initialize() { this.initialized = !0, this.providers.forEach((t, e) => { t.initialize().then(() => { let i = this._readyState.getValue();
                        i.push(e), this._readyState.next(i), t.getLoginStatus().then(t => { t.provider = e, this._user = t, this._authState.next(t) }).catch(t => { this._authState.next(null) }) }) }) } signIn(e, i) { return this.initialized || this.initialize(), new Promise((n, s) => { let r = this.providers.get(e);
                    r ? r.signIn(i).then(t => { t.provider = e, n(t), this._user = t, this._authState.next(t) }).catch(t => { s(t) }) : s(t.ERR_LOGIN_PROVIDER_NOT_FOUND) }) } signOut(e = !1) { return this.initialized || this.initialize(), new Promise((i, n) => { if (this._user) { let s = this.providers.get(this._user.provider);
                        s ? s.signOut(e).then(() => { i(), this._user = null, this._authState.next(null) }).catch(t => { n(t) }) : n(t.ERR_LOGIN_PROVIDER_NOT_FOUND) } else n(t.ERR_NOT_LOGGED_IN) }) } } return t.\u0275fac = function(e) { return new(e || t)(Xt(DG)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t.ERR_LOGIN_PROVIDER_NOT_FOUND = "Login provider not found", t.ERR_NOT_LOGGED_IN = "Not logged in", t })(), IG = (() => { class t { static initialize(e) { return { ngModule: t, providers: [AG, { provide: DG, useValue: e }] } } } return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [AG], imports: [
                [Jd]
            ] }), t })(); class TG {} class OG { constructor() { this._readyState = new Pu(!1) } onReady() { return new Promise((t, e) => { this._readyState.subscribe(e => { e && t() }) }) } loadScript(t, e, i, n = !0, s = "") { if ("undefined" != typeof document && !document.getElementById(t)) { let t = document.createElement("script");
                t.async = n, t.src = e, t.onload = i, document.head.appendChild(t) } } }
    let RG = (() => { class t extends OG { constructor(t, e = { scope: "email" }) { super(), this.clientId = t, this.opt = e } initialize() { return new Promise((e, i) => { this.loadScript(t.PROVIDER_ID, "https://apis.google.com/js/platform.js", () => { gapi.load("auth2", () => { this.auth2 = gapi.auth2.init(Object.assign({}, this.opt, { client_id: this.clientId })), this.auth2.then(() => { this._readyState.next(!0), e() }).catch(t => { i(t) }) }) }) }) } getLoginStatus() { return new Promise((t, e) => { this.onReady().then(() => { if (this.auth2.isSignedIn.get()) { let e = new TG,
                                i = this.auth2.currentUser.get().getBasicProfile(),
                                n = this.auth2.currentUser.get().getAuthResponse(!0).access_token,
                                s = this.auth2.currentUser.get().getAuthResponse(!0).id_token;
                            e.id = i.getId(), e.name = i.getName(), e.email = i.getEmail(), e.photoUrl = i.getImageUrl(), e.firstName = i.getGivenName(), e.lastName = i.getFamilyName(), e.authToken = n, e.idToken = s, t(e) } else e("No user is currently logged in.") }) }) } signIn(t) { return new Promise((e, i) => { this.onReady().then(() => {
                        (t && t.offline_access || this.opt && this.opt.offline_access ? this.auth2.grantOfflineAccess(t) : this.auth2.signIn(t)).then(t => { let i = new TG,
                                n = this.auth2.currentUser.get().getBasicProfile(),
                                s = this.auth2.currentUser.get().getAuthResponse(!0).access_token,
                                r = this.auth2.currentUser.get().getAuthResponse(!0).id_token;
                            i.id = n.getId(), i.name = n.getName(), i.email = n.getEmail(), i.photoUrl = n.getImageUrl(), i.firstName = n.getGivenName(), i.lastName = n.getFamilyName(), i.authToken = s, i.idToken = r, t && t.code && (i.authorizationCode = t.code), e(i) }, t => { i("User cancelled login or did not fully authorize.") }).catch(t => { i(t) }) }) }) } signOut(t) { return new Promise((e, i) => { this.onReady().then(() => { let n;
                        n = t ? this.auth2.disconnect() : this.auth2.signOut(), n.then(t => { t ? i(t) : e() }).catch(t => { i(t) }) }) }) } } return t.PROVIDER_ID = "GOOGLE", t })(), MG = (() => { class t extends OG { constructor(t, e = { scope: "email,public_profile" }, i = "en_US", n = "name,email,picture,first_name,last_name", s = "v4.0") { super(), this.clientId = t, this.opt = e, this.locale = i, this.fields = n, this.version = s } initialize() { return new Promise((e, i) => { this.loadScript(t.PROVIDER_ID, `//connect.facebook.net/${this.locale}/sdk.js`, () => { FB.init({ appId: this.clientId, autoLogAppEvents: !0, cookie: !0, xfbml: !0, version: this.version }), this._readyState.next(!0), e() }) }) } getLoginStatus() { return new Promise((t, e) => { this.onReady().then(() => { FB.getLoginStatus(i => { if ("connected" === i.status) { let e = i.authResponse;
                                FB.api(`/me?fields=${this.fields}`, i => { let n = new TG;
                                    n.id = i.id, n.name = i.name, n.email = i.email, n.photoUrl = "https://graph.facebook.com/" + i.id + "/picture?type=normal", n.firstName = i.first_name, n.lastName = i.last_name, n.authToken = e.accessToken, n.facebook = i, t(n) }) } else e("No user is currently logged in.") }) }) }) } signIn(t) { return new Promise((t, e) => { this.onReady().then(() => { FB.login(i => { if (i.authResponse) { let e = i.authResponse;
                                FB.api(`/me?fields=${this.fields}`, i => { let n = new TG;
                                    n.id = i.id, n.name = i.name, n.email = i.email, n.photoUrl = "https://graph.facebook.com/" + i.id + "/picture?type=normal", n.firstName = i.first_name, n.lastName = i.last_name, n.authToken = e.accessToken, n.facebook = i, t(n) }) } else e("User cancelled login or did not fully authorize.") }, this.opt) }) }) } signOut() { return new Promise((t, e) => { this.onReady().then(() => { FB.logout(e => { t() }) }) }) } } return t.PROVIDER_ID = "FACEBOOK", t })(), PG = (() => { class t { constructor(t) { this.dialogRef = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(RA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["dialog-nologinbuy"]
            ], decls: 12, vars: 0, consts: [
                ["mat-dialog-actions", "", 2, "margin", "auto"],
                ["mat-button", "", 2, "display", "inline-block", "margin", "auto", "color", "#87CEEB", 3, "click"],
                ["mat-dialog-content", "", 2, "color", "#FFFFFF"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div", 0), Ia(1, "button", 1), Ba("click", (function() { return e.dialogRef.close("google") })), _o(2, "Sign with google then Buy"), Ta(), Ia(3, "button", 1), Ba("click", (function() { return e.dialogRef.close("arcai") })), _o(4, "Sign with arcai then Buy"), Ta(), Ta(), Ia(5, "div", 0), Ia(6, "button", 1), Ba("click", (function() { return e.dialogRef.close("buy") })), _o(7, "Buy"), Ta(), Ta(), Ia(8, "div", 2), _o(9, " With login , can use membership by login on to other netCut "), Oa(10, "br"), _o(11, " Without login, use membership on this device only "), Ta()) }, directives: [HA, fk, UA], encapsulation: 2 }), t })(), FG = (() => { class t { constructor(t) { this.dialogRef = t } } return t.\u0275fac = function(e) { return new(e || t)(Sa(RA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["dialog-login2buy"]
            ], decls: 5, vars: 0, consts: [
                ["mat-dialog-content", "", 2, "color", "#87CEEB"],
                ["mat-dialog-actions", "", 2, "margin", "auto"],
                ["mat-button", "", 2, "display", "inline-block", "margin", "auto", "color", "#87CEEB", 3, "click"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div", 0), _o(1, " Login in Successful!! "), Ta(), Ia(2, "div", 1), Ia(3, "button", 2), Ba("click", (function() { return e.dialogRef.close("") })), _o(4, " Continue to Buy "), Ta(), Ta()) }, directives: [UA, HA, fk], encapsulation: 2 }), t })();

    function NG(t, e) { if (1 & t && (Ia(0, "section", 1), Ia(1, "span"), Ia(2, "span", 3), _o(3, "Pro ID:"), Ta(), _o(4), Ta(), Ta()), 2 & t) { const t = ja();
            ps(4), yo(" ", t.m_AC.m_nProID, " ") } }

    function LG(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "section", 1), Ia(1, "span"), Ia(2, "img", 8), Ba("click", (function() { return Qe(t), ja().signInWithGoogle() })), Ta(), Ta(), Ta() } }

    function BG(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "section", 1), Ia(1, "span"), Ia(2, "button", 9), Ba("click", (function() { return Qe(t), ja().OnLogin() })), _o(3, "Sign in with Arcai"), Ta(), Ta(), Ta() } }

    function VG(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "section", 1), Ia(1, "span"), Ia(2, "span", 3), _o(3, "Username:"), Ta(), _o(4), Ia(5, "button", 6), Ba("click", (function() { return Qe(t), ja().signOut() })), _o(6, "Sign out"), Ta(), Ta(), Ta() } if (2 & t) { const t = ja();
            ps(4), vo(" ", t.m_AC.m_sGoogleLogin, " ", t.m_AC.m_sArcaiLogin, " ") } }

    function zG(t, e) { 1 & t && (Ia(0, "span"), Ia(1, "font", 10), _o(2, "Yes"), Ta(), Ta()) }

    function UG(t, e) { 1 & t && _o(0, "No") }
    let HG = (() => { class t { constructor(t, e, i, n) { this.authService = t, this.googleAnalyticsService = e, this.m_NetCutMessageService = i, this.dialog = n, this.m_bLoginAction = !1, this.m_nTobuyAfterLogin = 0, this.m_sTest = "test", this.m_bBuyOnline = !1, this.m_nCutMethod = 0, this.m_AC = new dV, this.m_GoogleLogin = new EG, this.m_nProFunctionDisable = 1, this.m_NetCutMessageService.m_MessageProAccountID.subscribe(t => this.OnNewACInfo(t)), this.m_NetCutMessageService.m_nProAccountDisable.subscribe(t => this.OnProFuntionDisabled(t)), this.m_NetCutMessageService.m_bAdBlocked.subscribe(t => this.OnAdBlockedNoPro(t)), this.m_NetCutMessageService.m_nBuyAction.subscribe(t => this.OnBuy(t)), this.m_NetCutMessageService.m_bFreeCutTimeout.subscribe(t => this.OnFreeCutTimeOut(t)) } OnLogin() { this.googleAnalyticsService.eventEmitter("SIGN_ARCAI", "SIGN", "", 20), this.dialog.open(wG) } OnFreeCutTimeOut(t) { this.googleAnalyticsService.eventEmitter("FreeCut", "FreeTimeout", "", 1), this.dialog.open(kG, { data: 3 }) } OnAdBlockedNoPro(t) { this.googleAnalyticsService.eventEmitter("Ad_block", "AD", "", 10), console.log("Ad blocked"), this.dialog.open(kG, { data: 2 }) } OnProFuntionDisabled(t) { 0 == t && this.dialog.open(kG, { data: 1 }) } OnRefresh() { let t = new aV;
                t.m_nID = eV.IPCMESSAGE_ID_INT_RELOGIN, t.m_nValue = 1, this.m_NetCutMessageService.SendIPCMessage(t) } OnBuy(t) { if (0 != t) { let e, i = 1 == t ? "Month" : "Year"; switch (this.m_AC.m_nAccountType) {
                        case 0:
                            e = "no login"; break;
                        case 1:
                            e = "Arcai User"; break;
                        case 2:
                            e = "Google User"; break;
                        default:
                            e = "no login" } this.googleAnalyticsService.eventEmitter("Buy_click", e, i, t) } if (0 == this.m_AC.m_nAccountType) this.dialog.open(PG).afterClosed().subscribe(e => { switch (e) {
                        case "google":
                            this.m_nTobuyAfterLogin = t, this.signInWithGoogle(); break;
                        case "arcai":
                            this.m_nTobuyAfterLogin = t, this.OnLogin(); break;
                        default:
                            var i = this.m_AC.GetBuyLink(t);
                            window.open().location.href = i } });
                else { var e = this.m_AC.GetBuyLink(t);
                    window.open(e, "_blank"), this.m_nTobuyAfterLogin = 0 } } OnNewACInfo(t) { null != this.m_AC.m_bExpired && !this.m_AC.m_bExpired && t.m_bExpired && 0 == this.m_nTobuyAfterLogin && this.dialog.open(kG, { data: 1 }), this.m_AC.LoadBuffer(t.m_MemberBuf), 0 != this.m_nTobuyAfterLogin && 0 != this.m_AC.m_nAccountType && this.dialog.open(FG).afterClosed().subscribe(t => { this.OnBuy(this.m_nTobuyAfterLogin) }) } signInWithGoogle() { this.m_bLoginAction = !0, this.googleAnalyticsService.eventEmitter("SIGN_GOOGLE", "SIGN", "", 30), this.authService.signIn(RG.PROVIDER_ID) } signInWithFB() { this.authService.signIn(MG.PROVIDER_ID) } signOut() { this.m_NetCutMessageService.SendIPCMessage(new vG) } ngOnInit() { this.authService.authState.subscribe(t => this.OnUserLogin(t)) } OnUserLogin(t) { this.m_bLoginAction && (null != t && (this.m_GoogleLogin.m_sIDToken = t.idToken, this.m_NetCutMessageService.SendIPCMessage(this.m_GoogleLogin)), this.m_bLoginAction = !1) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(AG), Sa(fV), Sa(gV), Sa(LA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["pro"]
            ], decls: 35, vars: 7, consts: [
                [1, "tabpage"],
                [1, "option-section"],
                ["class", "option-section", 4, "ngIf"],
                [1, "option-detail-row-name"],
                [4, "ngIf", "ngIfElse"],
                ["elseBlock", ""],
                ["mat-button", "", 2, "display", "inline-block", "margin", "auto", "color", "#87CEEB", 3, "click"],
                ["mat-button", "", 1, "button", 2, "display", "inline-block", "margin", "auto", "color", "#87CEEB", 3, "click"],
                ["src", "assets/drawable/googlelogin.png", 1, "a", 3, "click"],
                [1, "titlebutton", 3, "click"],
                ["color", "red"]
            ], template: function(t, e) { if (1 & t && (Ia(0, "mat-sidenav-container"), Ia(1, "div", 0), Ia(2, "section", 1), Ta(), Ca(4, NG, 5, 1, "section", 2), Ca(5, LG, 3, 0, "section", 2), Ca(6, BG, 4, 0, "section", 2), Ca(7, VG, 7, 2, "section", 2), Ia(8, "section", 1), Ia(9, "span"), Ia(10, "span", 3), _o(11, "Expire Time:"), Ta(), _o(12, "sdad"), Ta(), Ta(), Ia(13, "section", 1), Ia(14, "span"), Ia(15, "span", 3), _o(16, "Expired:"), Ta(), Ca(17, zG, 3, 0, "span", 4), Ca(18, UG, 1, 0, "ng-template", null, 5, dc), Ta(), Ta(), Ia(20, "section", 1), Ia(21, "span"), Oa(22, "span", 3), Ia(23, "button", 6), Ba("click", (function() { return e.OnBuy(1) })), _o(24, "Buy 1$/Month"), Ta(), Ta(), Ta(), Ia(25, "section", 1), Ia(26, "span"), Oa(27, "span", 3), Ia(28, "button", 6), Ba("click", (function() { return e.OnBuy(2) })), _o(29, "Buy 9.9$/Year (15% off) "), Ta(), Ta(), Ta(), Ia(30, "section", 1), Ia(31, "span"), Oa(32, "span", 3), Ia(33, "button", 7), Ba("click", (function() { return e.OnRefresh() })), _o(34, "Refresh"), Ta(), Ta(), Ta(), Ta(), Ta()), 2 & t) { const t = xa(19);
                    ps(4), Da("ngIf", 0 == e.m_AC.m_nAccountType), ps(1), Da("ngIf", 0 == e.m_AC.m_nAccountType), ps(1), Da("ngIf", 0 == e.m_AC.m_nAccountType), ps(1), Da("ngIf", 0 != e.m_AC.m_nAccountType), ps(5), bo("Never"), ps(5), Da("ngIf", e.m_AC.m_bExpired)("ngIfElse", t) } }, directives: [SO, yd, fk], encapsulation: 2 }), t })();

    function jG(t, e) { if (1 & t && (Ia(0, "div"), _o(1, " Your netcut service might be not running, simply "), Ia(2, "a", 2), _o(3), Ta(), _o(4, " And Run. "), Ia(5, "p"), _o(6, "With netCut 3.0, you can know who has is or has been on your WIFI, his name, device brand, what time in, what time out. "), Ia(7, "li"), _o(8, " Speed Control !!! "), Ta(), Ia(9, "li"), _o(10, "Automatic: See NEW unknown(guest) users in your network "), Ta(), Ia(11, "li"), _o(12, " Click or Drag: Stop anyone access with one click or drag "), Ta(), Ia(13, "li"), _o(14, " Schdule: Schdule anyone on/offline time per day "), Ta(), Ia(15, "li"), _o(16, " Tablet suppprt: Support windows 10 tablet "), Ta(), Ia(17, "li"), _o(18, " Cut Off ALL: One click cut off ALL (Pro member) "), Ta(), Ia(19, "li"), _o(20, " netLock: Lock your WIFI network so no any new user can access. One click to release allow guest user access (Pro member) "), Ta(), Ia(21, "li"), _o(22, " Records: View history records of who/when/name/brand been usig your WIFI and Left. (Pro member see full details) "), Ta(), Ia(23, "li"), _o(24, "Geek play: Copy Mac "), Ta(), Ia(25, "li"), _o(26, "NetCut Pro membership is only 1$ a month. or 9.9$ a year. Support paypal. If you pay via google pay at NetCut for Android, the Pro membership can be transfer to netCut Windows. Just need to login with username/password "), Ta(), Ta(), Ta()), 2 & t) { const t = ja();
            ps(3), yo("Download netcut 3.0.", t.m_NetCutMessageService.m_nLastVersion, "") } }

    function GG(t, e) { if (1 & t && (Ia(0, "span"), _o(1, "Buy"), Ia(2, "a", 23), _o(3, " 1 month for 1$"), Ta(), _o(4, " or "), Ia(5, "a", 23), _o(6, "1 year for 9.9$ "), Ta(), _o(7, " Netcut Pro membership to see who has been in your network at what time, when they Left Time, their phone/tablet/laptop name , Brand and physic address. Plus unlimit netlock, CUT OFF ALL "), Ta()), 2 & t) { const t = ja(2);
            ps(2), Ya("href", "", t.m_NetCutMessageService.m_AC.GetBuyLink(1), " target='_blank'", Zn), ps(3), Ya("href", "", t.m_NetCutMessageService.m_AC.GetBuyLink(2), " target='_blank'", Zn) } }

    function $G(t, e) { 1 & t && _o(0, "The history will overwrite oldest when reach to 30000 Records") }

    function WG(t, e) { if (1 & t && (Ia(0, "div"), Ia(1, "span"), _o(2), Ta(), Oa(3, "br"), Ta()), 2 & t) { const t = e.$implicit,
                i = ja(2);
            ps(1), so(t.m_bMyuser || i.m_OnlyShowGuest || !t.IsToday() ? "" : "blink_me"), ps(1), bo(t.GetReadableRecord()) } }

    function qG(t, e) { if (1 & t && (Ia(0, "div"), _o(1), Oa(2, "br"), Ta()), 2 & t) { const t = e.$implicit;
            ps(1), yo(" ", t, "") } }

    function YG(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 3), Ia(1, "h1"), _o(2, "Arcai.com's Netcut PRO "), Ta(), Ta(), Ia(3, "div"), Ia(4, "a", 4), _o(5, "Home"), Ta(), Ia(6, "a", 5), _o(7, "Support"), Ta(), Ia(8, "a", 6), _o(9, "Free Pro"), Ta(), Ta(), Ia(10, "mat-sidenav-container", 7), Ia(11, "mat-tab-group", 8), Ba("selectedTabChange", (function(e) { return Qe(t), ja().onLinkClick(e) })), Ia(12, "mat-tab", 9), Oa(13, "users-component"), Ta(), Ia(14, "mat-tab", 10), Oa(15, "options"), Ta(), Ia(16, "mat-tab", 11), Oa(17, "pro"), Ta(), Ia(18, "mat-tab", 12), Ia(19, "section", 13), Ca(20, GG, 8, 2, "span", 0), Ca(21, $G, 1, 0, "ng-template", null, 14, dc), Ta(), Ia(23, "section", 13), Ia(24, "div", 15), _o(25), Ia(26, "img", 16), Ba("click", (function() { return Qe(t), ja().RequestPage(2) })), Ta(), Ia(27, "img", 17), Ba("click", (function() { return Qe(t), ja().RequestPage(1) })), Ta(), Ta(), Ta(), Ia(28, "section", 13), Ia(29, "div", 18), _o(30, "Only Show Unknown (guest) User:"), Ta(), Ia(31, "div", 19), Ia(32, "mat-checkbox", 20), Ba("change", (function(e) { return Qe(t), ja().OnClickOnlyShowGuest(e.checked) })), Ta(), Ta(), Ta(), Ca(33, WG, 4, 4, "div", 21), Ul(34, "async"), Ta(), Ia(35, "mat-tab", 22), Ca(36, qG, 3, 1, "div", 21), Ul(37, "async"), Ta(), Ta(), Ta() } if (2 & t) { const t = xa(22),
                e = ja();
            ps(20), Da("ngIf", e.m_NetCutMessageService.m_AC.m_bExpired)("ngIfElse", t), ps(5), wo(" ", 30 * e.m_LastOnOffHistory.m_nCurrentPage, " - ", 30 * e.m_LastOnOffHistory.m_nCurrentPage + 30, " of ", e.m_LastOnOffHistory.m_nTotalRecords, " "), ps(7), Da("checked", e.m_OnlyShowGuest), ps(1), Da("ngForOf", Hl(34, 9, e.m_sHistoryRecords)), ps(2), qa("label", e.m_sStatus), ps(1), Da("ngForOf", Hl(37, 11, e.m_sHistoryStatus)) } }
    let XG = (() => { class t { constructor(t, e) { this.m_NetCutMessageService = t, this.m_UITabService = e, this.title = "app works!", this.m_bGoodChrome = !1, this.m_LastOnOffHistory = new nV, this.m_sStatus = "", this.recordmap = new Map, this.m_sRecordStatus = "", this.m_sRecordTitle = "Who When ON/OFF", this.m_OnlyShowGuest = !1, this.BrowserVersionCheck(), JB.InitIconList(), this.m_sStore = [], this._sHistoryStatus = new Pu([]), this.m_sHistoryStatus = this._sHistoryStatus.asObservable(), this.m_NetCutMessageService.m_Status.subscribe(t => this.OnNewStatus(t.m_sMessage)), this.m_sRecordStore = [], this._sHistoryRecords = new Pu([]), this.m_sHistoryRecords = this._sHistoryRecords.asObservable(), this.m_NetCutMessageService.m_RecordsHistory.pipe(QB(1e3)).subscribe(t => this.OnNewRecords(t), t => this.OnRecordLoadingBreak()), this.m_NetCutMessageService.m_bResetUser.subscribe(t => this.Reset()) } OnRecordLoadingBreak() { this.m_NetCutMessageService.m_RecordsHistory.pipe(QB(1e3)).subscribe(t => this.OnNewRecords(t), t => this.OnRecordLoadingBreak()), this.ReloadRecords() } BrowserVersionCheck() { var t = this.getChromeVersion();
                this.m_bGoodChrome = !(t < 49) } getChromeVersion() { var t = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./); return !!t && parseInt(t[2], 10) } OnClickOnlyShowGuest(t) { this.m_OnlyShowGuest = t, this.ReloadRecords() } RequestPage(t) { this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_REQUESTPAGE, t) } Reset() { this.recordmap.clear() } ReloadRecords() { this.m_sRecordStore = []; var t = [];
                this.recordmap.forEach((function(e, i) { t.push(i) })), t.sort((function(t, e) { return e - t })); for (var e = 0, i = t.length; e < i; e++) this.m_OnlyShowGuest && this.recordmap.get(t[e]).m_bMyuser || this.m_sRecordStore.push(this.recordmap.get(t[e]));
                this._sHistoryRecords.next(this.m_sRecordStore) } OnNewRecords(t) { this.m_LastOnOffHistory.m_nCurrentPage != t.m_nCurrentPage && this.Reset(), this.m_LastOnOffHistory = t, this.recordmap.set(t.m_nIndex, t) } OnNewStatus(t) { if (null != t) { var e = (new Date).toLocaleString();
                    this.m_sStatus = e + ":  " + t, this.m_sStore.unshift(this.m_sStatus), this.m_sStore.length > 98 && (this.m_sStore = this.m_sStore.slice(0, 98)), this._sHistoryStatus.next(this.m_sStore) } } onRemoveAD() { this.m_UITabService.SetActiveTabIndex(2) } onLinkClick(t) { this.m_UITabService.SetActiveTabIndex(t.index) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gV), Sa(_V)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["app-root"]
            ], decls: 3, vars: 2, consts: [
                [4, "ngIf", "ngIfElse"],
                ["elseBlockmain", ""],
                ["href", "/download/netcut.exe"],
                [1, "top-card-title"],
                ["href", "http://www.arcai.com/"],
                ["href", "http://www.arcai.com/forums/support/netcut/"],
                ["href", "http://www.arcai.com/forums/topic/free-netcut-pro-membership-for-one-month/"],
                [2, "display", "block"],
                [3, "selectedTabChange"],
                ["label", "Users"],
                ["label", "Options"],
                ["label", "Pro"],
                ["label", "Records"],
                [1, "option-section"],
                ["elseBlock", ""],
                [2, "height", "32px", "line-height", "32px", "text-align", "center", "float", "left", "color", "white"],
                ["src", "assets/drawable/newer.png", 3, "click"],
                ["src", "assets/drawable/older.png", 3, "click"],
                [2, "float", "left", "color", "white"],
                [2, "float", "right"],
                ["align", "end", "disabled", "false", 3, "checked", "change"],
                [4, "ngFor", "ngForOf"],
                [3, "label"],
                [3, "href"]
            ], template: function(t, e) { if (1 & t && (Ca(0, jG, 27, 1, "div", 0), Ca(1, YG, 38, 13, "ng-template", null, 1, dc)), 2 & t) { const t = xa(2);
                    Da("ngIf", e.m_NetCutMessageService.m_bNeedSetup || e.m_NetCutMessageService.m_bNeedUpgrade)("ngIfElse", t) } }, directives: [yd, SO, FP, SP, _G, yG, HG, Ak, _d], pipes: [Fd], styles: ["", "[type=range]{-webkit-appearance:none;margin:9px 0;width:100%}[type=range]:focus{outline:0}[type=range]:focus::-webkit-slider-runnable-track{background:#3d3d3d}[type=range]:focus::-ms-fill-lower{background:#303030}[type=range]:focus::-ms-fill-upper{background:#3d3d3d}[type=range]::-webkit-slider-runnable-track{cursor:pointer;height:10px;-webkit-transition:all .2s ease;transition:all .2s ease;width:100%;box-shadow:1px 1px 1px hsla(0,0%,100%,.2),0 0 1px hsla(0,0%,100%,.2);background:#303030;border:0 solid #4682b4;border-radius:0}[type=range]::-webkit-slider-thumb{box-shadow:4px 4px 2px rgba(0,0,0,.2),0 0 4px rgba(13,13,13,.2);background:#4682b4;border:0 solid #eceff1;border-radius:12px;cursor:pointer;height:18px;width:18px;-webkit-appearance:none;margin-top:-4px}[type=range]::-moz-range-track{cursor:pointer;height:10px;-moz-transition:all .2s ease;transition:all .2s ease;width:100%;box-shadow:1px 1px 1px hsla(0,0%,100%,.2),0 0 1px hsla(0,0%,100%,.2);background:#303030;border:0 solid #4682b4;border-radius:0}[type=range]::-moz-range-thumb{box-shadow:4px 4px 2px rgba(0,0,0,.2),0 0 4px rgba(13,13,13,.2);background:#4682b4;border:0 solid #eceff1;border-radius:12px;cursor:pointer;height:18px;width:18px}[type=range]::-ms-track{cursor:pointer;height:10px;-ms-transition:all .2s ease;transition:all .2s ease;width:100%;background:transparent;border-color:transparent;border-width:9px 0;color:transparent}[type=range]::-ms-fill-lower{background:#232323}[type=range]::-ms-fill-lower,[type=range]::-ms-fill-upper{box-shadow:1px 1px 1px hsla(0,0%,100%,.2),0 0 1px hsla(0,0%,100%,.2);border:0 solid #4682b4;border-radius:0}[type=range]::-ms-fill-upper{background:#303030}[type=range]::-ms-thumb{box-shadow:4px 4px 2px rgba(0,0,0,.2),0 0 4px rgba(13,13,13,.2);background:#4682b4;border:0 solid #eceff1;border-radius:12px;cursor:pointer;height:18px;width:18px;margin-top:0}", '.tg-list{text-align:center;display:flex;align-items:center}.tg-list-item{margin:0 2em}.tgl{display:none}.tgl,.tgl *,.tgl+.tgl-btn,.tgl:after,.tgl :after,.tgl:before,.tgl :before{box-sizing:border-box}.tgl+.tgl-btn::-moz-selection,.tgl::-moz-selection,.tgl ::-moz-selection,.tgl:after::-moz-selection,.tgl :after::-moz-selection,.tgl:before::-moz-selection,.tgl :before::-moz-selection{background:none}.tgl+.tgl-btn::selection,.tgl::selection,.tgl ::selection,.tgl:after::selection,.tgl :after::selection,.tgl:before::selection,.tgl :before::selection{background:none}.tgl+.tgl-btn{outline:0;display:block;width:120px;height:36px;position:relative;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.tgl+.tgl-btn:after,.tgl+.tgl-btn:before{position:relative;display:block;content:"";width:50%;height:100%}.tgl+.tgl-btn:after{left:0}.tgl+.tgl-btn:before{display:none}.tgl:checked+.tgl-btn:after{left:50%}.tgl-light+.tgl-btn{background:#f0f0f0;border-radius:2em;padding:2px;transition:all .4s ease}.tgl-light+.tgl-btn:after{border-radius:50%;background:#fff;transition:all .2s ease}.tgl-light:checked+.tgl-btn{background:#9fd6ae}.tgl-ios+.tgl-btn{background:#fbfbfb;border-radius:2em;padding:2px;transition:all .4s ease;border:1px solid #e8eae9}.tgl-ios+.tgl-btn:after{border-radius:2em;background:#fbfbfb;transition:left .3s cubic-bezier(.175,.885,.32,1.275),padding .3s ease,margin .3s ease;box-shadow:0 0 0 1px rgba(0,0,0,.1),0 4px 0 rgba(0,0,0,.08)}.tgl-ios+.tgl-btn:hover:after{will-change:padding}.tgl-ios+.tgl-btn:active{box-shadow:inset 0 0 0 2em #e8eae9}.tgl-ios+.tgl-btn:active:after{padding-right:.8em}.tgl-ios:checked+.tgl-btn{background:#86d993}.tgl-ios:checked+.tgl-btn:active{box-shadow:none}.tgl-ios:checked+.tgl-btn:active:after{margin-left:-.8em}.tgl-skewed+.tgl-btn{overflow:hidden;-webkit-backface-visibility:hidden;backface-visibility:hidden;transition:all .2s ease;font-family:sans-serif;background:#888}.tgl-skewed+.tgl-btn:after,.tgl-skewed+.tgl-btn:before{display:inline-block;transition:all .2s ease;width:100%;text-align:center;position:absolute;line-height:2em;font-weight:700;color:#fff;text-shadow:0 1px 0 rgba(0,0,0,.4)}.tgl-skewed+.tgl-btn:after{left:100%;content:attr(data-tg-on)}.tgl-skewed+.tgl-btn:before{left:0;content:attr(data-tg-off)}.tgl-skewed+.tgl-btn:active{background:#888}.tgl-skewed+.tgl-btn:active:before{left:-10%}.tgl-skewed:checked+.tgl-btn{background:#86d993}.tgl-skewed:checked+.tgl-btn:before{left:-100%}.tgl-skewed:checked+.tgl-btn:after{left:0}.tgl-skewed:checked+.tgl-btn:active:after{left:10%}.tgl-flat+.tgl-btn{padding:2px;transition:all .2s ease;background:#fff;border:4px solid #f2f2f2;border-radius:2em}.tgl-flat+.tgl-btn:after{transition:all .2s ease;background:#f2f2f2;content:"";border-radius:1em}.tgl-flat:checked+.tgl-btn{border:4px solid #7fc6a6}.tgl-flat:checked+.tgl-btn:after{left:50%;background:#7fc6a6}.tgl-flip+.tgl-btn{padding:2px;transition:all .2s ease;font-family:sans-serif;perspective:100px}.tgl-flip+.tgl-btn:after,.tgl-flip+.tgl-btn:before{display:inline-block;transition:all .4s ease;width:100%;text-align:center;line-height:2em;font-weight:700;color:#fff;position:absolute;top:0;left:0;-webkit-backface-visibility:hidden;backface-visibility:hidden;border-radius:4px}.tgl-flip+.tgl-btn:after{content:attr(data-tg-on);background:#02c66f;transform:rotateY(-180deg)}.tgl-flip+.tgl-btn:before{background:#ff3a19;content:attr(data-tg-off)}.tgl-flip+.tgl-btn:active:before{transform:rotateY(-20deg)}.tgl-flip:checked+.tgl-btn:before{transform:rotateY(180deg)}.tgl-flip:checked+.tgl-btn:after{transform:rotateY(0);left:0;background:#7fc6a6}.tgl-flip:checked+.tgl-btn:active:after{transform:rotateY(20deg)}'], encapsulation: 2 }), t })();

    function KG(t, e) { if (1 & t && (Ia(0, "span"), _o(1, "Buy"), Ia(2, "a", 10), _o(3, " 1 month for 1$"), Ta(), _o(4, " or "), Ia(5, "a", 10), _o(6, "1 year for 9.9$ "), Ta(), _o(7, " Netcut Pro membership to see who has been in your network at what time, when they Left Time, their phone/tablet/laptop name , Brand and physic address. Plus unlimit netlock, CUT OFF ALL "), Ta()), 2 & t) { const t = ja();
            ps(2), Ya("href", "", t.m_NetCutMessageService.m_AC.GetBuyLink(1), " target='_blank'", Zn), ps(3), Ya("href", "", t.m_NetCutMessageService.m_AC.GetBuyLink(2), " target='_blank'", Zn) } }

    function ZG(t, e) { 1 & t && _o(0, "The history will overwrite oldest when reach to 30000 Records") }

    function QG(t, e) { if (1 & t && (Ia(0, "div"), Ia(1, "span"), _o(2), Ta(), Oa(3, "br"), Ta()), 2 & t) { const t = e.$implicit,
                i = ja();
            ps(1), so(t.m_bMyuser || i.m_OnlyShowGuest || !t.IsToday() ? "" : "blink_me"), ps(1), bo(t.GetReadableRecord()) } }
    let JG = (() => { class t { constructor(t, e) { this.m_NetCutMessageService = t, this.m_UITabService = e, this.m_LastOnOffHistory = new nV, this.m_sStatus = "", this.recordmap = new Map, this.m_sRecordStatus = "", this.m_sRecordTitle = "Who When ON/OFF", this.m_OnlyShowGuest = !1, JB.InitIconList(), this.m_sStore = [], this._sHistoryStatus = new Pu([]), this.m_sHistoryStatus = this._sHistoryStatus.asObservable(), this.m_NetCutMessageService.m_Status.subscribe(t => this.OnNewStatus(t.m_sMessage)), this.m_sRecordStore = [], this._sHistoryRecords = new Pu([]), this.m_sHistoryRecords = this._sHistoryRecords.asObservable(), this.m_NetCutMessageService.m_RecordsHistory.pipe(QB(1e3)).subscribe(t => this.OnNewRecords(t), t => this.OnRecordLoadingBreak()), this.m_NetCutMessageService.m_bResetUser.subscribe(t => this.Reset()) } OnRecordLoadingBreak() { this.m_NetCutMessageService.m_RecordsHistory.pipe(QB(1e3)).subscribe(t => this.OnNewRecords(t), t => this.OnRecordLoadingBreak()), this.ReloadRecords() } RequestPage(t) { this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_REQUESTPAGE, t) } OnClickOnlyShowGuest(t) { this.m_OnlyShowGuest = t, this.ReloadRecords() } Reset() { this.recordmap.clear() } ReloadRecords() { this.m_sRecordStore = []; var t = [];
                this.recordmap.forEach((function(e, i) { t.push(i) })), t.sort((function(t, e) { return e - t })); for (var e = 0, i = t.length; e < i; e++) this.m_OnlyShowGuest && this.recordmap.get(t[e]).m_bMyuser || this.m_sRecordStore.push(this.recordmap.get(t[e]));
                this._sHistoryRecords.next(this.m_sRecordStore) } OnNewRecords(t) { this.m_LastOnOffHistory.m_nCurrentPage != t.m_nCurrentPage && this.Reset(), this.m_LastOnOffHistory = t, this.recordmap.set(t.m_nIndex, t) } OnNewStatus(t) { if (null != t) { var e = (new Date).toLocaleString();
                    this.m_sStatus = e + ":  " + t, this.m_sStore.unshift(this.m_sStatus), this.m_sStore.length > 98 && (this.m_sStore = this.m_sStore.slice(0, 98)), this._sHistoryStatus.next(this.m_sStore) } } onLinkClick(t) { this.m_UITabService.SetActiveTabIndex(t.index) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gV), Sa(_V)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["records"]
            ], decls: 16, vars: 9, consts: [
                [1, "option-section"],
                [4, "ngIf", "ngIfElse"],
                ["elseBlock", ""],
                [2, "height", "32px", "line-height", "32px", "text-align", "center", "float", "left", "color", "white"],
                ["src", "assets/drawable/newer.png", 3, "click"],
                ["src", "assets/drawable/older.png", 3, "click"],
                [2, "float", "left", "color", "white"],
                [2, "float", "right"],
                ["align", "end", "disabled", "false", 3, "checked", "change"],
                [4, "ngFor", "ngForOf"],
                [3, "href"]
            ], template: function(t, e) { if (1 & t && (Ia(0, "section", 0), Ca(1, KG, 8, 2, "span", 1), Ca(2, ZG, 1, 0, "ng-template", null, 2, dc), Ta(), Ia(4, "section", 0), Ia(5, "div", 3), _o(6), Ia(7, "img", 4), Ba("click", (function() { return e.RequestPage(2) })), Ta(), Ia(8, "img", 5), Ba("click", (function() { return e.RequestPage(1) })), Ta(), Ta(), Ta(), Ia(9, "section", 0), Ia(10, "div", 6), _o(11, "Only Show Unknown (guest) User:"), Ta(), Ia(12, "div", 7), Ia(13, "mat-checkbox", 8), Ba("change", (function(t) { return e.OnClickOnlyShowGuest(t.checked) })), Ta(), Ta(), Ta(), Ca(14, QG, 4, 4, "div", 9), Ul(15, "async")), 2 & t) { const t = xa(3);
                    ps(1), Da("ngIf", e.m_NetCutMessageService.m_AC.m_bExpired)("ngIfElse", t), ps(5), wo(" ", 30 * e.m_LastOnOffHistory.m_nCurrentPage, " - ", 30 * e.m_LastOnOffHistory.m_nCurrentPage + 30, " of ", e.m_LastOnOffHistory.m_nTotalRecords, " "), ps(7), Da("checked", e.m_OnlyShowGuest), ps(1), Da("ngForOf", Hl(15, 7, e.m_sHistoryRecords)) } }, directives: [yd, Ak, _d], pipes: [Fd], encapsulation: 2 }), t })(), t$ = (() => { class t { constructor(t) { this.m_NetCutMessageService = t, this.defender = !1 } onChange(t) { console.log(t), this.defender = 1 == t.checked, this.m_NetCutMessageService.ActionOnID(eV.IPCMESSAGE_ID_INT_SETDEFENDER, this.defender ? 1 : 0) } ngOnInit() { this.m_NetCutMessageService.m_MessageDefender.subscribe(t => { this.defender = 1 == t.m_nValue }) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gV)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["slide-toggle-defender"]
            ], decls: 1, vars: 2, consts: [
                ["id", "defender_onoff", "ngDefaultControl", "", 3, "checked", "disabled", "change"]
            ], template: function(t, e) { 1 & t && (Ia(0, "mat-slide-toggle", 0), Ba("change", (function(t) { return e.onChange(t) })), Ta()), 2 & t && Da("checked", e.defender)("disabled", !1) }, directives: [RT, kg], encapsulation: 2 }), t })();

    function e$(t, e) { 1 & t && (Ia(0, "span"), Ia(1, "button", 2), _o(2, "Google Sign-In"), Ta(), Ta()) }

    function i$(t, e) { if (1 & t) { const t = Fa();
            _o(0), Ia(1, "a", 3), Ba("click", (function() { return Qe(t), ja().signOut() })), _o(2, "Sign out"), Ta() } 2 & t && yo(" ", ja().email, " ") }
    let n$ = (() => { class t { constructor(t) { this.element = t, this.clientId = "848393748057-21k3c6flaoou7fiihvq4g3td2216pb8b.apps.googleusercontent.com", this.scope = ["profile", "email"].join(" "), console.log("ElementRef: ", this.element) } googleInit() { let t = this;
                gapi.load("auth2", (function() { t.auth2 = gapi.auth2.init({ client_id: t.clientId, cookiepolicy: "single_host_origin", scope: t.scope }), t.attachSignin(t.element.nativeElement.querySelector(".login")) })) } attachSignin(t) { this.auth2.attachClickHandler(t, {}, (function(t) { let e = t.getBasicProfile();
                    console.log("Token || " + t.getAuthResponse().id_token), console.log("Email: " + e.getEmail()), localStorage.setItem("token", t.getAuthResponse().id_token), localStorage.setItem("email", e.getEmail()) }), (function(t) { console.log(JSON.stringify(t, void 0, 2)) })) } ngAfterViewInit() { this.googleInit() } signOut() { var t = gapi.auth2.getAuthInstance();
                t.signOut().then((function() { console.log("User signed out.") })), t.disconnect() } } return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["google-signin"]
            ], decls: 3, vars: 2, consts: [
                [4, "ngIf", "ngIfElse"],
                ["elseBlockGoogleLogin", ""],
                ["id", "googleBtn", 1, "login"],
                ["href", "#", 3, "click"]
            ], template: function(t, e) { if (1 & t && (Ca(0, e$, 3, 0, "span", 0), Ca(1, i$, 3, 1, "ng-template", null, 1, dc)), 2 & t) { const t = xa(2);
                    Da("ngIf", "" == e.email)("ngIfElse", t) } }, directives: [yd], encapsulation: 2 }), t })();
    const s$ = ["canvas"], r$ = ["rLabel"], a$ = ["reading"];

    function o$(t, e) { 1 & t && Wa(0, 0, ["*ngSwitchCase", "true"]) }

    function l$(t, e) { if (1 & t && (Ra(0), _o(1), Ma()), 2 & t) { const t = ja();
            ps(1), bo(t.prepend) } }

    function c$(t, e) { 1 & t && Wa(0, 1, ["*ngSwitchCase", "true"]) }

    function h$(t, e) { if (1 & t && (Ra(0), _o(1), Ul(2, "number"), Ma()), 2 & t) { const t = ja();
            ps(1), bo(Hl(2, 1, t.value)) } }

    function d$(t, e) { 1 & t && Wa(0, 2, ["*ngSwitchCase", "true"]) }

    function u$(t, e) { if (1 & t && (Ra(0), _o(1), Ma()), 2 & t) { const t = ja();
            ps(1), bo(t.append) } }

    function m$(t, e) { 1 & t && Wa(0, 3, ["*ngSwitchCase", "true"]) }

    function p$(t, e) { if (1 & t && (Ra(0), _o(1), Ma()), 2 & t) { const t = ja();
            ps(1), bo(t.label) } }
    const f$ = [
        [
            ["ngx-gauge-prepend"]
        ],
        [
            ["ngx-gauge-value"]
        ],
        [
            ["ngx-gauge-append"]
        ],
        [
            ["ngx-gauge-label"]
        ]
    ], g$ = ["ngx-gauge-prepend", "ngx-gauge-value", "ngx-gauge-append", "ngx-gauge-label"];

    function _$(t, e = 0) { return isNaN(parseFloat(t)) || isNaN(Number(t)) ? e : Number(t) }

    function b$(t) { return `${t}px` }
    let y$ = (() => { let t = class {}; return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["ngx-gauge-append"]
            ], exportAs: ["ngxGaugeAppend"] }), t })(), v$ = (() => { let t = class {}; return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["ngx-gauge-prepend"]
            ], exportAs: ["ngxGaugePrepend"] }), t })(), w$ = (() => { let t = class {}; return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["ngx-gauge-value"]
            ], exportAs: ["ngxGaugeValue"] }), t })(), C$ = (() => { let t = class {}; return t.\u0275fac = function(e) { return new(e || t) }, t.\u0275dir = we({ type: t, selectors: [
                ["ngx-gauge-label"]
            ], exportAs: ["ngxGaugeLabel"] }), t })(), x$ = (() => { let t = class { constructor(t, e) { this._elementRef = t, this._renderer = e, this._size = 200, this._min = 0, this._max = 100, this._animate = !0, this._initialized = !1, this._animationRequestID = 0, this.ariaLabel = "", this.ariaLabelledby = null, this.type = "arch", this.cap = "butt", this.thick = 4, this.foregroundColor = "rgba(0, 150, 136, 1)", this.backgroundColor = "rgba(0, 0, 0, 0.1)", this.thresholds = Object.create(null), this._value = 0, this.duration = 1200 } get size() { return this._size } set size(t) { this._size = _$(t) } get min() { return this._min } set min(t) { this._min = _$(t, 0) } get animate() { return this._animate } set animate(t) { this._animate = function(t) { return null != t && "false" !== `${t}` }(t) } get max() { return this._max } set max(t) { this._max = _$(t, 100) } get value() { return this._value } set value(t) { this._value = _$(t) } ngOnChanges(t) { const e = t.thick || t.type || t.cap || t.size; if (this._initialized) { if (t.value || t.min || t.max) { let e, i;
                        t.value && (e = t.value.currentValue, i = t.value.previousValue), this._update(e, i) } e && (this._destroy(), this._init()) } } _updateSize() { this._renderer.setStyle(this._elementRef.nativeElement, "width", b$(this._getWidth())), this._renderer.setStyle(this._elementRef.nativeElement, "height", b$(this._getCanvasHeight())), this._canvas.nativeElement.width = this._getWidth(), this._canvas.nativeElement.height = this._getCanvasHeight(), this._renderer.setStyle(this._label.nativeElement, "transform", "translateY(" + (this.size / 3 * 2 - this.size / 13 / 4) + "px)"), this._renderer.setStyle(this._reading.nativeElement, "transform", "translateY(" + (this.size / 2 - .22 * this.size / 2) + "px)") } ngAfterViewInit() { this._canvas && this._init() } ngOnDestroy() { this._destroy() } _getBounds(t) { let e, i; return "semi" == t ? (e = Math.PI, i = 2 * Math.PI) : "full" == t ? (e = 1.5 * Math.PI, i = 3.5 * Math.PI) : "arch" === t && (e = .8 * Math.PI, i = 2.2 * Math.PI), { head: e, tail: i } } _drawShell(t, e, i, n) { let s = this._getCenter(),
                    r = this._getRadius();
                e = Math.max(e, t), e = Math.min(e, i), this._initialized && (this._clear(), this._context.beginPath(), this._context.strokeStyle = this.backgroundColor, this._context.arc(s.x, s.y, r, e, i, !1), this._context.stroke(), this._context.beginPath(), this._context.strokeStyle = n, this._context.arc(s.x, s.y, r, t, e, !1), this._context.stroke()) } _clear() { this._context.clearRect(0, 0, this._getWidth(), this._getHeight()) } _getWidth() { return this.size } _getHeight() { return this.size } _getCanvasHeight() { return "arch" == this.type || "semi" == this.type ? .85 * this._getHeight() : this._getHeight() } _getRadius() { return this._getCenter().x - this.thick } _getCenter() { return { x: this._getWidth() / 2, y: this._getHeight() / 2 } } _init() { this._context = this._canvas.nativeElement.getContext("2d"), this._initialized = !0, this._updateSize(), this._setupStyles(), this._create() } _destroy() { this._animationRequestID && (window.cancelAnimationFrame(this._animationRequestID), this._animationRequestID = 0), this._clear(), this._context = null, this._initialized = !1 } _setupStyles() { this._context.lineCap = this.cap, this._context.lineWidth = this.thick } _getForegroundColorByRange(t) { const e = Object.keys(this.thresholds).filter((function(e) { return function(t) { return null != t && !isNaN(parseFloat(t)) && !isNaN(Number(t)) }(e) && Number(e) <= t })).sort((t, e) => Number(t) - Number(e)).reverse()[0]; return void 0 !== e && this.thresholds[e].color || this.foregroundColor } _create(t, e) { let i, n = this,
                    s = this._getBounds(this.type),
                    r = this.duration,
                    a = this.min,
                    o = this.max,
                    l = function(t, e, i) { return Math.max(e, Math.min(i, t)) }(this.value, this.min, this.max),
                    c = s.head,
                    h = (s.tail - s.head) / (o - a),
                    d = h * (l - a),
                    u = s.tail,
                    m = this._getForegroundColorByRange(l);
                n._animationRequestID && window.cancelAnimationFrame(n._animationRequestID), this._animate ? (null != t && null != e && (d = h * t - h * e), n._animationRequestID = window.requestAnimationFrame(t => { i = t || (new Date).getTime(),
                        function t(s) { let o = (s = s || (new Date).getTime()) - i,
                                l = Math.min(o / r, 1);
                            n._drawShell(c, c + (e ? (e - a) * h : 0) + d * l, u, m), n._animationRequestID && o < r ? n._animationRequestID = window.requestAnimationFrame(e => t(e)) : window.cancelAnimationFrame(n._animationRequestID) }(i) })) : n._drawShell(c, c + d, u, m) } _update(t, e) { this._clear(), this._create(t, e) } }; return t.\u0275fac = function(e) { return new(e || t)(Sa(Wo), Sa(Ko)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["ngx-gauge"]
            ], contentQueries: function(t, e, i) { var n;
                1 & t && (sc(i, C$, !0), sc(i, v$, !0), sc(i, y$, !0), sc(i, w$, !0)), 2 & t && (tc(n = oc()) && (e._labelChild = n.first), tc(n = oc()) && (e._prependChild = n.first), tc(n = oc()) && (e._appendChild = n.first), tc(n = oc()) && (e._valueDisplayChild = n.first)) }, viewQuery: function(t, e) { var i;
                1 & t && (ec(s$, !0), ec(r$, !0), ec(a$, !0)), 2 & t && (tc(i = oc()) && (e._canvas = i.first), tc(i = oc()) && (e._label = i.first), tc(i = oc()) && (e._reading = i.first)) }, hostAttrs: ["role", "slider", "aria-readonly", "true"], hostVars: 7, hostBindings: function(t, e) { 2 & t && (va("aria-valuemin", e.min)("aria-valuemax", e.max)("aria-valuenow", e.value)("aria-label", e.ariaLabel)("aria-labelledby", e.ariaLabelledby), no("ngx-gauge-meter", !0)) }, inputs: { ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], type: "type", cap: "cap", thick: "thick", foregroundColor: "foregroundColor", backgroundColor: "backgroundColor", thresholds: "thresholds", duration: "duration", size: "size", min: "min", animate: "animate", max: "max", value: "value", label: "label", append: "append", prepend: "prepend" }, features: [Ro], ngContentSelectors: g$, decls: 17, vars: 16, consts: [
                [1, "reading-block"],
                ["reading", ""],
                [1, "reading-affix", 3, "ngSwitch"],
                [4, "ngSwitchCase"],
                [3, "ngSwitch"],
                [1, "reading-label", 3, "ngSwitch"],
                ["rLabel", ""],
                ["canvas", ""]
            ], template: function(t, e) { 1 & t && ($a(f$), Ia(0, "div", 0, 1), Ia(2, "u", 2), Ca(3, o$, 1, 0, void 0, 3), Ca(4, l$, 2, 1, "ng-container", 3), Ta(), Ra(5, 4), Ca(6, c$, 1, 0, void 0, 3), Ca(7, h$, 3, 3, "ng-container", 3), Ma(), Ia(8, "u", 2), Ca(9, d$, 1, 0, void 0, 3), Ca(10, u$, 2, 1, "ng-container", 3), Ta(), Ta(), Ia(11, "div", 5, 6), Ca(13, m$, 1, 0, void 0, 3), Ca(14, p$, 2, 1, "ng-container", 3), Ta(), Oa(15, "canvas", null, 7)), 2 & t && (io("font-size", .22 * e.size + "px"), ps(2), Da("ngSwitch", null != e._prependChild), ps(1), Da("ngSwitchCase", !0), ps(1), Da("ngSwitchCase", !1), ps(1), Da("ngSwitch", null != e._valueDisplayChild), ps(1), Da("ngSwitchCase", !0), ps(1), Da("ngSwitchCase", !1), ps(1), Da("ngSwitch", null != e._appendChild), ps(1), Da("ngSwitchCase", !0), ps(1), Da("ngSwitchCase", !1), ps(1), io("font-size", e.size / 13 + "px"), Da("ngSwitch", null != e._labelChild), ps(2), Da("ngSwitchCase", !0), ps(1), Da("ngSwitchCase", !1)) }, directives: [xd, Sd], pipes: [qd], styles: [".ngx-gauge-meter{display:inline-block;text-align:center;position:relative}.reading-block{position:absolute;width:100%;font-weight:400;white-space:nowrap;text-align:center;overflow:hidden;text-overflow:ellipsis}.reading-label{font-family:inherit;width:100%;display:inline-block;position:absolute;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:400}.reading-affix{text-decoration:none;font-size:.6em;opacity:.8;font-weight:200;padding:0 .18em}.reading-affix:first-child{padding-left:0}.reading-affix:last-child{padding-right:0}"], encapsulation: 2 }), t })(), S$ = (() => { let t = class {}; return t.\u0275mod = ye({ type: t }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, imports: [
                [Jd]
            ] }), t })(), k$ = (() => { class t { constructor(t) { this.m_NetCutMessageService = t, this.animationState = !1, this.animationWithState = !1, this.hueBtnState = !1, this.name = "Angular", this.gaugeType = "arch", this.gaugeValue = .16, this.gaugeLabel = "Used", this.gaugeAppendText = "mb/s", this.thick = 9, this.max = 40, this.foregroundColor = "#92cedd", this.isOpen = !0, this.logging = !1, this.class = "open-close-container" } animate() { this.animationState = !1, setTimeout(() => { this.animationState = !0, this.animationWithState = !this.animationWithState }, 1) } ngOnInit() { this.m_NetCutMessageService.m_UserSpeed.pipe(Gu(t => t.m_sMacBuf.isSame(this.m_NetCutDriver.m_sMacBuf))).subscribe(t => { if (this.gaugeValue = t.m_nSpeed, this.gaugeValue >= 1024 ? (this.max = 50, this.gaugeValue = JB.roundToTwo(this.gaugeValue / 1024), this.gaugeAppendText = "mb/s") : (this.max = 51200, this.gaugeAppendText = "kb/s"), t.m_nUsage > 1024) { var e = JB.roundToTwo(t.m_nUsage / 1024);
                        this.gaugeLabel = e.toString() + "mb used" } else this.gaugeLabel = t.m_nUsage.toString() + "kb used" }), this.animate() } OnClick() {} } return t.\u0275fac = function(e) { return new(e || t)(Sa(gV)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["chart-root"]
            ], inputs: { m_NetCutDriver: "m_NetCutDriver" }, decls: 4, vars: 10, consts: [
                ["align", "center"],
                [2, "background-color", "coral", "color", "white"],
                ["size", "200", 3, "type", "value", "label", "thick", "max", "foregroundColor", "append", "click"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div", 0), Ia(1, "div", 1), _o(2, "Free help for stay home period of netCut user"), Ta(), Ia(3, "ngx-gauge", 2), Ba("click", (function() { return e.OnClick() })), Ta(), Ta()), 2 & t && (Da("@rubberBand", e.animationState), ps(3), so(e.class), Da("type", e.gaugeType)("value", e.gaugeValue)("label", e.gaugeLabel)("thick", e.thick)("max", e.max)("foregroundColor", e.foregroundColor)("append", e.gaugeAppendText)) }, directives: [x$], styles: ["[_nghost-%COMP%]{display:block}.open-close-container[_ngcontent-%COMP%]{border:0 solid #0f0f0f;margin-top:0;padding:0 0 0 10px;color:#92cedd;font-weight:700;font-size:17px}"], data: { animation: [oz({ anchor: "enter1" }), oz({ anchor: "enter2", delay: 100 }), oz({ anchor: "enter3", delay: 200 }), wV(), SV(), DV({ anchor: "pulse" }), TV(), MV(), NV(), VV(), HV(), $V(), YV(), ZV(), tz(), nz(), az(), cz(), uz(), fz(), bz(), wz(), Sz(), Dz(), Tz(), Mz(), Nz(), Vz(), Hz(), $z(), Yz(), Zz(), tU(), nU(), aU(), cU(), uU(), fU(), bU(), wU(), SU(), DU(), TU(), MU(), NU(), VU(), HU(), $U(), YU(), ZU(), tH(), nH(), aH(), cH(), uH(), fH(), bH(), wH(), SH(), DH(), TH(), MH(), NH(), VH(), HH(), $H(), YH(), ZH(), tj(), nj(), aj(), cj(), uj(), fj(), bj(), wj(), Sj(), Dj(), Tj(), Rj(), Uj(), Uj({ anchor: "rotate90", degrees: 90 }), jj(), jj({ anchor: "hueButton", duration: 2e4 })] } }), t })();
    var E$ = { prefix: "fas", iconName: "eye", icon: [576, 512, [], "f06e", "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"] }, D$ = { prefix: "fas", iconName: "eye-slash", icon: [640, 512, [], "f070", "M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z"] };

    function A$(t, e) { if (1 & t && (Ia(0, "div", 6), Oa(1, "activity-detail", 7), Ta()), 2 & t) { const t = e.$implicit;
            Da("id", t.ID()), ps(1), Da("m_ActivitytDriver", t) } }

    function I$(t, e) { if (1 & t && (Ia(0, "div", 4), Ca(1, A$, 2, 2, "div", 5), Ul(2, "async"), Ta()), 2 & t) { const t = ja(2);
            ps(1), Da("ngForOf", Hl(2, 1, t.m_activitylist)) } }

    function T$(t, e) { if (1 & t) { const t = Fa();
            Ia(0, "div", 2), Ba("click", (function() { return Qe(t), ja().OnClickShow() })), Oa(1, "fa-icon", 3), _o(2, " Speed Brust "), Ca(3, I$, 3, 3, "ng-template", 1), Ta() } if (2 & t) { const t = ja();
            ps(1), Da("icon", t.faEye), ps(2), Da("ngIf", t.m_bShow) } }
    let O$ = (() => { class t { constructor(t) { this.m_NetCutMessageService = t, this.faEye = E$, this.m_bShow = !0, this.m_show = "show", this.animationState = !1, this.animationWithState = !1, this.hueBtnState = !1, this.tempArray = [], this.activityMap = new Map, this._m_activitylist = new Pu([]), this.m_activitylist = this._m_activitylist.asObservable() } animate() { this.animationState = !1, setTimeout(() => { this.animationState = !0, this.animationWithState = !this.animationWithState }, 10) } OnClickShow() { this.m_bShow ? (this.m_bShow = !1, this.m_show = "hide", this.faEye = D$) : (this.m_bShow = !0, this.m_show = "show", this.faEye = E$) } ngOnInit() { this.m_NetCutMessageService.m_UserActivity.pipe(Gu(t => t.m_sMacBuf.isSame(this.m_NetCutDriver.m_sMacBuf))).subscribe(t => { this.onmessage(t) }); var t = new sV;
                t.m_sMacBuf.Clone(this.m_NetCutDriver.m_sMacBuf.m_dv.buffer), t.m_nID = eV.IPCMESSAGE_ID_MAC_INT_USAGE, t.m_nValue = 1, this.m_NetCutMessageService.SendIPCMessage(t) } onmessage(t) { if (!this.activityMap.get(t.ID())) { this.activityMap.set(t.ID(), t), this.newArrayIndex = 0, this.tempArray = [], this.activityMap.forEach(this.loopmap.bind(this)), this.tempArray.sort((function(t, e) { return e.m_nStartTime - t.m_nStartTime }).bind(this)); for (var e = 0; e < this.tempArray.length; ++e) this.tempArray[e].setPos(e);
                    this._m_activitylist.next(this.tempArray) } } loopmap(t, e, i) { this.tempArray.push(t) } } return t.\u0275fac = function(e) { return new(e || t)(Sa(gV)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["activity-root"]
            ], inputs: { m_NetCutDriver: "m_NetCutDriver" }, decls: 3, vars: 3, consts: [
                ["name", "viewport", "content", "width=device-width, initial-scale=1.0"],
                [3, "ngIf"],
                [3, "click"],
                [3, "icon"],
                [1, "timeline"],
                [3, "id", 4, "ngFor", "ngForOf"],
                [3, "id"],
                [3, "m_ActivitytDriver"]
            ], template: function(t, e) { if (1 & t && (Oa(0, "meta", 0), Ca(1, T$, 4, 2, "ng-template", 1), Ul(2, "async")), 2 & t) { var i; const t = (null == (i = Hl(2, 1, e.m_activitylist)) ? null : i.length) > 0;
                    ps(1), Da("ngIf", t) } }, styles: ['*[_ngcontent-%COMP%]{box-sizing:border-box}i[_ngcontent-%COMP%]{border:solid #92cedd;border-width:0 3px 3px 0;display:inline-block;padding:3px}.right[_ngcontent-%COMP%]{transform:rotate(-45deg);-webkit-transform:rotate(-45deg)}.left[_ngcontent-%COMP%]{transform:rotate(135deg);-webkit-transform:rotate(135deg)}.hide[_ngcontent-%COMP%]{transform:rotate(-135deg);-webkit-transform:rotate(-135deg)}.show[_ngcontent-%COMP%]{transform:rotate(45deg);-webkit-transform:rotate(45deg)}body[_ngcontent-%COMP%]{background-color:#474e5d;font-family:Helvetica,sans-serif}.timeline[_ngcontent-%COMP%]{position:relative;max-width:1200px;margin:0 auto}.timeline[_ngcontent-%COMP%]:after{content:"";position:absolute;width:6px;background-color:#264b51;top:0;bottom:0;left:31px;margin-left:-3px}.container[_ngcontent-%COMP%]{position:relative;background-color:inherit;width:100%;padding:10px 25px 10px 70px}.container[_ngcontent-%COMP%]:before{left:60px;border:solid transparent;border-right:solid #fff;border-width:10px 10px 10px 0}.container[_ngcontent-%COMP%]:after{content:"";position:absolute;width:25px;height:25px;right:-17px;background-color:#fff;border:4px solid #ff9f55;top:15px;border-radius:50%;z-index:1}.left[_ngcontent-%COMP%], .right[_ngcontent-%COMP%]{left:0}.left[_ngcontent-%COMP%]:before{right:30px;border:solid transparent;border-left:solid #fff;border-width:10px 0 10px 10px}.left[_ngcontent-%COMP%]:before, .right[_ngcontent-%COMP%]:before{content:" ";height:0;position:absolute;top:22px;width:0;z-index:1}.right[_ngcontent-%COMP%]:before{left:30px;border:solid transparent;border-right:solid #fff;border-width:10px 10px 10px 0}.left[_ngcontent-%COMP%]:after, .right[_ngcontent-%COMP%]:after{left:15px}.content[_ngcontent-%COMP%]{padding:20px 30px;background-color:#fff;position:relative;border-radius:6px}@media screen and (max-width:600px){.container[_ngcontent-%COMP%]{width:100%;padding-left:70px;padding-right:25px}.container[_ngcontent-%COMP%]:before{left:60px;border:solid transparent;border-right:solid #fff;border-width:10px 10px 10px 0}.left[_ngcontent-%COMP%]:after, .right[_ngcontent-%COMP%]:after{left:15px}.right[_ngcontent-%COMP%]{left:0}}'], data: { animation: [oz({ anchor: "enter1" }), oz({ anchor: "enter2", delay: 100 }), oz({ anchor: "enter3", delay: 200 }), wV(), XV(), hz(), SV(), DV({ anchor: "pulse" }), TV(), MV(), NV(), VV(), HV(), $V(), YV(), ZV(), tz(), nz(), az(), cz(), uz(), fz(), bz(), wz(), Sz(), Dz(), Tz(), Mz(), Nz(), Vz(), Hz(), $z(), Yz(), Zz(), tU(), nU(), aU(), cU(), uU(), fU(), bU(), wU(), SU(), DU(), TU(), MU(), NU(), VU(), HU(), $U(), YU(), ZU(), tH(), nH(), aH(), cH(), uH(), fH(), bH(), wH(), SH(), DH(), TH(), MH(), NH(), VH(), HH(), $H(), oj(), YH(), ZH(), tj(), nj(), WH(), aj(), cj(), uj(), fj(), bj(), wj(), Sj(), Dj(), Tj(), Rj(), Uj(), Uj({ anchor: "rotate90", degrees: 90 }), jj(), jj({ anchor: "hueButton", duration: 2e4 })] } }), t })(), R$ = (() => { class t { constructor(t, e, i) { this.googleAnalyticsService = t, this.m_NetCutMessageService = e, this.dialog = i, this.m_sTest = "test", this.nLastAnimationTime = Date.now() - 12e4, this.animationState = !1, this.animationWithState = !1, this.hueBtnState = !1, this.gaugeType = "full", this.gaugeValue = 1, this.gaugeLabel = "", this.gaugeAppendText = "Minute", this.thick = 9, this.max = 60, this.foregroundColor = "#92cedd", this.TitleImage = mV.m_sImgPath + "base.png", this.TitleString = "" } animate() { Date.now() - this.nLastAnimationTime > 7e3 && (this.nLastAnimationTime = Date.now(), this.animationState = !1, setTimeout(() => { this.animationState = !0, this.animationWithState = !this.animationWithState }, 1)) } ngOnInit() { this.gaugeLabel = this.m_ActivitytDriver.m_sStartTime + "-" + this.m_ActivitytDriver.m_sLastTime, this.m_NetCutMessageService.m_UserActivity.pipe(Gu(t => t.ID() == this.m_ActivitytDriver.ID())).subscribe(t => { this.onmessage(t) }), this.m_NetCutMessageService.m_MessageProAccountID.subscribe(t => this.OnNewACInfo(t)), this.animate(), setInterval(() => { this.foregroundColor = this.m_ActivitytDriver.IsActive() ? "#06f06f" : "#92cedd" }, 3e4); for (var t = 0; t < this.m_ActivitytDriver.m_DomainList.length; t++) this.googleAnalyticsService.eventEmitter(this.m_ActivitytDriver.m_DomainList[t], this.m_ActivitytDriver.m_sActivityName, this.m_ActivitytDriver.m_sRawTitle, this.m_ActivitytDriver.m_nUsedMinutes) } OnNewACInfo(t) {} OnFindOut() { this.m_NetCutMessageService.m_AC.m_bExpired && this.dialog.open(kG, { data: 1 }) } onmessage(t) { this.m_ActivitytDriver.LoadBuffer(t.m_MemberBuf), this.m_ActivitytDriver.m_nUsedMinutes <= 0 ? (this.gaugeValue = this.m_ActivitytDriver.m_nLastAccessTime - this.m_ActivitytDriver.m_nStartTime, this.gaugeAppendText = "Seconds", this.max = 60) : this.m_ActivitytDriver.m_nUsedMinutes > 0 && this.m_ActivitytDriver.m_nUsedMinutes < 60 ? (this.gaugeValue = this.m_ActivitytDriver.m_nUsedMinutes, this.gaugeAppendText = "Minutes", this.max = 60) : (this.gaugeValue = JB.roundToTwo(this.m_ActivitytDriver.m_nUsedMinutes / 60), this.gaugeAppendText = "Hours", this.max = this.gaugeValue < 24 ? 24 : Math.round(1.86 * this.gaugeValue)), this.gaugeLabel = this.m_ActivitytDriver.m_sStartTime + "-" + this.m_ActivitytDriver.m_sLastTime, this.animate(), this.m_ActivitytDriver.IsActive() && "#92cedd" == this.foregroundColor && (this.foregroundColor = "#06f06f"), this.m_ActivitytDriver.IsActive() || "#06f06f" != this.foregroundColor || (this.foregroundColor = "#92cedd") } } return t.\u0275fac = function(e) { return new(e || t)(Sa(fV), Sa(gV), Sa(LA)) }, t.\u0275cmp = pe({ type: t, selectors: [
                ["activity-detail"]
            ], inputs: { m_ActivitytDriver: "m_ActivitytDriver" }, decls: 7, vars: 11, consts: [
                [1, "container", "left"],
                [1, "content"],
                ["height", "32", 3, "src"],
                ["size", "200", 3, "type", "value", "label", "thick", "max", "foregroundColor", "append"]
            ], template: function(t, e) { 1 & t && (Ia(0, "div"), Ia(1, "div", 0), Ia(2, "div", 1), Oa(3, "img", 2), _o(4), Oa(5, "ngx-gauge", 3), _o(6), Ta(), Ta(), Ta()), 2 & t && (Da("@rubberBand", e.animationState), ps(3), Da("src", e.TitleImage, Zn), ps(1), yo(" ", e.TitleString, " "), ps(1), Da("type", e.gaugeType)("value", e.gaugeValue)("label", e.gaugeLabel)("thick", e.thick)("max", e.max)("foregroundColor", e.foregroundColor)("append", e.gaugeAppendText), ps(1), yo(" Data: ", e.m_ActivitytDriver.m_sDataUsage, " ")) }, directives: [x$], styles: ['*[_ngcontent-%COMP%]{box-sizing:border-box}.open-close-container[_ngcontent-%COMP%]{border:0 solid #0f0f0f;margin-top:0;padding:0 0 0 10px;color:#92cedd;font-weight:700;font-size:17px}body[_ngcontent-%COMP%]{background-color:#475d51;font-family:Helvetica,sans-serif}.timeline[_ngcontent-%COMP%]{position:relative;max-width:1200px;margin:0 auto}.timeline[_ngcontent-%COMP%]:after{content:"";position:absolute;width:6px;background-color:#fff;top:0;bottom:0;left:31px;margin-left:-3px}.container[_ngcontent-%COMP%]{position:relative;background-color:inherit;width:100%;padding:10px 25px 10px 70px}.container[_ngcontent-%COMP%]:before{left:60px;border:solid transparent;border-right:solid #fff;border-width:10px 10px 10px 0}.container[_ngcontent-%COMP%]:after{content:"";position:absolute;width:25px;height:25px;right:-17px;background-color:#264b51;border:2px solid #92cedd;top:15px;border-radius:50%;z-index:1}.left[_ngcontent-%COMP%], .right[_ngcontent-%COMP%]{left:0}.left[_ngcontent-%COMP%]:before{right:30px;border:solid transparent;border-left:solid #92cedd;border-width:10px 0 10px 10px}.left[_ngcontent-%COMP%]:before, .right[_ngcontent-%COMP%]:before{content:" ";height:0;position:absolute;top:22px;width:0;z-index:1}.right[_ngcontent-%COMP%]:before{left:30px;border:solid transparent;border-right:solid #92cedd;border-width:10px 10px 10px 0}.left[_ngcontent-%COMP%]:after, .right[_ngcontent-%COMP%]:after{left:15px}.content[_ngcontent-%COMP%]{padding:20px 30px;background-color:#333;position:relative;border-radius:6px}@media screen and (max-width:600px){.container[_ngcontent-%COMP%]{width:100%;padding-left:70px;padding-right:25px}.container[_ngcontent-%COMP%]:before{left:60px;border:solid transparent;border-right:solid #92cedd;border-width:10px 10px 10px 0}.left[_ngcontent-%COMP%]:after, .right[_ngcontent-%COMP%]:after{left:15px}.right[_ngcontent-%COMP%]{left:0}}'], data: { animation: [sz({ anchor: "enter1" }), sz({ anchor: "enter2", delay: 100 }), sz({ anchor: "enter3", delay: 200, animateChildren: "none" }), CV(), kV(), AV(), OV(), TV(), PV(), LV(), zV(), jV(), WV(), kU(), XV(), oz(), hz(), mz(), QV(), Cz(), ez(), sz(), gz(), yz(), kz(), Wz(), Az(), Pz(), zz(), Xz(), Oz(), Lz(), jz(), Qz(), yU(), eU(), oU(), mU(), CU(), sU(), hU(), gU(), AU(), OU(), PU(), LU(), zU(), jU(), WU(), eH(), sH(), XU(), QU(), oH(), gH(), yH(), hH(), mH(), AH(), OH(), CH(), kH(), jH(), PH(), LH(), zH(), WH(), sj(), XH(), QH(), ej(), oj(), yj(), hj(), mj(), gj(), Cj(), kj(), Aj(), Oj(), Lj({ duration: 400 }), Bj({ duration: 400 }), Vj({ duration: 400 }), zj({ duration: 400 })] } }), t })(); i("yLV6");
    let M$ = new DG([{ id: RG.PROVIDER_ID, provider: new RG("848393748057-21k3c6flaoou7fiihvq4g3td2216pb8b.apps.googleusercontent.com") }]);

    function P$() { return M$ }
    const F$ = [{ path: "Users", component: _G }, { path: "Options", component: yG }, { path: "Pro", component: HG }, { path: "Records", component: JG }];
    let N$ = (() => { class t {} return t.\u0275mod = ye({ type: t, bootstrap: [XG] }), t.\u0275inj = ut({ factory: function(e) { return new(e || t) }, providers: [Av, { provide: DG, useFactory: P$ }, gV, pV, _V, fV], imports: [
                [Ev, S$, lS, YB.forRoot(), gb, Ru, fb, Yb, lS, kA, _k, PF, qR, Mk, ZF, RI, OE, GA, Fk, CF, ER, vM, zE, aR, sO, NS, NB, fN, oN, GI, YS, hT, EO, vT, LT, HN, CB, QM, oB, XP, MO, RN, IG, cg.forRoot(F$, { enableTracing: !1 })]
            ] }), t })(); fe(O$, [yv, vv, Cv, Sv, xv, kv, bv, x$, y$, v$, w$, C$, pd, fd, _d, yd, Id, Ad, xd, Sd, kd, Ed, Dd, qB, U_, s_, l_, kg, $g, Kg, Cg, n_, o_, Yg, Rg, Mg, ib, lb, hb, ub, nb, ab, G_, W_, J_, Y_, K_, z_, L_, R_, yA, rk, tk, SA, vA, Mw, fk, gk, TF, MF, GR, $R, WR, MR, PR, FR, NR, LR, VR, zR, UR, BR, HR, jR, Ak, Tk, qF, zF, XF, UF, BF, VF, _I, cI, kI, SI, II, OI, TI, hI, fI, dI, gI, fE, TE, vE, wE, CE, xE, SE, TA, VA, zA, UA, HA, Pk, vF, fF, gF, _F, yF, bF, uF, kR, dR, uR, BS, pR, fR, mR, yM, Yk, Xk, VE, RE, qO, $O, ZO, YO, XO, KO, XS, rR, sR, QT, WT, iO, HT, PB, mN, rN, aN, zI, jI, qS, cT, lT, yO, vO, bO, CO, SO, wO, _T, PT, RT, UN, mB, wB, $M, qM, HM, FM, jM, YM, KM, VM, UM, PL, BL, qL, HL, NL, ZL, zL, XL, GL, WL, $L, JL, nB, eB, rB, FP, yP, SP, GP, YP, bP, RO, OO, TN, ON, Jf, qf, Yf, Kf, qm, R$, O$, k$, XG, aG, _G, yG, HG, JG, t$, bV, PG, FG, yV, hV, wG, kG, Kj, Gj, oG, n$], [Fd, Vd, Nd, Gd, Qd, qd, Yd, Bd, Xd, zd, Hd, jd, $d]), fe(aG, [yv, vv, Cv, Sv, xv, kv, bv, x$, y$, v$, w$, C$, pd, fd, _d, yd, Id, Ad, xd, Sd, kd, Ed, Dd, qB, U_, s_, l_, kg, $g, Kg, Cg, n_, o_, Yg, Rg, Mg, ib, lb, hb, ub, nb, ab, G_, W_, J_, Y_, K_, z_, L_, R_, yA, rk, tk, SA, vA, Mw, fk, gk, TF, MF, GR, $R, WR, MR, PR, FR, NR, LR, VR, zR, UR, BR, HR, jR, Ak, Tk, qF, zF, XF, UF, BF, VF, _I, cI, kI, SI, II, OI, TI, hI, fI, dI, gI, fE, TE, vE, wE, CE, xE, SE, TA, VA, zA, UA, HA, Pk, vF, fF, gF, _F, yF, bF, uF, kR, dR, uR, BS, pR, fR, mR, yM, Yk, Xk, VE, RE, qO, $O, ZO, YO, XO, KO, XS, rR, sR, QT, WT, iO, HT, PB, mN, rN, aN, zI, jI, qS, cT, lT, yO, vO, bO, CO, SO, wO, _T, PT, RT, UN, mB, wB, $M, qM, HM, FM, jM, YM, KM, VM, UM, PL, BL, qL, HL, NL, ZL, zL, XL, GL, WL, $L, JL, nB, eB, rB, FP, yP, SP, GP, YP, bP, RO, OO, TN, ON, Jf, qf, Yf, Kf, qm, R$, O$, k$, XG, aG, _G, yG, HG, JG, t$, bV, PG, FG, yV, hV, wG, kG, Kj, Gj, oG, n$], [Fd, Vd, Nd, Gd, Qd, qd, Yd, Bd, Xd, zd, Hd, jd, $d]),
    function() { if (xn) throw new Error("Cannot enable prod mode after platform setup.");
        Cn = !1 }(), Tu().bootstrapModule(N$).catch(t => console.error(t))
}, zn8P: function(t, e) {
    function i(t) { return Promise.resolve().then((function() { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e })) } i.keys = function() { return [] }, i.resolve = i, t.exports = i, i.id = "zn8P" }
}, [
    [0, 0]
]]);